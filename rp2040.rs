// Generated by LabWired Codegen
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
pub mod watchdog { # [doc = "No description"] pub struct WATCHDOG ; impl WATCHDOG { pub const BASE_ADDR : u64 = 1074102272u64 ; } # [doc = "Watchdog control \n                    The rst_wdsel register determines which subsystems are reset when the watchdog is triggered. \n                    The watchdog can be triggered in software."] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 117440512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset will be triggered"] pub fn time (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Pause the watchdog timer when JTAG is accessing the bus fabric"] pub fn pause_jtag (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pause the watchdog timer when JTAG is accessing the bus fabric"] pub fn set_pause_jtag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pause the watchdog timer when processor 0 is in debug mode"] pub fn pause_dbg0 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pause the watchdog timer when processor 0 is in debug mode"] pub fn set_pause_dbg0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pause the watchdog timer when processor 1 is in debug mode"] pub fn pause_dbg1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pause the watchdog timer when processor 1 is in debug mode"] pub fn set_pause_dbg1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "When not enabled the watchdog timer is paused"] pub fn enable (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When not enabled the watchdog timer is paused"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Trigger a watchdog reset"] pub fn trigger (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Trigger a watchdog reset"] pub fn set_trigger (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1)."] pub struct LOAD (u32) ; impl LOAD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn load (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "No description"] pub fn set_load (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Logs the reason for the last reset. Both bits are zero for the case of a hardware reset."] pub struct REASON (u32) ; impl REASON { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timer (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn force (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH0 (u32) ; impl SCRATCH0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH1 (u32) ; impl SCRATCH1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH2 (u32) ; impl SCRATCH2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH3 (u32) ; impl SCRATCH3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH4 (u32) ; impl SCRATCH4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch4 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch4 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH5 (u32) ; impl SCRATCH5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch5 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch5 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH6 (u32) ; impl SCRATCH6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch6 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch6 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Scratch register. Information persists through soft reset of the chip."] pub struct SCRATCH7 (u32) ; impl SCRATCH7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn scratch7 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_scratch7 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the tick generator"] pub struct TICK (u32) ; impl TICK { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Total number of clk_tick cycles before the next tick."] pub fn cycles (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Total number of clk_tick cycles before the next tick."] pub fn set_cycles (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "start / stop tick generation"] pub fn enable (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "start / stop tick generation"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Is the tick generator running?"] pub fn running (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Count down timer: the remaining number clk_tick cycles before the next tick is generated."] pub fn count (& self) -> u32 { (self . 0 >> 11u32) & 511u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod vreg_and_chip_reset { # [doc = "control and status for on-chip voltage regulator and chip level reset subsystem"] pub struct VREG_AND_CHIP_RESET ; impl VREG_AND_CHIP_RESET { pub const BASE_ADDR : u64 = 1074151424u64 ; } # [doc = "Voltage regulator control and status"] pub struct VREG (u32) ; impl VREG { pub const RESET_VALUE : u32 = 177u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "enable \n                            0=not enabled, 1=enabled"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "enable \n                            0=not enabled, 1=enabled"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "high impedance mode select \n                            0=not in high impedance mode, 1=in high impedance mode"] pub fn hiz (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "high impedance mode select \n                            0=not in high impedance mode, 1=in high impedance mode"] pub fn set_hiz (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "output voltage select \n                            0000 to 0101 - 0.80V \n                            0110         - 0.85V \n                            0111         - 0.90V \n                            1000         - 0.95V \n                            1001         - 1.00V \n                            1010         - 1.05V \n                            1011         - 1.10V (default) \n                            1100         - 1.15V \n                            1101         - 1.20V \n                            1110         - 1.25V \n                            1111         - 1.30V"] pub fn vsel (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "output voltage select \n                            0000 to 0101 - 0.80V \n                            0110         - 0.85V \n                            0111         - 0.90V \n                            1000         - 0.95V \n                            1001         - 1.00V \n                            1010         - 1.05V \n                            1011         - 1.10V (default) \n                            1100         - 1.15V \n                            1101         - 1.20V \n                            1110         - 1.25V \n                            1111         - 1.30V"] pub fn set_vsel (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "regulation status \n                            0=not in regulation, 1=in regulation"] pub fn rok (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "brown-out detection control"] pub struct BOD (u32) ; impl BOD { pub const RESET_VALUE : u32 = 145u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "enable \n                            0=not enabled, 1=enabled"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "enable \n                            0=not enabled, 1=enabled"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "threshold select \n                            0000 - 0.473V \n                            0001 - 0.516V \n                            0010 - 0.559V \n                            0011 - 0.602V \n                            0100 - 0.645V \n                            0101 - 0.688V \n                            0110 - 0.731V \n                            0111 - 0.774V \n                            1000 - 0.817V \n                            1001 - 0.860V (default) \n                            1010 - 0.903V \n                            1011 - 0.946V \n                            1100 - 0.989V \n                            1101 - 1.032V \n                            1110 - 1.075V \n                            1111 - 1.118V"] pub fn vsel (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "threshold select \n                            0000 - 0.473V \n                            0001 - 0.516V \n                            0010 - 0.559V \n                            0011 - 0.602V \n                            0100 - 0.645V \n                            0101 - 0.688V \n                            0110 - 0.731V \n                            0111 - 0.774V \n                            1000 - 0.817V \n                            1001 - 0.860V (default) \n                            1010 - 0.903V \n                            1011 - 0.946V \n                            1100 - 0.989V \n                            1101 - 1.032V \n                            1110 - 1.075V \n                            1111 - 1.118V"] pub fn set_vsel (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Chip reset control and status"] pub struct CHIP_RESET (u32) ; impl CHIP_RESET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Last reset was from the power-on reset or brown-out detection blocks"] pub fn had_por (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Last reset was from the RUN pin"] pub fn had_run (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Last reset was from the debug port"] pub fn had_psm_restart (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "This is set by psm_restart from the debugger. \n                            Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up. \n                            In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor."] pub fn psm_restart_flag (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "This is set by psm_restart from the debugger. \n                            Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up. \n                            In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor."] pub fn set_psm_restart_flag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pwm { # [doc = "Simple PWM"] pub struct PWM ; impl PWM { pub const BASE_ADDR : u64 = 1074069504u64 ; } # [doc = "Control and status register"] pub struct CH0_CSR (u32) ; impl CH0_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH0_DIV (u32) ; impl CH0_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH0_CTR (u32) ; impl CH0_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch0_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH0_CC (u32) ; impl CH0_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH0_TOP (u32) ; impl CH0_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch0_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH1_CSR (u32) ; impl CH1_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH1_DIV (u32) ; impl CH1_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH1_CTR (u32) ; impl CH1_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch1_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH1_CC (u32) ; impl CH1_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH1_TOP (u32) ; impl CH1_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch1_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH2_CSR (u32) ; impl CH2_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH2_DIV (u32) ; impl CH2_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH2_CTR (u32) ; impl CH2_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch2_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH2_CC (u32) ; impl CH2_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH2_TOP (u32) ; impl CH2_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch2_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH3_CSR (u32) ; impl CH3_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH3_DIV (u32) ; impl CH3_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH3_CTR (u32) ; impl CH3_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch3_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH3_CC (u32) ; impl CH3_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH3_TOP (u32) ; impl CH3_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch3_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH4_CSR (u32) ; impl CH4_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH4_DIV (u32) ; impl CH4_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH4_CTR (u32) ; impl CH4_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch4_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH4_CC (u32) ; impl CH4_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH4_TOP (u32) ; impl CH4_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch4_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH5_CSR (u32) ; impl CH5_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH5_DIV (u32) ; impl CH5_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH5_CTR (u32) ; impl CH5_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch5_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH5_CC (u32) ; impl CH5_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH5_TOP (u32) ; impl CH5_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch5_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH6_CSR (u32) ; impl CH6_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH6_DIV (u32) ; impl CH6_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH6_CTR (u32) ; impl CH6_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch6_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH6_CC (u32) ; impl CH6_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH6_TOP (u32) ; impl CH6_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch6_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register"] pub struct CH7_CSR (u32) ; impl CH7_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable the PWM channel."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable the PWM channel."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn ph_correct (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "1: Enable phase-correct modulation. 0: Trailing-edge"] pub fn set_ph_correct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Invert output A"] pub fn a_inv (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Invert output A"] pub fn set_a_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Invert output B"] pub fn b_inv (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Invert output B"] pub fn set_b_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn divmode (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "No description"] pub fn set_divmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn ph_ret (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Retard the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running."] pub fn set_ph_ret (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn ph_adv (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Advance the phase of the counter by 1 count, while it is running. \n                            Self-clearing. Write a 1, and poll until low. Counter must be running \n                            at less than full speed (div_int + div_frac / 16 > 1)"] pub fn set_ph_adv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "INT and FRAC form a fixed-point fractional number. \n                    Counting rate is system clock frequency divided by this number. \n                    Fractional division uses simple 1st-order sigma-delta."] pub struct CH7_DIV (u32) ; impl CH7_DIV { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn int (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "No description"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct access to the PWM counter"] pub struct CH7_CTR (u32) ; impl CH7_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_ctr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch7_ctr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter compare values"] pub struct CH7_CC (u32) ; impl CH7_CC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_a (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn b (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter wrap value"] pub struct CH7_TOP (u32) ; impl CH7_TOP { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_top (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_ch7_top (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "This register aliases the CSR_EN bits for all channels. \n                    Writing to this register allows multiple channels to be enabled \n                    or disabled simultaneously, so they can run in perfect sync. \n                    For each channel, there is only one physical EN register bit, \n                    which can be accessed through here or CHx_CSR."] pub struct EN (u32) ; impl EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tbman { # [doc = "Testbench manager. Allows the programmer to know what platform their software is running on."] pub struct TBMAN ; impl TBMAN { pub const BASE_ADDR : u64 = 1074184192u64 ; } # [doc = "Indicates the type of platform in use"] pub struct PLATFORM (u32) ; impl PLATFORM { pub const RESET_VALUE : u32 = 5u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates the platform is an ASIC"] pub fn asic (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Indicates the platform is an FPGA"] pub fn fpga (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod dma { # [doc = "DMA with separate read and write masters"] pub struct DMA ; impl DMA { pub const BASE_ADDR : u64 = 1342177280u64 ; } # [doc = "DMA Channel 0 Read Address pointer"] pub struct CH0_READ_ADDR (u32) ; impl CH0_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch0_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch0_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 0 Write Address pointer"] pub struct CH0_WRITE_ADDR (u32) ; impl CH0_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch0_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch0_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 0 Transfer Count"] pub struct CH0_TRANS_COUNT (u32) ; impl CH0_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch0_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch0_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 0 Control and Status"] pub struct CH0_CTRL_TRIG (u32) ; impl CH0_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 CTRL register"] pub struct CH0_AL1_CTRL (u32) ; impl CH0_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 READ_ADDR register"] pub struct CH0_AL1_READ_ADDR (u32) ; impl CH0_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 WRITE_ADDR register"] pub struct CH0_AL1_WRITE_ADDR (u32) ; impl CH0_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH0_AL1_TRANS_COUNT_TRIG (u32) ; impl CH0_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 CTRL register"] pub struct CH0_AL2_CTRL (u32) ; impl CH0_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 TRANS_COUNT register"] pub struct CH0_AL2_TRANS_COUNT (u32) ; impl CH0_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 READ_ADDR register"] pub struct CH0_AL2_READ_ADDR (u32) ; impl CH0_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH0_AL2_WRITE_ADDR_TRIG (u32) ; impl CH0_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 CTRL register"] pub struct CH0_AL3_CTRL (u32) ; impl CH0_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 WRITE_ADDR register"] pub struct CH0_AL3_WRITE_ADDR (u32) ; impl CH0_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 TRANS_COUNT register"] pub struct CH0_AL3_TRANS_COUNT (u32) ; impl CH0_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 0 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH0_AL3_READ_ADDR_TRIG (u32) ; impl CH0_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch0_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 1 Read Address pointer"] pub struct CH1_READ_ADDR (u32) ; impl CH1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 1 Write Address pointer"] pub struct CH1_WRITE_ADDR (u32) ; impl CH1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 1 Transfer Count"] pub struct CH1_TRANS_COUNT (u32) ; impl CH1_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch1_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch1_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 1 Control and Status"] pub struct CH1_CTRL_TRIG (u32) ; impl CH1_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 CTRL register"] pub struct CH1_AL1_CTRL (u32) ; impl CH1_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 READ_ADDR register"] pub struct CH1_AL1_READ_ADDR (u32) ; impl CH1_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 WRITE_ADDR register"] pub struct CH1_AL1_WRITE_ADDR (u32) ; impl CH1_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH1_AL1_TRANS_COUNT_TRIG (u32) ; impl CH1_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 CTRL register"] pub struct CH1_AL2_CTRL (u32) ; impl CH1_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 TRANS_COUNT register"] pub struct CH1_AL2_TRANS_COUNT (u32) ; impl CH1_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 READ_ADDR register"] pub struct CH1_AL2_READ_ADDR (u32) ; impl CH1_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH1_AL2_WRITE_ADDR_TRIG (u32) ; impl CH1_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 CTRL register"] pub struct CH1_AL3_CTRL (u32) ; impl CH1_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 WRITE_ADDR register"] pub struct CH1_AL3_WRITE_ADDR (u32) ; impl CH1_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 TRANS_COUNT register"] pub struct CH1_AL3_TRANS_COUNT (u32) ; impl CH1_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 1 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH1_AL3_READ_ADDR_TRIG (u32) ; impl CH1_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch1_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 2 Read Address pointer"] pub struct CH2_READ_ADDR (u32) ; impl CH2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 2 Write Address pointer"] pub struct CH2_WRITE_ADDR (u32) ; impl CH2_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch2_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch2_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 2 Transfer Count"] pub struct CH2_TRANS_COUNT (u32) ; impl CH2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 2 Control and Status"] pub struct CH2_CTRL_TRIG (u32) ; impl CH2_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 CTRL register"] pub struct CH2_AL1_CTRL (u32) ; impl CH2_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 READ_ADDR register"] pub struct CH2_AL1_READ_ADDR (u32) ; impl CH2_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 WRITE_ADDR register"] pub struct CH2_AL1_WRITE_ADDR (u32) ; impl CH2_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH2_AL1_TRANS_COUNT_TRIG (u32) ; impl CH2_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 CTRL register"] pub struct CH2_AL2_CTRL (u32) ; impl CH2_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 TRANS_COUNT register"] pub struct CH2_AL2_TRANS_COUNT (u32) ; impl CH2_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 READ_ADDR register"] pub struct CH2_AL2_READ_ADDR (u32) ; impl CH2_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH2_AL2_WRITE_ADDR_TRIG (u32) ; impl CH2_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 CTRL register"] pub struct CH2_AL3_CTRL (u32) ; impl CH2_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 WRITE_ADDR register"] pub struct CH2_AL3_WRITE_ADDR (u32) ; impl CH2_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 TRANS_COUNT register"] pub struct CH2_AL3_TRANS_COUNT (u32) ; impl CH2_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 2 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH2_AL3_READ_ADDR_TRIG (u32) ; impl CH2_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch2_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 3 Read Address pointer"] pub struct CH3_READ_ADDR (u32) ; impl CH3_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch3_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch3_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 3 Write Address pointer"] pub struct CH3_WRITE_ADDR (u32) ; impl CH3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 3 Transfer Count"] pub struct CH3_TRANS_COUNT (u32) ; impl CH3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 3 Control and Status"] pub struct CH3_CTRL_TRIG (u32) ; impl CH3_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 CTRL register"] pub struct CH3_AL1_CTRL (u32) ; impl CH3_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 READ_ADDR register"] pub struct CH3_AL1_READ_ADDR (u32) ; impl CH3_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 WRITE_ADDR register"] pub struct CH3_AL1_WRITE_ADDR (u32) ; impl CH3_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH3_AL1_TRANS_COUNT_TRIG (u32) ; impl CH3_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 CTRL register"] pub struct CH3_AL2_CTRL (u32) ; impl CH3_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 TRANS_COUNT register"] pub struct CH3_AL2_TRANS_COUNT (u32) ; impl CH3_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 READ_ADDR register"] pub struct CH3_AL2_READ_ADDR (u32) ; impl CH3_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH3_AL2_WRITE_ADDR_TRIG (u32) ; impl CH3_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 CTRL register"] pub struct CH3_AL3_CTRL (u32) ; impl CH3_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 WRITE_ADDR register"] pub struct CH3_AL3_WRITE_ADDR (u32) ; impl CH3_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 TRANS_COUNT register"] pub struct CH3_AL3_TRANS_COUNT (u32) ; impl CH3_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 3 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH3_AL3_READ_ADDR_TRIG (u32) ; impl CH3_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch3_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 4 Read Address pointer"] pub struct CH4_READ_ADDR (u32) ; impl CH4_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch4_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch4_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 4 Write Address pointer"] pub struct CH4_WRITE_ADDR (u32) ; impl CH4_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch4_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch4_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 4 Transfer Count"] pub struct CH4_TRANS_COUNT (u32) ; impl CH4_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch4_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch4_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 4 Control and Status"] pub struct CH4_CTRL_TRIG (u32) ; impl CH4_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 CTRL register"] pub struct CH4_AL1_CTRL (u32) ; impl CH4_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 READ_ADDR register"] pub struct CH4_AL1_READ_ADDR (u32) ; impl CH4_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 WRITE_ADDR register"] pub struct CH4_AL1_WRITE_ADDR (u32) ; impl CH4_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH4_AL1_TRANS_COUNT_TRIG (u32) ; impl CH4_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 CTRL register"] pub struct CH4_AL2_CTRL (u32) ; impl CH4_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 TRANS_COUNT register"] pub struct CH4_AL2_TRANS_COUNT (u32) ; impl CH4_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 READ_ADDR register"] pub struct CH4_AL2_READ_ADDR (u32) ; impl CH4_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH4_AL2_WRITE_ADDR_TRIG (u32) ; impl CH4_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 CTRL register"] pub struct CH4_AL3_CTRL (u32) ; impl CH4_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 WRITE_ADDR register"] pub struct CH4_AL3_WRITE_ADDR (u32) ; impl CH4_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 TRANS_COUNT register"] pub struct CH4_AL3_TRANS_COUNT (u32) ; impl CH4_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 4 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH4_AL3_READ_ADDR_TRIG (u32) ; impl CH4_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch4_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 5 Read Address pointer"] pub struct CH5_READ_ADDR (u32) ; impl CH5_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch5_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch5_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 5 Write Address pointer"] pub struct CH5_WRITE_ADDR (u32) ; impl CH5_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch5_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch5_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 5 Transfer Count"] pub struct CH5_TRANS_COUNT (u32) ; impl CH5_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch5_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch5_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 5 Control and Status"] pub struct CH5_CTRL_TRIG (u32) ; impl CH5_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 CTRL register"] pub struct CH5_AL1_CTRL (u32) ; impl CH5_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 READ_ADDR register"] pub struct CH5_AL1_READ_ADDR (u32) ; impl CH5_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 WRITE_ADDR register"] pub struct CH5_AL1_WRITE_ADDR (u32) ; impl CH5_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH5_AL1_TRANS_COUNT_TRIG (u32) ; impl CH5_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 CTRL register"] pub struct CH5_AL2_CTRL (u32) ; impl CH5_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 TRANS_COUNT register"] pub struct CH5_AL2_TRANS_COUNT (u32) ; impl CH5_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 READ_ADDR register"] pub struct CH5_AL2_READ_ADDR (u32) ; impl CH5_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH5_AL2_WRITE_ADDR_TRIG (u32) ; impl CH5_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 CTRL register"] pub struct CH5_AL3_CTRL (u32) ; impl CH5_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 WRITE_ADDR register"] pub struct CH5_AL3_WRITE_ADDR (u32) ; impl CH5_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 TRANS_COUNT register"] pub struct CH5_AL3_TRANS_COUNT (u32) ; impl CH5_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 5 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH5_AL3_READ_ADDR_TRIG (u32) ; impl CH5_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch5_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 6 Read Address pointer"] pub struct CH6_READ_ADDR (u32) ; impl CH6_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch6_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch6_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 6 Write Address pointer"] pub struct CH6_WRITE_ADDR (u32) ; impl CH6_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch6_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch6_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 6 Transfer Count"] pub struct CH6_TRANS_COUNT (u32) ; impl CH6_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch6_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch6_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 6 Control and Status"] pub struct CH6_CTRL_TRIG (u32) ; impl CH6_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 CTRL register"] pub struct CH6_AL1_CTRL (u32) ; impl CH6_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 READ_ADDR register"] pub struct CH6_AL1_READ_ADDR (u32) ; impl CH6_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 WRITE_ADDR register"] pub struct CH6_AL1_WRITE_ADDR (u32) ; impl CH6_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH6_AL1_TRANS_COUNT_TRIG (u32) ; impl CH6_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 CTRL register"] pub struct CH6_AL2_CTRL (u32) ; impl CH6_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 TRANS_COUNT register"] pub struct CH6_AL2_TRANS_COUNT (u32) ; impl CH6_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 READ_ADDR register"] pub struct CH6_AL2_READ_ADDR (u32) ; impl CH6_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH6_AL2_WRITE_ADDR_TRIG (u32) ; impl CH6_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 CTRL register"] pub struct CH6_AL3_CTRL (u32) ; impl CH6_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 WRITE_ADDR register"] pub struct CH6_AL3_WRITE_ADDR (u32) ; impl CH6_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 TRANS_COUNT register"] pub struct CH6_AL3_TRANS_COUNT (u32) ; impl CH6_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 6 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH6_AL3_READ_ADDR_TRIG (u32) ; impl CH6_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch6_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 7 Read Address pointer"] pub struct CH7_READ_ADDR (u32) ; impl CH7_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch7_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch7_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 7 Write Address pointer"] pub struct CH7_WRITE_ADDR (u32) ; impl CH7_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch7_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch7_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 7 Transfer Count"] pub struct CH7_TRANS_COUNT (u32) ; impl CH7_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch7_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch7_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 7 Control and Status"] pub struct CH7_CTRL_TRIG (u32) ; impl CH7_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 CTRL register"] pub struct CH7_AL1_CTRL (u32) ; impl CH7_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 READ_ADDR register"] pub struct CH7_AL1_READ_ADDR (u32) ; impl CH7_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 WRITE_ADDR register"] pub struct CH7_AL1_WRITE_ADDR (u32) ; impl CH7_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH7_AL1_TRANS_COUNT_TRIG (u32) ; impl CH7_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 CTRL register"] pub struct CH7_AL2_CTRL (u32) ; impl CH7_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 TRANS_COUNT register"] pub struct CH7_AL2_TRANS_COUNT (u32) ; impl CH7_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 READ_ADDR register"] pub struct CH7_AL2_READ_ADDR (u32) ; impl CH7_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH7_AL2_WRITE_ADDR_TRIG (u32) ; impl CH7_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 CTRL register"] pub struct CH7_AL3_CTRL (u32) ; impl CH7_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 WRITE_ADDR register"] pub struct CH7_AL3_WRITE_ADDR (u32) ; impl CH7_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 TRANS_COUNT register"] pub struct CH7_AL3_TRANS_COUNT (u32) ; impl CH7_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 7 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH7_AL3_READ_ADDR_TRIG (u32) ; impl CH7_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch7_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 8 Read Address pointer"] pub struct CH8_READ_ADDR (u32) ; impl CH8_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch8_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch8_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 8 Write Address pointer"] pub struct CH8_WRITE_ADDR (u32) ; impl CH8_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch8_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch8_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 8 Transfer Count"] pub struct CH8_TRANS_COUNT (u32) ; impl CH8_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch8_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch8_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 8 Control and Status"] pub struct CH8_CTRL_TRIG (u32) ; impl CH8_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 CTRL register"] pub struct CH8_AL1_CTRL (u32) ; impl CH8_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 READ_ADDR register"] pub struct CH8_AL1_READ_ADDR (u32) ; impl CH8_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 WRITE_ADDR register"] pub struct CH8_AL1_WRITE_ADDR (u32) ; impl CH8_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH8_AL1_TRANS_COUNT_TRIG (u32) ; impl CH8_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 CTRL register"] pub struct CH8_AL2_CTRL (u32) ; impl CH8_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 TRANS_COUNT register"] pub struct CH8_AL2_TRANS_COUNT (u32) ; impl CH8_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 READ_ADDR register"] pub struct CH8_AL2_READ_ADDR (u32) ; impl CH8_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH8_AL2_WRITE_ADDR_TRIG (u32) ; impl CH8_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 CTRL register"] pub struct CH8_AL3_CTRL (u32) ; impl CH8_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 WRITE_ADDR register"] pub struct CH8_AL3_WRITE_ADDR (u32) ; impl CH8_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 TRANS_COUNT register"] pub struct CH8_AL3_TRANS_COUNT (u32) ; impl CH8_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 8 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH8_AL3_READ_ADDR_TRIG (u32) ; impl CH8_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch8_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 9 Read Address pointer"] pub struct CH9_READ_ADDR (u32) ; impl CH9_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch9_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch9_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 9 Write Address pointer"] pub struct CH9_WRITE_ADDR (u32) ; impl CH9_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch9_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch9_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 9 Transfer Count"] pub struct CH9_TRANS_COUNT (u32) ; impl CH9_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch9_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch9_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 9 Control and Status"] pub struct CH9_CTRL_TRIG (u32) ; impl CH9_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 CTRL register"] pub struct CH9_AL1_CTRL (u32) ; impl CH9_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 READ_ADDR register"] pub struct CH9_AL1_READ_ADDR (u32) ; impl CH9_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 WRITE_ADDR register"] pub struct CH9_AL1_WRITE_ADDR (u32) ; impl CH9_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH9_AL1_TRANS_COUNT_TRIG (u32) ; impl CH9_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 CTRL register"] pub struct CH9_AL2_CTRL (u32) ; impl CH9_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 TRANS_COUNT register"] pub struct CH9_AL2_TRANS_COUNT (u32) ; impl CH9_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 READ_ADDR register"] pub struct CH9_AL2_READ_ADDR (u32) ; impl CH9_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH9_AL2_WRITE_ADDR_TRIG (u32) ; impl CH9_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 CTRL register"] pub struct CH9_AL3_CTRL (u32) ; impl CH9_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 WRITE_ADDR register"] pub struct CH9_AL3_WRITE_ADDR (u32) ; impl CH9_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 TRANS_COUNT register"] pub struct CH9_AL3_TRANS_COUNT (u32) ; impl CH9_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 9 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH9_AL3_READ_ADDR_TRIG (u32) ; impl CH9_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch9_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 10 Read Address pointer"] pub struct CH10_READ_ADDR (u32) ; impl CH10_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch10_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch10_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 10 Write Address pointer"] pub struct CH10_WRITE_ADDR (u32) ; impl CH10_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch10_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch10_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 10 Transfer Count"] pub struct CH10_TRANS_COUNT (u32) ; impl CH10_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch10_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch10_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 10 Control and Status"] pub struct CH10_CTRL_TRIG (u32) ; impl CH10_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 CTRL register"] pub struct CH10_AL1_CTRL (u32) ; impl CH10_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 READ_ADDR register"] pub struct CH10_AL1_READ_ADDR (u32) ; impl CH10_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 WRITE_ADDR register"] pub struct CH10_AL1_WRITE_ADDR (u32) ; impl CH10_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH10_AL1_TRANS_COUNT_TRIG (u32) ; impl CH10_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 CTRL register"] pub struct CH10_AL2_CTRL (u32) ; impl CH10_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 TRANS_COUNT register"] pub struct CH10_AL2_TRANS_COUNT (u32) ; impl CH10_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 READ_ADDR register"] pub struct CH10_AL2_READ_ADDR (u32) ; impl CH10_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH10_AL2_WRITE_ADDR_TRIG (u32) ; impl CH10_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 CTRL register"] pub struct CH10_AL3_CTRL (u32) ; impl CH10_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 WRITE_ADDR register"] pub struct CH10_AL3_WRITE_ADDR (u32) ; impl CH10_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 TRANS_COUNT register"] pub struct CH10_AL3_TRANS_COUNT (u32) ; impl CH10_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 10 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH10_AL3_READ_ADDR_TRIG (u32) ; impl CH10_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch10_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 11 Read Address pointer"] pub struct CH11_READ_ADDR (u32) ; impl CH11_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn ch11_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a read completes. The current value is the next address to be read by this channel."] pub fn set_ch11_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 11 Write Address pointer"] pub struct CH11_WRITE_ADDR (u32) ; impl CH11_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn ch11_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This register updates automatically each time a write completes. The current value is the next address to be written by this channel."] pub fn set_ch11_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 11 Transfer Count"] pub struct CH11_TRANS_COUNT (u32) ; impl CH11_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn ch11_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n                            When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes.\n\n                            Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write.\n\n                            The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD."] pub fn set_ch11_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Channel 11 Control and Status"] pub struct CH11_CTRL_TRIG (u32) ; impl CH11_CTRL_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DMA Channel Enable. \n                            When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn high_priority (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels.\n\n                            This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput."] pub fn set_high_priority (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn data_size (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer."] pub fn set_data_size (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn incr_read (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address.\n\n                            Generally this should be disabled for peripheral-to-memory transfers."] pub fn set_incr_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn incr_write (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address.\n\n                            Generally this should be disabled for memory-to-peripheral transfers."] pub fn set_incr_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn ring_size (& self) -> u32 { (self . 0 >> 6u32) & 15u32 } # [doc = "Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers.\n\n                            Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL."] pub fn set_ring_size (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn ring_sel (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Select whether RING_SIZE applies to read or write addresses. \n                            If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped."] pub fn set_ring_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn chain_to (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_."] pub fn set_chain_to (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn treq_sel (& self) -> u32 { (self . 0 >> 15u32) & 63u32 } # [doc = "Select a Transfer Request signal. \n                            The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). \n                            0x0 to 0x3a -> select DREQ n as TREQ"] pub fn set_treq_sel (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn irq_quiet (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain.\n\n                            This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks."] pub fn set_irq_quiet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn bswap (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Apply byte-swap transformation to DMA data. \n                            For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn sniff_en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected.\n\n                            This allows checksum to be enabled or disabled on a per-control- block basis."] pub fn set_sniff_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused.\n\n                            To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT."] pub fn busy (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn write_error (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, the channel received a write bus error. Write one to clear. \n                            WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)"] pub fn set_write_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn read_error (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the channel received a read bus error. Write one to clear. \n                            READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)"] pub fn set_read_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag."] pub fn ahb_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 CTRL register"] pub struct CH11_AL1_CTRL (u32) ; impl CH11_AL1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al1_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al1_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 READ_ADDR register"] pub struct CH11_AL1_READ_ADDR (u32) ; impl CH11_AL1_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al1_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al1_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 WRITE_ADDR register"] pub struct CH11_AL1_WRITE_ADDR (u32) ; impl CH11_AL1_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al1_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al1_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 TRANS_COUNT register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH11_AL1_TRANS_COUNT_TRIG (u32) ; impl CH11_AL1_TRANS_COUNT_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al1_trans_count_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al1_trans_count_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 CTRL register"] pub struct CH11_AL2_CTRL (u32) ; impl CH11_AL2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al2_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al2_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 TRANS_COUNT register"] pub struct CH11_AL2_TRANS_COUNT (u32) ; impl CH11_AL2_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al2_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al2_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 READ_ADDR register"] pub struct CH11_AL2_READ_ADDR (u32) ; impl CH11_AL2_READ_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al2_read_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al2_read_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 WRITE_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH11_AL2_WRITE_ADDR_TRIG (u32) ; impl CH11_AL2_WRITE_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al2_write_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al2_write_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 CTRL register"] pub struct CH11_AL3_CTRL (u32) ; impl CH11_AL3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al3_ctrl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al3_ctrl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 WRITE_ADDR register"] pub struct CH11_AL3_WRITE_ADDR (u32) ; impl CH11_AL3_WRITE_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al3_write_addr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al3_write_addr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 TRANS_COUNT register"] pub struct CH11_AL3_TRANS_COUNT (u32) ; impl CH11_AL3_TRANS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al3_trans_count (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al3_trans_count (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alias for channel 11 READ_ADDR register \n                    This is a trigger register (0xc). Writing a nonzero value will \n                    reload the channel counter and start the channel."] pub struct CH11_AL3_READ_ADDR_TRIG (u32) ; impl CH11_AL3_READ_ADDR_TRIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_al3_read_addr_trig (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_ch11_al3_read_addr_trig (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Status (raw)"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n                            Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n                            This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n                            It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0."] pub fn intr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n                            Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n                            This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n                            It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0."] pub fn set_intr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enables for IRQ 0"] pub struct INTE0 (u32) ; impl INTE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set bit n to pass interrupts from channel n to DMA IRQ 0."] pub fn inte0 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Set bit n to pass interrupts from channel n to DMA IRQ 0."] pub fn set_inte0 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Force Interrupts"] pub struct INTF0 (u32) ; impl INTF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared."] pub fn intf0 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared."] pub fn set_intf0 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Status for IRQ 0"] pub struct INTS0 (u32) ; impl INTS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted. \n                            Channel interrupts can be cleared by writing a bit mask here."] pub fn ints0 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted. \n                            Channel interrupts can be cleared by writing a bit mask here."] pub fn set_ints0 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Status (raw)"] pub struct INTR1 (u32) ; impl INTR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n                            Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n                            This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n                            It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0."] pub fn intr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1.\n\n                            Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1.\n\n                            This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores.\n\n                            It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0."] pub fn set_intr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enables for IRQ 1"] pub struct INTE1 (u32) ; impl INTE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set bit n to pass interrupts from channel n to DMA IRQ 1."] pub fn inte1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Set bit n to pass interrupts from channel n to DMA IRQ 1."] pub fn set_inte1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Force Interrupts for IRQ 1"] pub struct INTF1 (u32) ; impl INTF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared."] pub fn intf1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared."] pub fn set_intf1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Status (masked) for IRQ 1"] pub struct INTS1 (u32) ; impl INTS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted. \n                            Channel interrupts can be cleared by writing a bit mask here."] pub fn ints1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted. \n                            Channel interrupts can be cleared by writing a bit mask here."] pub fn set_ints1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pacing (X/Y) Fractional Timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."] pub struct TIMER0 (u32) ; impl TIMER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn y (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn set_y (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn x (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn set_x (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pacing (X/Y) Fractional Timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."] pub struct TIMER1 (u32) ; impl TIMER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn y (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn set_y (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn x (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn set_x (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pacing (X/Y) Fractional Timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."] pub struct TIMER2 (u32) ; impl TIMER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn y (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn set_y (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn x (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn set_x (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pacing (X/Y) Fractional Timer \n                    The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less."] pub struct TIMER3 (u32) ; impl TIMER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn y (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer."] pub fn set_y (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn x (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer."] pub fn set_x (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Trigger one or more channels simultaneously"] pub struct MULTI_CHAN_TRIGGER (u32) ; impl MULTI_CHAN_TRIGGER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy."] pub fn multi_chan_trigger (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy."] pub fn set_multi_chan_trigger (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sniffer Control"] pub struct SNIFF_CTRL (u32) ; impl SNIFF_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable sniffer"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable sniffer"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA channel for Sniffer to observe"] pub fn dmach (& self) -> u32 { (self . 0 >> 1u32) & 15u32 } # [doc = "DMA channel for Sniffer to observe"] pub fn set_dmach (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn calc (& self) -> u32 { (self . 0 >> 5u32) & 15u32 } # [doc = "No description"] pub fn set_calc (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Locally perform a byte reverse on the sniffed data, before feeding into checksum.\n\n                            Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view."] pub fn bswap (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Locally perform a byte reverse on the sniffed data, before feeding into checksum.\n\n                            Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view."] pub fn set_bswap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus."] pub fn out_rev (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus."] pub fn set_out_rev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus."] pub fn out_inv (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus."] pub fn set_out_inv (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data accumulator for sniff hardware"] pub struct SNIFF_DATA (u32) ; impl SNIFF_DATA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register."] pub fn sniff_data (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register."] pub fn set_sniff_data (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Debug RAF, WAF, TDF levels"] pub struct FIFO_LEVELS (u32) ; impl FIFO_LEVELS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Current Transfer-Data-FIFO fill level"] pub fn tdf_lvl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Current Write-Address-FIFO fill level"] pub fn waf_lvl (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Current Read-Address-FIFO fill level"] pub fn raf_lvl (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Abort an in-progress transfer sequence on one or more channels"] pub struct CHAN_ABORT (u32) ; impl CHAN_ABORT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.\n\n                            After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel."] pub fn chan_abort (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs.\n\n                            After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel."] pub fn set_chan_abort (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area."] pub struct N_CHANNELS (u32) ; impl N_CHANNELS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn n_channels (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH0_DBG_CTDREQ (u32) ; impl CH0_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch0_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH0_DBG_TCR (u32) ; impl CH0_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch0_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH1_DBG_CTDREQ (u32) ; impl CH1_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch1_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH1_DBG_TCR (u32) ; impl CH1_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch1_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH2_DBG_CTDREQ (u32) ; impl CH2_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch2_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH2_DBG_TCR (u32) ; impl CH2_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch2_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH3_DBG_CTDREQ (u32) ; impl CH3_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch3_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH3_DBG_TCR (u32) ; impl CH3_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch3_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH4_DBG_CTDREQ (u32) ; impl CH4_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch4_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH4_DBG_TCR (u32) ; impl CH4_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch4_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH5_DBG_CTDREQ (u32) ; impl CH5_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch5_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH5_DBG_TCR (u32) ; impl CH5_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch5_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH6_DBG_CTDREQ (u32) ; impl CH6_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch6_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH6_DBG_TCR (u32) ; impl CH6_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch6_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH7_DBG_CTDREQ (u32) ; impl CH7_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch7_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH7_DBG_TCR (u32) ; impl CH7_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch7_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH8_DBG_CTDREQ (u32) ; impl CH8_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch8_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH8_DBG_TCR (u32) ; impl CH8_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch8_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH9_DBG_CTDREQ (u32) ; impl CH9_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch9_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH9_DBG_TCR (u32) ; impl CH9_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch9_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH10_DBG_CTDREQ (u32) ; impl CH10_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch10_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH10_DBG_TCR (u32) ; impl CH10_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch10_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake."] pub struct CH11_DBG_CTDREQ (u32) ; impl CH11_DBG_CTDREQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_dbg_ctdreq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_ch11_dbg_ctdreq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer"] pub struct CH11_DBG_TCR (u32) ; impl CH11_DBG_TCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ch11_dbg_tcr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod xosc { # [doc = "Controls the crystal oscillator"] pub struct XOSC ; impl XOSC { pub const BASE_ADDR : u64 = 1073889280u64 ; } # [doc = "Crystal Oscillator Control"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Frequency range. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_FREQ_RANGE. This resets to 0xAA0 and cannot be changed."] pub fn freq_range (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Frequency range. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_FREQ_RANGE. This resets to 0xAA0 and cannot be changed."] pub fn set_freq_range (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "On power-up this field is initialised to DISABLE and the chip runs from the ROSC. \n                            If the chip has subsequently been programmed to run from the XOSC then DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature. \n                            The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator."] pub fn enable (& self) -> u32 { (self . 0 >> 12u32) & 4095u32 } # [doc = "On power-up this field is initialised to DISABLE and the chip runs from the ROSC. \n                            If the chip has subsequently been programmed to run from the XOSC then DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature. \n                            The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Crystal Oscillator Status"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The current frequency range setting, always reads 0"] pub fn freq_range (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Oscillator is enabled but not necessarily running and stable, resets to 0"] pub fn enabled (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT"] pub fn badwrite (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT"] pub fn set_badwrite (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Oscillator is running and stable"] pub fn stable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Crystal Oscillator pause control"] pub struct DORMANT (u32) ; impl DORMANT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This is used to save power by pausing the XOSC \n                            On power-up this field is initialised to WAKE \n                            An invalid write will also select WAKE \n                            Warning: stop the PLLs before selecting dormant mode \n                            Warning: setup the irq before selecting dormant mode"] pub fn dormant (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This is used to save power by pausing the XOSC \n                            On power-up this field is initialised to WAKE \n                            An invalid write will also select WAKE \n                            Warning: stop the PLLs before selecting dormant mode \n                            Warning: setup the irq before selecting dormant mode"] pub fn set_dormant (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the startup delay"] pub struct STARTUP (u32) ; impl STARTUP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles."] pub fn delay (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles."] pub fn set_delay (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly."] pub fn x4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly."] pub fn set_x4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "A down counter running at the xosc frequency which counts to zero and stops. \n                    To start the counter write a non-zero value. \n                    Can be used for short software pauses when setting up time sensitive hardware."] pub struct COUNT (u32) ; impl COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn count (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_count (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rtc { # [doc = "Register block to control RTC"] pub struct RTC ; impl RTC { pub const BASE_ADDR : u64 = 1074118656u64 ; } # [doc = "Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled."] pub struct CLKDIV_M1 (u32) ; impl CLKDIV_M1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clkdiv_m1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_clkdiv_m1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RTC setup register 0"] pub struct SETUP_0 (u32) ; impl SETUP_0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Day of the month (1..31)"] pub fn day (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Day of the month (1..31)"] pub fn set_day (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Month (1..12)"] pub fn month (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Month (1..12)"] pub fn set_month (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Year"] pub fn year (& self) -> u32 { (self . 0 >> 12u32) & 4095u32 } # [doc = "Year"] pub fn set_year (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RTC setup register 1"] pub struct SETUP_1 (u32) ; impl SETUP_1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Seconds"] pub fn sec (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Seconds"] pub fn set_sec (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Minutes"] pub fn min (& self) -> u32 { (self . 0 >> 8u32) & 63u32 } # [doc = "Minutes"] pub fn set_min (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Hours"] pub fn hour (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "Hours"] pub fn set_hour (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7"] pub fn dotw (& self) -> u32 { (self . 0 >> 24u32) & 7u32 } # [doc = "Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7"] pub fn set_dotw (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RTC Control and status"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable RTC"] pub fn rtc_enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable RTC"] pub fn set_rtc_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RTC enabled (running)"] pub fn rtc_active (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Load RTC"] pub fn load (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Load RTC"] pub fn set_load (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "If set, leapyear is forced off. \n                            Useful for years divisible by 100 but not by 400"] pub fn force_notleapyear (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "If set, leapyear is forced off. \n                            Useful for years divisible by 100 but not by 400"] pub fn set_force_notleapyear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt setup register 0"] pub struct IRQ_SETUP_0 (u32) ; impl IRQ_SETUP_0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Day of the month (1..31)"] pub fn day (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Day of the month (1..31)"] pub fn set_day (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Month (1..12)"] pub fn month (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Month (1..12)"] pub fn set_month (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Year"] pub fn year (& self) -> u32 { (self . 0 >> 12u32) & 4095u32 } # [doc = "Year"] pub fn set_year (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable day matching"] pub fn day_ena (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable day matching"] pub fn set_day_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable month matching"] pub fn month_ena (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable month matching"] pub fn set_month_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable year matching"] pub fn year_ena (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable year matching"] pub fn set_year_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Global match enable. Don't change any other value while this one is enabled"] pub fn match_ena (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Global match enable. Don't change any other value while this one is enabled"] pub fn set_match_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn match_active (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt setup register 1"] pub struct IRQ_SETUP_1 (u32) ; impl IRQ_SETUP_1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Seconds"] pub fn sec (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Seconds"] pub fn set_sec (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Minutes"] pub fn min (& self) -> u32 { (self . 0 >> 8u32) & 63u32 } # [doc = "Minutes"] pub fn set_min (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Hours"] pub fn hour (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "Hours"] pub fn set_hour (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Day of the week"] pub fn dotw (& self) -> u32 { (self . 0 >> 24u32) & 7u32 } # [doc = "Day of the week"] pub fn set_dotw (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable second matching"] pub fn sec_ena (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable second matching"] pub fn set_sec_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable minute matching"] pub fn min_ena (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable minute matching"] pub fn set_min_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable hour matching"] pub fn hour_ena (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable hour matching"] pub fn set_hour_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable day of the week matching"] pub fn dotw_ena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable day of the week matching"] pub fn set_dotw_ena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RTC register 1."] pub struct RTC_1 (u32) ; impl RTC_1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Day of the month (1..31)"] pub fn day (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Month (1..12)"] pub fn month (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Year"] pub fn year (& self) -> u32 { (self . 0 >> 12u32) & 4095u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RTC register 0 \n                    Read this before RTC 1!"] pub struct RTC_0 (u32) ; impl RTC_0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Seconds"] pub fn sec (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Minutes"] pub fn min (& self) -> u32 { (self . 0 >> 8u32) & 63u32 } # [doc = "Hours"] pub fn hour (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "Day of the week"] pub fn dotw (& self) -> u32 { (self . 0 >> 24u32) & 7u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod io_qspi { # [doc = "No description"] pub struct IO_QSPI ; impl IO_QSPI { pub const BASE_ADDR : u64 = 1073840128u64 ; } # [doc = "GPIO status"] pub struct GPIO_QSPI_SCLK_STATUS (u32) ; impl GPIO_QSPI_SCLK_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SCLK_CTRL (u32) ; impl GPIO_QSPI_SCLK_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO_QSPI_SS_STATUS (u32) ; impl GPIO_QSPI_SS_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SS_CTRL (u32) ; impl GPIO_QSPI_SS_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO_QSPI_SD0_STATUS (u32) ; impl GPIO_QSPI_SD0_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SD0_CTRL (u32) ; impl GPIO_QSPI_SD0_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO_QSPI_SD1_STATUS (u32) ; impl GPIO_QSPI_SD1_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SD1_CTRL (u32) ; impl GPIO_QSPI_SD1_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO_QSPI_SD2_STATUS (u32) ; impl GPIO_QSPI_SD2_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SD2_CTRL (u32) ; impl GPIO_QSPI_SD2_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO_QSPI_SD3_STATUS (u32) ; impl GPIO_QSPI_SD3_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO_QSPI_SD3_CTRL (u32) ; impl GPIO_QSPI_SD3_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc0"] pub struct PROC0_INTE (u32) ; impl PROC0_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc0"] pub struct PROC0_INTF (u32) ; impl PROC0_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc0"] pub struct PROC0_INTS (u32) ; impl PROC0_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc1"] pub struct PROC1_INTE (u32) ; impl PROC1_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc1"] pub struct PROC1_INTF (u32) ; impl PROC1_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc1"] pub struct PROC1_INTS (u32) ; impl PROC1_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for dormant_wake"] pub struct DORMANT_WAKE_INTE (u32) ; impl DORMANT_WAKE_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for dormant_wake"] pub struct DORMANT_WAKE_INTF (u32) ; impl DORMANT_WAKE_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sclk_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_ss_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio_qspi_sd3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for dormant_wake"] pub struct DORMANT_WAKE_INTS (u32) ; impl DORMANT_WAKE_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio_qspi_sclk_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sclk_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_ss_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd0_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd1_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd2_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio_qspi_sd3_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pio1 { # [doc = "Programmable IO block"] pub struct PIO1 ; impl PIO1 { pub const BASE_ADDR : u64 = 1345323008u64 ; } # [doc = "PIO control register"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously."] pub fn sm_enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously."] pub fn set_sm_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.\n\n                            Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY.\n\n                            The program counter, the contents of the output shift register and the X/Y scratch registers are not affected."] pub fn sm_restart (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.\n\n                            Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY.\n\n                            The program counter, the contents of the output shift register and the X/Y scratch registers are not affected."] pub fn set_sm_restart (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.\n\n                            Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n                            Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly."] pub fn clkdiv_restart (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.\n\n                            Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n                            Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly."] pub fn set_clkdiv_restart (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO status register"] pub struct FSTAT (u32) ; impl FSTAT { pub const RESET_VALUE : u32 = 251662080u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "State machine RX FIFO is full"] pub fn rxfull (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "State machine RX FIFO is empty"] pub fn rxempty (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "State machine TX FIFO is full"] pub fn txfull (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "State machine TX FIFO is empty"] pub fn txempty (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO debug register"] pub struct FDEBUG (u32) ; impl FDEBUG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear."] pub fn rxstall (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear."] pub fn set_rxstall (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error."] pub fn rxunder (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error."] pub fn set_rxunder (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor."] pub fn txover (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor."] pub fn set_txover (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear."] pub fn txstall (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear."] pub fn set_txstall (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO levels"] pub struct FLEVEL (u32) ; impl FLEVEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn tx0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn rx0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "No description"] pub fn tx1 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "No description"] pub fn rx1 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "No description"] pub fn tx2 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "No description"] pub fn rx2 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "No description"] pub fn tx3 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "No description"] pub fn rx3 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF0 (u32) ; impl TXF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF1 (u32) ; impl TXF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF2 (u32) ; impl TXF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF3 (u32) ; impl TXF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF0 (u32) ; impl RXF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF1 (u32) ; impl RXF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF2 (u32) ; impl RXF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF3 (u32) ; impl RXF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag.\n\n                    Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE."] pub struct IRQ (u32) ; impl IRQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn irq (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_irq (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines."] pub struct IRQ_FORCE (u32) ; impl IRQ_FORCE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn irq_force (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_irq_force (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. \n                    0 -> input is synchronized (default) \n                    1 -> synchronizer is bypassed \n                    If in doubt, leave this register as all zeroes."] pub struct INPUT_SYNC_BYPASS (u32) ; impl INPUT_SYNC_BYPASS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn input_sync_bypass (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_input_sync_bypass (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."] pub struct DBG_PADOUT (u32) ; impl DBG_PADOUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn dbg_padout (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."] pub struct DBG_PADOE (u32) ; impl DBG_PADOE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn dbg_padoe (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The PIO hardware has some free parameters that may vary between chip products. \n                    These should be provided in the chip datasheet, but are also exposed here."] pub struct DBG_CFGINFO (u32) ; impl DBG_CFGINFO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The depth of the state machine TX/RX FIFOs, measured in words. \n                            Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double \n                            this depth."] pub fn fifo_depth (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "The number of state machines this PIO instance is equipped with."] pub fn sm_count (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "The size of the instruction memory, measured in units of one instruction"] pub fn imem_size (& self) -> u32 { (self . 0 >> 16u32) & 63u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 0"] pub struct INSTR_MEM0 (u32) ; impl INSTR_MEM0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem0 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem0 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 1"] pub struct INSTR_MEM1 (u32) ; impl INSTR_MEM1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 2"] pub struct INSTR_MEM2 (u32) ; impl INSTR_MEM2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem2 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem2 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 3"] pub struct INSTR_MEM3 (u32) ; impl INSTR_MEM3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem3 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem3 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 4"] pub struct INSTR_MEM4 (u32) ; impl INSTR_MEM4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem4 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem4 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 5"] pub struct INSTR_MEM5 (u32) ; impl INSTR_MEM5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem5 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem5 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 6"] pub struct INSTR_MEM6 (u32) ; impl INSTR_MEM6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem6 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem6 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 7"] pub struct INSTR_MEM7 (u32) ; impl INSTR_MEM7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem7 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem7 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 8"] pub struct INSTR_MEM8 (u32) ; impl INSTR_MEM8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem8 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem8 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 9"] pub struct INSTR_MEM9 (u32) ; impl INSTR_MEM9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem9 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem9 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 10"] pub struct INSTR_MEM10 (u32) ; impl INSTR_MEM10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem10 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem10 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 11"] pub struct INSTR_MEM11 (u32) ; impl INSTR_MEM11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem11 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem11 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 12"] pub struct INSTR_MEM12 (u32) ; impl INSTR_MEM12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem12 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem12 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 13"] pub struct INSTR_MEM13 (u32) ; impl INSTR_MEM13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem13 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem13 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 14"] pub struct INSTR_MEM14 (u32) ; impl INSTR_MEM14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem14 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem14 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 15"] pub struct INSTR_MEM15 (u32) ; impl INSTR_MEM15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem15 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem15 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 16"] pub struct INSTR_MEM16 (u32) ; impl INSTR_MEM16 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem16 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem16 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 17"] pub struct INSTR_MEM17 (u32) ; impl INSTR_MEM17 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem17 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem17 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 18"] pub struct INSTR_MEM18 (u32) ; impl INSTR_MEM18 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem18 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem18 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 19"] pub struct INSTR_MEM19 (u32) ; impl INSTR_MEM19 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem19 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem19 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 20"] pub struct INSTR_MEM20 (u32) ; impl INSTR_MEM20 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem20 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem20 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 21"] pub struct INSTR_MEM21 (u32) ; impl INSTR_MEM21 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem21 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem21 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 22"] pub struct INSTR_MEM22 (u32) ; impl INSTR_MEM22 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem22 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem22 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 23"] pub struct INSTR_MEM23 (u32) ; impl INSTR_MEM23 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem23 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem23 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 24"] pub struct INSTR_MEM24 (u32) ; impl INSTR_MEM24 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem24 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem24 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 25"] pub struct INSTR_MEM25 (u32) ; impl INSTR_MEM25 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem25 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem25 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 26"] pub struct INSTR_MEM26 (u32) ; impl INSTR_MEM26 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem26 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem26 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 27"] pub struct INSTR_MEM27 (u32) ; impl INSTR_MEM27 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem27 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem27 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 28"] pub struct INSTR_MEM28 (u32) ; impl INSTR_MEM28 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem28 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem28 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 29"] pub struct INSTR_MEM29 (u32) ; impl INSTR_MEM29 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem29 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem29 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 30"] pub struct INSTR_MEM30 (u32) ; impl INSTR_MEM30 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem30 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem30 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 31"] pub struct INSTR_MEM31 (u32) ; impl INSTR_MEM31 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem31 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem31 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 0 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM0_CLKDIV (u32) ; impl SM0_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 0"] pub struct SM0_EXECCTRL (u32) ; impl SM0_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 0"] pub struct SM0_SHIFTCTRL (u32) ; impl SM0_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 0"] pub struct SM0_ADDR (u32) ; impl SM0_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 0's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM0_INSTR (u32) ; impl SM0_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm0_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM0_PINCTRL (u32) ; impl SM0_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 1 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM1_CLKDIV (u32) ; impl SM1_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 1"] pub struct SM1_EXECCTRL (u32) ; impl SM1_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 1"] pub struct SM1_SHIFTCTRL (u32) ; impl SM1_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 1"] pub struct SM1_ADDR (u32) ; impl SM1_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm1_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 1's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM1_INSTR (u32) ; impl SM1_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm1_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm1_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM1_PINCTRL (u32) ; impl SM1_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 2 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM2_CLKDIV (u32) ; impl SM2_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 2"] pub struct SM2_EXECCTRL (u32) ; impl SM2_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 2"] pub struct SM2_SHIFTCTRL (u32) ; impl SM2_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 2"] pub struct SM2_ADDR (u32) ; impl SM2_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm2_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 2's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM2_INSTR (u32) ; impl SM2_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm2_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm2_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM2_PINCTRL (u32) ; impl SM2_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 3 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM3_CLKDIV (u32) ; impl SM3_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 3"] pub struct SM3_EXECCTRL (u32) ; impl SM3_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 3"] pub struct SM3_SHIFTCTRL (u32) ; impl SM3_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 3"] pub struct SM3_ADDR (u32) ; impl SM3_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm3_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 3's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM3_INSTR (u32) ; impl SM3_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm3_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm3_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM3_PINCTRL (u32) ; impl SM3_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for irq0"] pub struct IRQ0_INTE (u32) ; impl IRQ0_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for irq0"] pub struct IRQ0_INTF (u32) ; impl IRQ0_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for irq0"] pub struct IRQ0_INTS (u32) ; impl IRQ0_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for irq1"] pub struct IRQ1_INTE (u32) ; impl IRQ1_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for irq1"] pub struct IRQ1_INTF (u32) ; impl IRQ1_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for irq1"] pub struct IRQ1_INTS (u32) ; impl IRQ1_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod xip_ctrl { # [doc = "QSPI flash execute-in-place block"] pub struct XIP_CTRL ; impl XIP_CTRL { pub const BASE_ADDR : u64 = 335544320u64 ; } # [doc = "Cache control"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 3u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "When 1, enable the cache. When the cache is disabled, all XIP accesses \n                            will go straight to the flash, without querying the cache. When enabled, \n                            cacheable XIP accesses will query the cache, and the flash will \n                            not be accessed if the tag matches and the valid bit is set.\n\n                            If the cache is enabled, cache-as-SRAM accesses have no effect on the \n                            cache data RAM, and will produce a bus error response."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "When 1, enable the cache. When the cache is disabled, all XIP accesses \n                            will go straight to the flash, without querying the cache. When enabled, \n                            cacheable XIP accesses will query the cache, and the flash will \n                            not be accessed if the tag matches and the valid bit is set.\n\n                            If the cache is enabled, cache-as-SRAM accesses have no effect on the \n                            cache data RAM, and will produce a bus error response."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "When 1, writes to any alias other than 0x0 (caching, allocating) \n                            will produce a bus fault. When 0, these writes are silently ignored. \n                            In either case, writes to the 0x0 alias will deallocate on tag match, \n                            as usual."] pub fn err_badwrite (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "When 1, writes to any alias other than 0x0 (caching, allocating) \n                            will produce a bus fault. When 0, these writes are silently ignored. \n                            In either case, writes to the 0x0 alias will deallocate on tag match, \n                            as usual."] pub fn set_err_badwrite (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "When 1, the cache memories are powered down. They retain state, \n                            but can not be accessed. This reduces static power dissipation. \n                            Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot \n                            be enabled when powered down. \n                            Cache-as-SRAM accesses will produce a bus error response when \n                            the cache is powered down."] pub fn power_down (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "When 1, the cache memories are powered down. They retain state, \n                            but can not be accessed. This reduces static power dissipation. \n                            Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot \n                            be enabled when powered down. \n                            Cache-as-SRAM accesses will produce a bus error response when \n                            the cache is powered down."] pub fn set_power_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Cache Flush control"] pub struct FLUSH (u32) ; impl FLUSH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write 1 to flush the cache. This clears the tag memory, but \n                            the data memory retains its contents. (This means cache-as-SRAM \n                            contents is not affected by flush or reset.) \n                            Reading will hold the bus (stall the processor) until the flush \n                            completes. Alternatively STAT can be polled until completion."] pub fn flush (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write 1 to flush the cache. This clears the tag memory, but \n                            the data memory retains its contents. (This means cache-as-SRAM \n                            contents is not affected by flush or reset.) \n                            Reading will hold the bus (stall the processor) until the flush \n                            completes. Alternatively STAT can be polled until completion."] pub fn set_flush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Cache Status"] pub struct STAT (u32) ; impl STAT { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reads as 0 while a cache flush is in progress, and 1 otherwise. \n                            The cache is flushed whenever the XIP block is reset, and also \n                            when requested via the FLUSH register."] pub fn flush_ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "When 1, indicates the XIP streaming FIFO is completely empty."] pub fn fifo_empty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "When 1, indicates the XIP streaming FIFO is completely full. \n                            The streaming FIFO is 2 entries deep, so the full and empty \n                            flag allow its level to be ascertained."] pub fn fifo_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Cache Hit counter"] pub struct CTR_HIT (u32) ; impl CTR_HIT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A 32 bit saturating counter that increments upon each cache hit, \n                            i.e. when an XIP access is serviced directly from cached data. \n                            Write any value to clear."] pub fn ctr_hit (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "A 32 bit saturating counter that increments upon each cache hit, \n                            i.e. when an XIP access is serviced directly from cached data. \n                            Write any value to clear."] pub fn set_ctr_hit (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Cache Access counter"] pub struct CTR_ACC (u32) ; impl CTR_ACC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A 32 bit saturating counter that increments upon each XIP access, \n                            whether the cache is hit or not. This includes noncacheable accesses. \n                            Write any value to clear."] pub fn ctr_acc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "A 32 bit saturating counter that increments upon each XIP access, \n                            whether the cache is hit or not. This includes noncacheable accesses. \n                            Write any value to clear."] pub fn set_ctr_acc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO stream address"] pub struct STREAM_ADDR (u32) ; impl STREAM_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The address of the next word to be streamed from flash to the streaming FIFO. \n                            Increments automatically after each flash access. \n                            Write the initial access address here before starting a streaming read."] pub fn stream_addr (& self) -> u32 { (self . 0 >> 2u32) & 1073741823u32 } # [doc = "The address of the next word to be streamed from flash to the streaming FIFO. \n                            Increments automatically after each flash access. \n                            Write the initial access address here before starting a streaming read."] pub fn set_stream_addr (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO stream control"] pub struct STREAM_CTR (u32) ; impl STREAM_CTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write a nonzero value to start a streaming read. This will then \n                            progress in the background, using flash idle cycles to transfer \n                            a linear data block from flash to the streaming FIFO. \n                            Decrements automatically (1 at a time) as the stream \n                            progresses, and halts on reaching 0. \n                            Write 0 to halt an in-progress stream, and discard any in-flight \n                            read, so that a new stream can immediately be started (after \n                            draining the FIFO and reinitialising STREAM_ADDR)"] pub fn stream_ctr (& self) -> u32 { (self . 0 >> 0u32) & 4194303u32 } # [doc = "Write a nonzero value to start a streaming read. This will then \n                            progress in the background, using flash idle cycles to transfer \n                            a linear data block from flash to the streaming FIFO. \n                            Decrements automatically (1 at a time) as the stream \n                            progresses, and halts on reaching 0. \n                            Write 0 to halt an in-progress stream, and discard any in-flight \n                            read, so that a new stream can immediately be started (after \n                            draining the FIFO and reinitialising STREAM_ADDR)"] pub fn set_stream_ctr (& mut self , value : u32) { let value_masked = value & 4194303u32 ; self . 0 &= ! (4194303u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO stream data"] pub struct STREAM_FIFO (u32) ; impl STREAM_FIFO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Streamed data is buffered here, for retrieval by the system DMA. \n                            This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing \n                            the DMA to bus stalls caused by other XIP traffic."] pub fn stream_fifo (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod psm { # [doc = "No description"] pub struct PSM ; impl PSM { pub const BASE_ADDR : u64 = 1073807360u64 ; } # [doc = "Force block out of reset (i.e. power it on)"] pub struct FRCE_ON (u32) ; impl FRCE_ON { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rosc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_rosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn xosc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_xosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clocks (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clocks (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn resets (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_resets (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_busfabric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn rom (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sram0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sram1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sram2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sram3 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sram4 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sram5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn xip (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_xip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_vreg_and_chip_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn sio (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_sio (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn proc0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_proc0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn proc1 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_proc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Force into reset (i.e. power it off)"] pub struct FRCE_OFF (u32) ; impl FRCE_OFF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rosc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_rosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn xosc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_xosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clocks (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clocks (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn resets (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_resets (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_busfabric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn rom (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sram0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sram1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sram2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sram3 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sram4 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sram5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn xip (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_xip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_vreg_and_chip_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn sio (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_sio (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn proc0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_proc0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn proc1 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_proc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set to 1 if this peripheral should be reset when the watchdog fires."] pub struct WDSEL (u32) ; impl WDSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rosc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_rosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn xosc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_xosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clocks (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clocks (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn resets (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_resets (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_busfabric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn rom (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sram0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sram1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sram2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sram3 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sram4 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sram5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn xip (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_xip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_vreg_and_chip_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn sio (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_sio (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn proc0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_proc0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn proc1 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_proc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates the peripheral's registers are ready to access."] pub struct DONE (u32) ; impl DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rosc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn xosc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn clocks (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn resets (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn rom (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sram0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sram1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sram2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sram3 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sram4 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sram5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn xip (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn sio (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn proc0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn proc1 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod adc { # [doc = "Control and data interface to SAR ADC"] pub struct ADC ; impl ADC { pub const BASE_ADDR : u64 = 1074053120u64 ; } # [doc = "ADC Control and Status"] pub struct CS (u32) ; impl CS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Power on ADC and enable its clock. \n                            1 - enabled. 0 - disabled."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Power on ADC and enable its clock. \n                            1 - enabled. 0 - disabled."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Power on temperature sensor. 1 - enabled. 0 - disabled."] pub fn ts_en (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Power on temperature sensor. 1 - enabled. 0 - disabled."] pub fn set_ts_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Start a single conversion. Self-clearing. Ignored if start_many is asserted."] pub fn start_once (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Start a single conversion. Self-clearing. Ignored if start_many is asserted."] pub fn set_start_once (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes."] pub fn start_many (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes."] pub fn set_start_many (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed. \n                            0 whilst conversion in progress."] pub fn ready (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "The most recent ADC conversion encountered an error; result is undefined or noisy."] pub fn err (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Some past ADC conversion encountered an error. Write 1 to clear."] pub fn err_sticky (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Some past ADC conversion encountered an error. Write 1 to clear."] pub fn set_err_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Select analog mux input. Updated automatically in round-robin mode."] pub fn ainsel (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Select analog mux input. Updated automatically in round-robin mode."] pub fn set_ainsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable. \n                            Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion. \n                            The first channel to be sampled will be the one currently indicated by AINSEL. \n                            AINSEL will be updated after each conversion with the newly-selected channel."] pub fn rrobin (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable. \n                            Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion. \n                            The first channel to be sampled will be the one currently indicated by AINSEL. \n                            AINSEL will be updated after each conversion with the newly-selected channel."] pub fn set_rrobin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Result of most recent ADC conversion"] pub struct RESULT (u32) ; impl RESULT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn result (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO control and status"] pub struct FCS (u32) ; impl FCS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "If 1: write result to the FIFO after each conversion."] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "If 1: write result to the FIFO after each conversion."] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers."] pub fn shift (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers."] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "If 1: conversion error bit appears in the FIFO alongside the result"] pub fn err (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "If 1: conversion error bit appears in the FIFO alongside the result"] pub fn set_err (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "If 1: assert DMA requests when FIFO contains data"] pub fn dreq_en (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "If 1: assert DMA requests when FIFO contains data"] pub fn set_dreq_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn empty (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn full (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "1 if the FIFO has been underflowed. Write 1 to clear."] pub fn under (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "1 if the FIFO has been underflowed. Write 1 to clear."] pub fn set_under (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "1 if the FIFO has been overflowed. Write 1 to clear."] pub fn over (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "1 if the FIFO has been overflowed. Write 1 to clear."] pub fn set_over (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "The number of conversion results currently waiting in the FIFO"] pub fn level (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "DREQ/IRQ asserted when level >= threshold"] pub fn thresh (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "DREQ/IRQ asserted when level >= threshold"] pub fn set_thresh (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Conversion result FIFO"] pub struct FIFO (u32) ; impl FIFO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn val (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted."] pub fn err (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divider. If non-zero, CS_START_MANY will start conversions \n                    at regular intervals rather than back-to-back. \n                    The divider is reset when either of these fields are written. \n                    Total period is 1 + INT + FRAC / 256"] pub struct DIV (u32) ; impl DIV { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor. First-order delta-sigma."] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional part of clock divisor. First-order delta-sigma."] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer part of clock divisor."] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 65535u32 } # [doc = "Integer part of clock divisor."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn fifo (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn fifo (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn set_fifo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn fifo (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn set_fifo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Triggered when the sample FIFO reaches a certain level. \n                            This level can be programmed via the FCS_THRESH field."] pub fn fifo (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod sio { # [doc = "Single-cycle IO block \n            Provides core-local and inter-core hardware for the two processors, with single-cycle access."] pub struct SIO ; impl SIO { pub const BASE_ADDR : u64 = 3489660928u64 ; } # [doc = "Processor core identifier"] pub struct CPUID (u32) ; impl CPUID { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value is 0 when read from processor core 0, and 1 when read from processor core 1."] pub fn cpuid (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Input value for GPIO pins"] pub struct GPIO_IN (u32) ; impl GPIO_IN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Input value for GPIO0...29"] pub fn gpio_in (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Input value for QSPI pins"] pub struct GPIO_HI_IN (u32) ; impl GPIO_HI_IN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2, SD3"] pub fn gpio_hi_in (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output value"] pub struct GPIO_OUT (u32) ; impl GPIO_OUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set output level (1/0 -> high/low) for GPIO0...29. \n                            Reading back gives the last value written, NOT the input value from the pins. \n                            If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn gpio_out (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Set output level (1/0 -> high/low) for GPIO0...29. \n                            Reading back gives the last value written, NOT the input value from the pins. \n                            If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn set_gpio_out (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output value set"] pub struct GPIO_OUT_SET (u32) ; impl GPIO_OUT_SET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`"] pub fn gpio_out_set (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`"] pub fn set_gpio_out_set (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output value clear"] pub struct GPIO_OUT_CLR (u32) ; impl GPIO_OUT_CLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`"] pub fn gpio_out_clr (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`"] pub fn set_gpio_out_clr (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output value XOR"] pub struct GPIO_OUT_XOR (u32) ; impl GPIO_OUT_XOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`"] pub fn gpio_out_xor (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata`"] pub fn set_gpio_out_xor (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output enable"] pub struct GPIO_OE (u32) ; impl GPIO_OE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set output enable (1/0 -> output/input) for GPIO0...29. \n                            Reading back gives the last value written. \n                            If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn gpio_oe (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Set output enable (1/0 -> output/input) for GPIO0...29. \n                            Reading back gives the last value written. \n                            If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn set_gpio_oe (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output enable set"] pub struct GPIO_OE_SET (u32) ; impl GPIO_OE_SET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`"] pub fn gpio_oe_set (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`"] pub fn set_gpio_oe_set (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output enable clear"] pub struct GPIO_OE_CLR (u32) ; impl GPIO_OE_CLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`"] pub fn gpio_oe_clr (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`"] pub fn set_gpio_oe_clr (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO output enable XOR"] pub struct GPIO_OE_XOR (u32) ; impl GPIO_OE_XOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`"] pub fn gpio_oe_xor (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`"] pub fn set_gpio_oe_xor (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output value"] pub struct GPIO_HI_OUT (u32) ; impl GPIO_HI_OUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set output level (1/0 -> high/low) for QSPI IO0...5. \n                            Reading back gives the last value written, NOT the input value from the pins. \n                            If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn gpio_hi_out (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Set output level (1/0 -> high/low) for QSPI IO0...5. \n                            Reading back gives the last value written, NOT the input value from the pins. \n                            If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn set_gpio_hi_out (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output value set"] pub struct GPIO_HI_OUT_SET (u32) ; impl GPIO_HI_OUT_SET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`"] pub fn gpio_hi_out_set (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`"] pub fn set_gpio_hi_out_set (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output value clear"] pub struct GPIO_HI_OUT_CLR (u32) ; impl GPIO_HI_OUT_CLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`"] pub fn gpio_hi_out_clr (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`"] pub fn set_gpio_hi_out_clr (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output value XOR"] pub struct GPIO_HI_OUT_XOR (u32) ; impl GPIO_HI_OUT_XOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`"] pub fn gpio_hi_out_xor (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`"] pub fn set_gpio_hi_out_xor (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output enable"] pub struct GPIO_HI_OE (u32) ; impl GPIO_HI_OE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set output enable (1/0 -> output/input) for QSPI IO0...5. \n                            Reading back gives the last value written. \n                            If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn gpio_hi_oe (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Set output enable (1/0 -> output/input) for QSPI IO0...5. \n                            Reading back gives the last value written. \n                            If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), \n                            the result is as though the write from core 0 took place first, \n                            and the write from core 1 was then applied to that intermediate result."] pub fn set_gpio_hi_oe (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output enable set"] pub struct GPIO_HI_OE_SET (u32) ; impl GPIO_HI_OE_SET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`"] pub fn gpio_hi_oe_set (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`"] pub fn set_gpio_hi_oe_set (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output enable clear"] pub struct GPIO_HI_OE_CLR (u32) ; impl GPIO_HI_OE_CLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`"] pub fn gpio_hi_oe_clr (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`"] pub fn set_gpio_hi_oe_clr (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QSPI output enable XOR"] pub struct GPIO_HI_OE_XOR (u32) ; impl GPIO_HI_OE_XOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`"] pub fn gpio_hi_oe_xor (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`"] pub fn set_gpio_hi_oe_xor (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register for inter-core FIFOs (mailboxes). \n                    There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. \n                    Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). \n                    Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). \n                    The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register."] pub struct FIFO_ST (u32) ; impl FIFO_ST { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)"] pub fn vld (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)"] pub fn rdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO."] pub fn wof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO."] pub fn set_wof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO."] pub fn roe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO."] pub fn set_roe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write access to this core's TX FIFO"] pub struct FIFO_WR (u32) ; impl FIFO_WR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fifo_wr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_fifo_wr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read access to this core's RX FIFO"] pub struct FIFO_RD (u32) ; impl FIFO_RD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fifo_rd (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Spinlock state \n                    A bitmap containing the state of all 32 spinlocks (1=locked). \n                    Mainly intended for debugging."] pub struct SPINLOCK_ST (u32) ; impl SPINLOCK_ST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock_st (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider unsigned dividend \n                    Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`. \n                    Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n                    UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an \n                    unsigned calculation, and the S alias starts a signed calculation."] pub struct DIV_UDIVIDEND (u32) ; impl DIV_UDIVIDEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_udividend (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_udividend (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider unsigned divisor \n                    Write to the DIVISOR operand of the divider, i.e. the q in `p / q`. \n                    Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. \n                    UDIVISOR/SDIVISOR are aliases of the same internal register. The U alias starts an \n                    unsigned calculation, and the S alias starts a signed calculation."] pub struct DIV_UDIVISOR (u32) ; impl DIV_UDIVISOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_udivisor (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_udivisor (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider signed dividend \n                    The same as UDIVIDEND, but starts a signed calculation, rather than unsigned."] pub struct DIV_SDIVIDEND (u32) ; impl DIV_SDIVIDEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_sdividend (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_sdividend (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider signed divisor \n                    The same as UDIVISOR, but starts a signed calculation, rather than unsigned."] pub struct DIV_SDIVISOR (u32) ; impl DIV_SDIVISOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_sdivisor (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_sdivisor (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider result quotient \n                    The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low. \n                    For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ. \n                    This register can be written to directly, for context save/restore purposes. This halts any \n                    in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. \n                    Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order \n                    REMAINDER, QUOTIENT if CSR_DIRTY is used."] pub struct DIV_QUOTIENT (u32) ; impl DIV_QUOTIENT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_quotient (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_quotient (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Divider result remainder \n                    The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low. \n                    For signed calculations, REMAINDER is negative only when DIVIDEND is negative. \n                    This register can be written to directly, for context save/restore purposes. This halts any \n                    in-progress calculation and sets the CSR_READY and CSR_DIRTY flags."] pub struct DIV_REMAINDER (u32) ; impl DIV_REMAINDER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn div_remainder (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_div_remainder (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control and status register for divider."] pub struct DIV_CSR (u32) ; impl DIV_CSR { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reads as 0 when a calculation is in progress, 1 otherwise. \n                            Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new calculation, no \n                            matter if one is already in progress. \n                            Writing to a result register will immediately terminate any in-progress calculation \n                            and set the READY and DIRTY flags."] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Changes to 1 when any register is written, and back to 0 when QUOTIENT is read. \n                            Software can use this flag to make save/restore more efficient (skip if not DIRTY). \n                            If the flag is used in this way, it's recommended to either read QUOTIENT only, \n                            or REMAINDER and then QUOTIENT, to prevent data loss on context switch."] pub fn dirty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to accumulator 0"] pub struct INTERP0_ACCUM0 (u32) ; impl INTERP0_ACCUM0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_accum0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_accum0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to accumulator 1"] pub struct INTERP0_ACCUM1 (u32) ; impl INTERP0_ACCUM1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_accum1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_accum1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE0 register."] pub struct INTERP0_BASE0 (u32) ; impl INTERP0_BASE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_base0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_base0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE1 register."] pub struct INTERP0_BASE1 (u32) ; impl INTERP0_BASE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_base1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_base1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE2 register."] pub struct INTERP0_BASE2 (u32) ; impl INTERP0_BASE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_base2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_base2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE0 result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP0_POP_LANE0 (u32) ; impl INTERP0_POP_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_pop_lane0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE1 result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP0_POP_LANE1 (u32) ; impl INTERP0_POP_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_pop_lane1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read FULL result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP0_POP_FULL (u32) ; impl INTERP0_POP_FULL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_pop_full (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE0 result, without altering any internal state (PEEK)."] pub struct INTERP0_PEEK_LANE0 (u32) ; impl INTERP0_PEEK_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_peek_lane0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE1 result, without altering any internal state (PEEK)."] pub struct INTERP0_PEEK_LANE1 (u32) ; impl INTERP0_PEEK_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_peek_lane1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read FULL result, without altering any internal state (PEEK)."] pub struct INTERP0_PEEK_FULL (u32) ; impl INTERP0_PEEK_FULL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_peek_full (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register for lane 0"] pub struct INTERP0_CTRL_LANE0 (u32) ; impl INTERP0_CTRL_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn shift (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn mask_lsb (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn set_mask_lsb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn mask_msb (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn set_mask_msb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."] pub fn signed (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."] pub fn set_signed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn cross_input (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn set_cross_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn cross_result (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn set_cross_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result."] pub fn add_raw (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result."] pub fn set_add_raw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn force_msb (& self) -> u32 { (self . 0 >> 19u32) & 3u32 } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn set_force_msb (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Only present on INTERP0 on each core. If BLEND mode is enabled: \n                            - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled \n                            by the 8 LSBs of lane 1 shift and mask value (a fractional number between \n                            0 and 255/256ths) \n                            - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value) \n                            - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) \n                            LANE1 SIGNED flag controls whether the interpolation is signed or unsigned."] pub fn blend (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Only present on INTERP0 on each core. If BLEND mode is enabled: \n                            - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled \n                            by the 8 LSBs of lane 1 shift and mask value (a fractional number between \n                            0 and 255/256ths) \n                            - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value) \n                            - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) \n                            LANE1 SIGNED flag controls whether the interpolation is signed or unsigned."] pub fn set_blend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Indicates if any masked-off MSBs in ACCUM0 are set."] pub fn overf0 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Indicates if any masked-off MSBs in ACCUM1 are set."] pub fn overf1 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Set if either OVERF0 or OVERF1 is set."] pub fn overf (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register for lane 1"] pub struct INTERP0_CTRL_LANE1 (u32) ; impl INTERP0_CTRL_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn shift (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn mask_lsb (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn set_mask_lsb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn mask_msb (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn set_mask_msb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."] pub fn signed (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."] pub fn set_signed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn cross_input (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn set_cross_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn cross_result (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn set_cross_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result."] pub fn add_raw (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result."] pub fn set_add_raw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn force_msb (& self) -> u32 { (self . 0 >> 19u32) & 3u32 } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn set_force_msb (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Values written here are atomically added to ACCUM0 \n                    Reading yields lane 0's raw shift and mask value (BASE0 not added)."] pub struct INTERP0_ACCUM0_ADD (u32) ; impl INTERP0_ACCUM0_ADD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_accum0_add (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "No description"] pub fn set_interp0_accum0_add (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Values written here are atomically added to ACCUM1 \n                    Reading yields lane 1's raw shift and mask value (BASE1 not added)."] pub struct INTERP0_ACCUM1_ADD (u32) ; impl INTERP0_ACCUM1_ADD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_accum1_add (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "No description"] pub fn set_interp0_accum1_add (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. \n                    Each half is sign-extended to 32 bits if that lane's SIGNED flag is set."] pub struct INTERP0_BASE_1AND0 (u32) ; impl INTERP0_BASE_1AND0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp0_base_1and0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp0_base_1and0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to accumulator 0"] pub struct INTERP1_ACCUM0 (u32) ; impl INTERP1_ACCUM0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_accum0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_accum0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to accumulator 1"] pub struct INTERP1_ACCUM1 (u32) ; impl INTERP1_ACCUM1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_accum1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_accum1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE0 register."] pub struct INTERP1_BASE0 (u32) ; impl INTERP1_BASE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_base0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_base0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE1 register."] pub struct INTERP1_BASE1 (u32) ; impl INTERP1_BASE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_base1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_base1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read/write access to BASE2 register."] pub struct INTERP1_BASE2 (u32) ; impl INTERP1_BASE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_base2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_base2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE0 result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP1_POP_LANE0 (u32) ; impl INTERP1_POP_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_pop_lane0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE1 result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP1_POP_LANE1 (u32) ; impl INTERP1_POP_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_pop_lane1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read FULL result, and simultaneously write lane results to both accumulators (POP)."] pub struct INTERP1_POP_FULL (u32) ; impl INTERP1_POP_FULL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_pop_full (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE0 result, without altering any internal state (PEEK)."] pub struct INTERP1_PEEK_LANE0 (u32) ; impl INTERP1_PEEK_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_peek_lane0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read LANE1 result, without altering any internal state (PEEK)."] pub struct INTERP1_PEEK_LANE1 (u32) ; impl INTERP1_PEEK_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_peek_lane1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read FULL result, without altering any internal state (PEEK)."] pub struct INTERP1_PEEK_FULL (u32) ; impl INTERP1_PEEK_FULL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_peek_full (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register for lane 0"] pub struct INTERP1_CTRL_LANE0 (u32) ; impl INTERP1_CTRL_LANE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn shift (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn mask_lsb (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn set_mask_lsb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn mask_msb (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn set_mask_msb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."] pub fn signed (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor."] pub fn set_signed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn cross_input (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn set_cross_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn cross_result (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn set_cross_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result."] pub fn add_raw (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result."] pub fn set_add_raw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn force_msb (& self) -> u32 { (self . 0 >> 19u32) & 3u32 } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn set_force_msb (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Only present on INTERP1 on each core. If CLAMP mode is enabled: \n                            - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of \n                            BASE0 and an upper bound of BASE1. \n                            - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED"] pub fn clamp (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Only present on INTERP1 on each core. If CLAMP mode is enabled: \n                            - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of \n                            BASE0 and an upper bound of BASE1. \n                            - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED"] pub fn set_clamp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Indicates if any masked-off MSBs in ACCUM0 are set."] pub fn overf0 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Indicates if any masked-off MSBs in ACCUM1 are set."] pub fn overf1 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Set if either OVERF0 or OVERF1 is set."] pub fn overf (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register for lane 1"] pub struct INTERP1_CTRL_LANE1 (u32) ; impl INTERP1_CTRL_LANE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn shift (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Logical right-shift applied to accumulator before masking"] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn mask_lsb (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The least-significant bit allowed to pass by the mask (inclusive)"] pub fn set_mask_lsb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn mask_msb (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The most-significant bit allowed to pass by the mask (inclusive) \n                            Setting MSB < LSB may cause chip to turn inside-out"] pub fn set_mask_msb (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."] pub fn signed (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits \n                            before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor."] pub fn set_signed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn cross_input (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. \n                            Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)"] pub fn set_cross_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn cross_result (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "If 1, feed the opposite lane's result into this lane's accumulator on POP."] pub fn set_cross_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result."] pub fn add_raw (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result."] pub fn set_add_raw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn force_msb (& self) -> u32 { (self . 0 >> 19u32) & 3u32 } # [doc = "ORed into bits 29:28 of the lane result presented to the processor on the bus. \n                            No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence \n                            of pointers into flash or SRAM."] pub fn set_force_msb (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Values written here are atomically added to ACCUM0 \n                    Reading yields lane 0's raw shift and mask value (BASE0 not added)."] pub struct INTERP1_ACCUM0_ADD (u32) ; impl INTERP1_ACCUM0_ADD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_accum0_add (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "No description"] pub fn set_interp1_accum0_add (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Values written here are atomically added to ACCUM1 \n                    Reading yields lane 1's raw shift and mask value (BASE1 not added)."] pub struct INTERP1_ACCUM1_ADD (u32) ; impl INTERP1_ACCUM1_ADD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_accum1_add (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "No description"] pub fn set_interp1_accum1_add (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. \n                    Each half is sign-extended to 32 bits if that lane's SIGNED flag is set."] pub struct INTERP1_BASE_1AND0 (u32) ; impl INTERP1_BASE_1AND0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn interp1_base_1and0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_interp1_base_1and0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK0 (u32) ; impl SPINLOCK0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK1 (u32) ; impl SPINLOCK1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK2 (u32) ; impl SPINLOCK2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK3 (u32) ; impl SPINLOCK3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK4 (u32) ; impl SPINLOCK4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock4 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock4 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK5 (u32) ; impl SPINLOCK5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock5 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock5 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK6 (u32) ; impl SPINLOCK6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock6 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock6 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK7 (u32) ; impl SPINLOCK7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock7 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock7 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK8 (u32) ; impl SPINLOCK8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock8 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock8 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK9 (u32) ; impl SPINLOCK9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock9 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock9 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK10 (u32) ; impl SPINLOCK10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock10 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock10 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK11 (u32) ; impl SPINLOCK11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock11 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock11 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK12 (u32) ; impl SPINLOCK12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock12 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock12 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK13 (u32) ; impl SPINLOCK13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock13 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock13 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK14 (u32) ; impl SPINLOCK14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock14 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock14 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK15 (u32) ; impl SPINLOCK15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock15 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock15 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK16 (u32) ; impl SPINLOCK16 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock16 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock16 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK17 (u32) ; impl SPINLOCK17 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock17 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock17 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK18 (u32) ; impl SPINLOCK18 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock18 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock18 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK19 (u32) ; impl SPINLOCK19 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock19 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock19 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK20 (u32) ; impl SPINLOCK20 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock20 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock20 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK21 (u32) ; impl SPINLOCK21 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock21 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock21 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK22 (u32) ; impl SPINLOCK22 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock22 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock22 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK23 (u32) ; impl SPINLOCK23 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock23 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock23 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK24 (u32) ; impl SPINLOCK24 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock24 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock24 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK25 (u32) ; impl SPINLOCK25 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock25 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock25 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK26 (u32) ; impl SPINLOCK26 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock26 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock26 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK27 (u32) ; impl SPINLOCK27 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock27 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock27 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK28 (u32) ; impl SPINLOCK28 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock28 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock28 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK29 (u32) ; impl SPINLOCK29 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock29 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock29 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK30 (u32) ; impl SPINLOCK30 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock30 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock30 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reading from a spinlock address will: \n                    - Return 0 if lock is already locked \n                    - Otherwise return nonzero, and simultaneously claim the lock\n\n                    Writing (any value) releases the lock. \n                    If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. \n                    The value returned on success is 0x1 << lock number."] pub struct SPINLOCK31 (u32) ; impl SPINLOCK31 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn spinlock31 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_spinlock31 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer { # [doc = "Controls time and alarms \n            time is a 64 bit value indicating the time in usec since power-on \n            timeh is the top 32 bits of time & timel is the bottom 32 bits \n            to change time write to timelw before timehw \n            to read time read from timelr before timehr \n            An alarm is set by setting alarm_enable and writing to the corresponding alarm register \n            When an alarm is pending, the corresponding alarm_running signal will be high \n            An alarm can be cancelled before it has finished by clearing the alarm_enable \n            When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared \n            To clear the interrupt write a 1 to the corresponding alarm_irq"] pub struct TIMER ; impl TIMER { pub const BASE_ADDR : u64 = 1074085888u64 ; } # [doc = "Write to bits 63:32 of time \n                    always write timelw before timehw"] pub struct TIMEHW (u32) ; impl TIMEHW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timehw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_timehw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write to bits 31:0 of time \n                    writes do not get copied to time until timehw is written"] pub struct TIMELW (u32) ; impl TIMELW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timelw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_timelw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read from bits 63:32 of time \n                    always read timelr before timehr"] pub struct TIMEHR (u32) ; impl TIMEHR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timehr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read from bits 31:0 of time"] pub struct TIMELR (u32) ; impl TIMELR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timelr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Arm alarm 0, and configure the time it will fire. \n                    Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. \n                    The alarm will disarm itself once it fires, and can \n                    be disarmed early using the ARMED status register."] pub struct ALARM0 (u32) ; impl ALARM0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_alarm0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Arm alarm 1, and configure the time it will fire. \n                    Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. \n                    The alarm will disarm itself once it fires, and can \n                    be disarmed early using the ARMED status register."] pub struct ALARM1 (u32) ; impl ALARM1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_alarm1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Arm alarm 2, and configure the time it will fire. \n                    Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. \n                    The alarm will disarm itself once it fires, and can \n                    be disarmed early using the ARMED status register."] pub struct ALARM2 (u32) ; impl ALARM2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_alarm2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Arm alarm 3, and configure the time it will fire. \n                    Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. \n                    The alarm will disarm itself once it fires, and can \n                    be disarmed early using the ARMED status register."] pub struct ALARM3 (u32) ; impl ALARM3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_alarm3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates the armed/disarmed status of each alarm. \n                    A write to the corresponding ALARMx register arms the alarm. \n                    Alarms automatically disarm upon firing, but writing ones here \n                    will disarm immediately without waiting to fire."] pub struct ARMED (u32) ; impl ARMED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn armed (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_armed (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw read from bits 63:32 of time (no side effects)"] pub struct TIMERAWH (u32) ; impl TIMERAWH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timerawh (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw read from bits 31:0 of time (no side effects)"] pub struct TIMERAWL (u32) ; impl TIMERAWL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn timerawl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set bits high to enable pause when the corresponding debug ports are active"] pub struct DBGPAUSE (u32) ; impl DBGPAUSE { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pause when processor 0 is in debug mode"] pub fn dbg0 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pause when processor 0 is in debug mode"] pub fn set_dbg0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pause when processor 1 is in debug mode"] pub fn dbg1 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pause when processor 1 is in debug mode"] pub fn set_dbg1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set high to pause the timer"] pub struct PAUSE (u32) ; impl PAUSE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn pause (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_pause (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm_0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn alarm_1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn alarm_2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn alarm_3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm_0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn alarm_1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn alarm_2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn alarm_3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm_0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn alarm_1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn alarm_2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn alarm_3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_alarm_3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn alarm_0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn alarm_1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn alarm_2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn alarm_3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ssi { # [doc = "DW_apb_ssi has the following features: \n            * APB interface  Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation. \n            * APB3 and APB4 protocol support. \n            * Scalable APB data bus width  Supports APB data bus widths of 8, 16, and 32 bits. \n            * Serial-master or serial-slave operation  Enables serial communication with serial-master or serial-slave peripheral devices. \n            * Programmable Dual/Quad/Octal SPI support in Master Mode. \n            * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation. \n            * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes. \n            * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes. \n            * DMA Controller Interface  Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests. \n            * Independent masking of interrupts  Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently. \n            * Multi-master contention detection  Informs the processor of multiple serial-master accesses on the serial bus. \n            * Bypass of meta-stability flip-flops for synchronous clocks  When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains. \n            * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates. \n            * Programmable features: \n            - Serial interface operation  Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire. \n            - Clock bit-rate  Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation. \n            - Data Item size (4 to 32 bits)  Item size of each data transfer under the control of the programmer. \n            * Configured features: \n            - FIFO depth  16 words deep. The FIFO width is fixed at 32 bits. \n            - 1 slave select output. \n            - Hardware slave-select  Dedicated hardware slave-select line. \n            - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller. \n            - Interrupt polarity  active high interrupt lines. \n            - Serial clock polarity  low serial-clock polarity directly after reset. \n            - Serial clock phase  capture on first edge of serial-clock directly after reset."] pub struct SSI ; impl SSI { pub const BASE_ADDR : u64 = 402653184u64 ; } # [doc = "Control register 0"] pub struct CTRLR0 (u32) ; impl CTRLR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data frame size"] pub fn dfs (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Data frame size"] pub fn set_dfs (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Serial clock phase"] pub fn scph (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Serial clock phase"] pub fn set_scph (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Serial clock polarity"] pub fn scpol (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Serial clock polarity"] pub fn set_scpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Transfer mode"] pub fn tmod (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Transfer mode"] pub fn set_tmod (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Slave output enable"] pub fn slv_oe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Slave output enable"] pub fn set_slv_oe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shift register loop (test mode)"] pub fn srl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shift register loop (test mode)"] pub fn set_srl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Control frame size \n                            Value of n -> n+1 clocks per frame."] pub fn cfs (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Control frame size \n                            Value of n -> n+1 clocks per frame."] pub fn set_cfs (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Data frame size in 32b transfer mode \n                            Value of n -> n+1 clocks per frame."] pub fn dfs_32 (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "Data frame size in 32b transfer mode \n                            Value of n -> n+1 clocks per frame."] pub fn set_dfs_32 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "SPI frame format"] pub fn spi_frf (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "SPI frame format"] pub fn set_spi_frf (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Slave select toggle enable"] pub fn sste (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Slave select toggle enable"] pub fn set_sste (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Master Control register 1"] pub struct CTRLR1 (u32) ; impl CTRLR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data frames"] pub fn ndf (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data frames"] pub fn set_ndf (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SSI Enable"] pub struct SSIENR (u32) ; impl SSIENR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SSI enable"] pub fn ssi_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "SSI enable"] pub fn set_ssi_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Microwire Control"] pub struct MWCR (u32) ; impl MWCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Microwire transfer mode"] pub fn mwmod (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Microwire transfer mode"] pub fn set_mwmod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Microwire control"] pub fn mdd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Microwire control"] pub fn set_mdd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Microwire handshaking"] pub fn mhs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Microwire handshaking"] pub fn set_mhs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slave enable"] pub struct SER (u32) ; impl SER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "For each bit: \n                            0 -> slave not selected \n                            1 -> slave selected"] pub fn ser (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "For each bit: \n                            0 -> slave not selected \n                            1 -> slave selected"] pub fn set_ser (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate"] pub struct BAUDR (u32) ; impl BAUDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SSI clock divider"] pub fn sckdv (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "SSI clock divider"] pub fn set_sckdv (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX FIFO threshold level"] pub struct TXFTLR (u32) ; impl TXFTLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO threshold"] pub fn tft (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Transmit FIFO threshold"] pub fn set_tft (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX FIFO threshold level"] pub struct RXFTLR (u32) ; impl RXFTLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO threshold"] pub fn rft (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive FIFO threshold"] pub fn set_rft (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX FIFO level"] pub struct TXFLR (u32) ; impl TXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO level"] pub fn tftfl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX FIFO level"] pub struct RXFLR (u32) ; impl RXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO level"] pub fn rxtfl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SSI busy flag"] pub fn busy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO not full"] pub fn tfnf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit FIFO empty"] pub fn tfe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO not empty"] pub fn rfne (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO full"] pub fn rff (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmission error"] pub fn txe (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Data collision error"] pub fn dcol (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt mask"] pub struct IMR (u32) ; impl IMR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO empty interrupt mask"] pub fn txeim (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO empty interrupt mask"] pub fn set_txeim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit FIFO overflow interrupt mask"] pub fn txoim (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit FIFO overflow interrupt mask"] pub fn set_txoim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receive FIFO underflow interrupt mask"] pub fn rxuim (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO underflow interrupt mask"] pub fn set_rxuim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Receive FIFO overflow interrupt mask"] pub fn rxoim (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO overflow interrupt mask"] pub fn set_rxoim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive FIFO full interrupt mask"] pub fn rxfim (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive FIFO full interrupt mask"] pub fn set_rxfim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Multi-master contention interrupt mask"] pub fn mstim (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Multi-master contention interrupt mask"] pub fn set_mstim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status"] pub struct ISR (u32) ; impl ISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO empty interrupt status"] pub fn txeis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO overflow interrupt status"] pub fn txois (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive FIFO underflow interrupt status"] pub fn rxuis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO overflow interrupt status"] pub fn rxois (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO full interrupt status"] pub fn rxfis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Multi-master contention interrupt status"] pub fn mstis (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw interrupt status"] pub struct RISR (u32) ; impl RISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO empty raw interrupt status"] pub fn txeir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO overflow raw interrupt status"] pub fn txoir (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive FIFO underflow raw interrupt status"] pub fn rxuir (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO overflow raw interrupt status"] pub fn rxoir (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO full raw interrupt status"] pub fn rxfir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Multi-master contention raw interrupt status"] pub fn mstir (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX FIFO overflow interrupt clear"] pub struct TXOICR (u32) ; impl TXOICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear-on-read transmit FIFO overflow interrupt"] pub fn txoicr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX FIFO overflow interrupt clear"] pub struct RXOICR (u32) ; impl RXOICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear-on-read receive FIFO overflow interrupt"] pub fn rxoicr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX FIFO underflow interrupt clear"] pub struct RXUICR (u32) ; impl RXUICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear-on-read receive FIFO underflow interrupt"] pub fn rxuicr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Multi-master interrupt clear"] pub struct MSTICR (u32) ; impl MSTICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear-on-read multi-master contention interrupt"] pub fn msticr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt clear"] pub struct ICR (u32) ; impl ICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear-on-read all active interrupts"] pub fn icr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control"] pub struct DMACR (u32) ; impl DMACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA enable"] pub fn rdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA enable"] pub fn set_rdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA enable"] pub fn tdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA enable"] pub fn set_tdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA TX data level"] pub struct DMATDLR (u32) ; impl DMATDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit data watermark level"] pub fn dmatdl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Transmit data watermark level"] pub fn set_dmatdl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA RX data level"] pub struct DMARDLR (u32) ; impl DMARDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive data watermark level (DMARDLR+1)"] pub fn dmardl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive data watermark level (DMARDLR+1)"] pub fn set_dmardl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Identification register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 1364414537u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral dentification code"] pub fn idcode (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Version ID"] pub struct SSI_VERSION_ID (u32) ; impl SSI_VERSION_ID { pub const RESET_VALUE : u32 = 875573546u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SNPS component version (format X.YY)"] pub fn ssi_comp_version (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data Register 0 (of 36)"] pub struct DR0 (u32) ; impl DR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "First data register of 36"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "First data register of 36"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX sample delay"] pub struct RX_SAMPLE_DLY (u32) ; impl RX_SAMPLE_DLY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD sample delay (in SCLK cycles)"] pub fn rsd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RXD sample delay (in SCLK cycles)"] pub fn set_rsd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI control"] pub struct SPI_CTRLR0 (u32) ; impl SPI_CTRLR0 { pub const RESET_VALUE : u32 = 50331648u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address and instruction transfer format"] pub fn trans_type (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Address and instruction transfer format"] pub fn set_trans_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Address length (0b-60b in 4b increments)"] pub fn addr_l (& self) -> u32 { (self . 0 >> 2u32) & 15u32 } # [doc = "Address length (0b-60b in 4b increments)"] pub fn set_addr_l (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Instruction length (0/4/8/16b)"] pub fn inst_l (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Instruction length (0/4/8/16b)"] pub fn set_inst_l (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Wait cycles between control frame transmit and data reception (in SCLK cycles)"] pub fn wait_cycles (& self) -> u32 { (self . 0 >> 11u32) & 31u32 } # [doc = "Wait cycles between control frame transmit and data reception (in SCLK cycles)"] pub fn set_wait_cycles (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI DDR transfer enable"] pub fn spi_ddr_en (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "SPI DDR transfer enable"] pub fn set_spi_ddr_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Instruction DDR transfer enable"] pub fn inst_ddr_en (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Instruction DDR transfer enable"] pub fn set_inst_ddr_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Read data strobe enable"] pub fn spi_rxds_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Read data strobe enable"] pub fn set_spi_rxds_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit)"] pub fn xip_cmd (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit)"] pub fn set_xip_cmd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX drive edge"] pub struct TXD_DRIVE_EDGE (u32) ; impl TXD_DRIVE_EDGE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD drive edge"] pub fn tde (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TXD drive edge"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pads_qspi { # [doc = "No description"] pub struct PADS_QSPI ; impl PADS_QSPI { pub const BASE_ADDR : u64 = 1073872896u64 ; } # [doc = "Voltage select. Per bank control"] pub struct VOLTAGE_SELECT (u32) ; impl VOLTAGE_SELECT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn voltage_select (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_voltage_select (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SCLK (u32) ; impl GPIO_QSPI_SCLK { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SD0 (u32) ; impl GPIO_QSPI_SD0 { pub const RESET_VALUE : u32 = 82u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SD1 (u32) ; impl GPIO_QSPI_SD1 { pub const RESET_VALUE : u32 = 82u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SD2 (u32) ; impl GPIO_QSPI_SD2 { pub const RESET_VALUE : u32 = 82u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SD3 (u32) ; impl GPIO_QSPI_SD3 { pub const RESET_VALUE : u32 = 82u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO_QSPI_SS (u32) ; impl GPIO_QSPI_SS { pub const RESET_VALUE : u32 = 90u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ppb { # [doc = "No description"] pub struct PPB ; impl PPB { pub const BASE_ADDR : u64 = 3758096384u64 ; } # [doc = "Use the SysTick Control and Status Register to enable the SysTick features."] pub struct SYST_CSR (u32) ; impl SYST_CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable SysTick counter: \n                            0 = Counter disabled. \n                            1 = Counter enabled."] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable SysTick counter: \n                            0 = Counter disabled. \n                            1 = Counter enabled."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enables SysTick exception request: \n                            0 = Counting down to zero does not assert the SysTick exception request. \n                            1 = Counting down to zero to asserts the SysTick exception request."] pub fn tickint (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enables SysTick exception request: \n                            0 = Counting down to zero does not assert the SysTick exception request. \n                            1 = Counting down to zero to asserts the SysTick exception request."] pub fn set_tickint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SysTick clock source. Always reads as one if SYST_CALIB reports NOREF. \n                            Selects the SysTick timer clock source: \n                            0 = External reference clock. \n                            1 = Processor clock."] pub fn clksource (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SysTick clock source. Always reads as one if SYST_CALIB reports NOREF. \n                            Selects the SysTick timer clock source: \n                            0 = External reference clock. \n                            1 = Processor clock."] pub fn set_clksource (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger."] pub fn countflag (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. \n                    To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99."] pub struct SYST_RVR (u32) ; impl SYST_RVR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value to load into the SysTick Current Value Register when the counter reaches 0."] pub fn reload (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Value to load into the SysTick Current Value Register when the counter reaches 0."] pub fn set_reload (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN."] pub struct SYST_CVR (u32) ; impl SYST_CVR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register."] pub fn current (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register."] pub fn set_current (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply."] pub struct SYST_CALIB (u32) ; impl SYST_CALIB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known."] pub fn tenms (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "If reads as 1, the calibration value for 10ms is inexact (due to clock frequency)."] pub fn skew (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0."] pub fn noref (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled. \n                    If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority."] pub struct NVIC_ISER (u32) ; impl NVIC_ISER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interrupt set-enable bits. \n                            Write: \n                            0 = No effect. \n                            1 = Enable interrupt. \n                            Read: \n                            0 = Interrupt disabled. \n                            1 = Interrupt enabled."] pub fn setena (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Interrupt set-enable bits. \n                            Write: \n                            0 = No effect. \n                            1 = Enable interrupt. \n                            Read: \n                            0 = Interrupt disabled. \n                            1 = Interrupt enabled."] pub fn set_setena (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled."] pub struct NVIC_ICER (u32) ; impl NVIC_ICER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interrupt clear-enable bits. \n                            Write: \n                            0 = No effect. \n                            1 = Disable interrupt. \n                            Read: \n                            0 = Interrupt disabled. \n                            1 = Interrupt enabled."] pub fn clrena (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Interrupt clear-enable bits. \n                            Write: \n                            0 = No effect. \n                            1 = Disable interrupt. \n                            Read: \n                            0 = Interrupt disabled. \n                            1 = Interrupt enabled."] pub fn set_clrena (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending."] pub struct NVIC_ISPR (u32) ; impl NVIC_ISPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interrupt set-pending bits. \n                            Write: \n                            0 = No effect. \n                            1 = Changes interrupt state to pending. \n                            Read: \n                            0 = Interrupt is not pending. \n                            1 = Interrupt is pending. \n                            Note: Writing 1 to the NVIC_ISPR bit corresponding to: \n                            An interrupt that is pending has no effect. \n                            A disabled interrupt sets the state of that interrupt to pending."] pub fn setpend (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Interrupt set-pending bits. \n                            Write: \n                            0 = No effect. \n                            1 = Changes interrupt state to pending. \n                            Read: \n                            0 = Interrupt is not pending. \n                            1 = Interrupt is pending. \n                            Note: Writing 1 to the NVIC_ISPR bit corresponding to: \n                            An interrupt that is pending has no effect. \n                            A disabled interrupt sets the state of that interrupt to pending."] pub fn set_setpend (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending."] pub struct NVIC_ICPR (u32) ; impl NVIC_ICPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interrupt clear-pending bits. \n                            Write: \n                            0 = No effect. \n                            1 = Removes pending state and interrupt. \n                            Read: \n                            0 = Interrupt is not pending. \n                            1 = Interrupt is pending."] pub fn clrpend (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Interrupt clear-pending bits. \n                            Write: \n                            0 = No effect. \n                            1 = Removes pending state and interrupt. \n                            Read: \n                            0 = Interrupt is not pending. \n                            1 = Interrupt is pending."] pub fn set_clrpend (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. \n                    Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt. \n                    These registers are only word-accessible"] pub struct NVIC_IPR0 (u32) ; impl NVIC_IPR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 0"] pub fn ip_0 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 0"] pub fn set_ip_0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 1"] pub fn ip_1 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 1"] pub fn set_ip_1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 2"] pub fn ip_2 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 2"] pub fn set_ip_2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 3"] pub fn ip_3 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 3"] pub fn set_ip_3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR1 (u32) ; impl NVIC_IPR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 4"] pub fn ip_4 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 4"] pub fn set_ip_4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 5"] pub fn ip_5 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 5"] pub fn set_ip_5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 6"] pub fn ip_6 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 6"] pub fn set_ip_6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 7"] pub fn ip_7 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 7"] pub fn set_ip_7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR2 (u32) ; impl NVIC_IPR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 8"] pub fn ip_8 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 8"] pub fn set_ip_8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 9"] pub fn ip_9 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 9"] pub fn set_ip_9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 10"] pub fn ip_10 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 10"] pub fn set_ip_10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 11"] pub fn ip_11 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 11"] pub fn set_ip_11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR3 (u32) ; impl NVIC_IPR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 12"] pub fn ip_12 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 12"] pub fn set_ip_12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 13"] pub fn ip_13 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 13"] pub fn set_ip_13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 14"] pub fn ip_14 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 14"] pub fn set_ip_14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 15"] pub fn ip_15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 15"] pub fn set_ip_15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR4 (u32) ; impl NVIC_IPR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 16"] pub fn ip_16 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 16"] pub fn set_ip_16 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 17"] pub fn ip_17 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 17"] pub fn set_ip_17 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 18"] pub fn ip_18 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 18"] pub fn set_ip_18 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 19"] pub fn ip_19 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 19"] pub fn set_ip_19 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR5 (u32) ; impl NVIC_IPR5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 20"] pub fn ip_20 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 20"] pub fn set_ip_20 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 21"] pub fn ip_21 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 21"] pub fn set_ip_21 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 22"] pub fn ip_22 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 22"] pub fn set_ip_22 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 23"] pub fn ip_23 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 23"] pub fn set_ip_23 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR6 (u32) ; impl NVIC_IPR6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 24"] pub fn ip_24 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 24"] pub fn set_ip_24 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 25"] pub fn ip_25 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 25"] pub fn set_ip_25 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 26"] pub fn ip_26 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 26"] pub fn set_ip_26 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 27"] pub fn ip_27 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 27"] pub fn set_ip_27 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest."] pub struct NVIC_IPR7 (u32) ; impl NVIC_IPR7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of interrupt 28"] pub fn ip_28 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Priority of interrupt 28"] pub fn set_ip_28 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Priority of interrupt 29"] pub fn ip_29 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Priority of interrupt 29"] pub fn set_ip_29 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Priority of interrupt 30"] pub fn ip_30 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of interrupt 30"] pub fn set_ip_30 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of interrupt 31"] pub fn ip_31 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of interrupt 31"] pub fn set_ip_31 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core."] pub struct CPUID (u32) ; impl CPUID { pub const RESET_VALUE : u32 = 1091356161u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Minor revision number m in the rnpm revision status: \n                            0x1 = Patch 1."] pub fn revision (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Number of processor within family: 0xC60 = Cortex-M0+"] pub fn partno (& self) -> u32 { (self . 0 >> 4u32) & 4095u32 } # [doc = "Constant that defines the architecture of the processor: \n                            0xC = ARMv6-M architecture."] pub fn architecture (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Major revision number n in the rnpm revision status: \n                            0x0 = Revision 0."] pub fn variant (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Implementor code: 0x41 = ARM"] pub fn implementer (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception."] pub struct ICSR (u32) ; impl ICSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Active exception number field. Reset clears the VECTACTIVE field."] pub fn vectactive (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Indicates the exception number for the highest priority pending exception: 0 = no pending exceptions. Non zero = The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier."] pub fn vectpending (& self) -> u32 { (self . 0 >> 12u32) & 511u32 } # [doc = "External interrupt pending flag"] pub fn isrpending (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "The system can only access this bit when the core is halted. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced."] pub fn isrpreempt (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "SysTick exception clear-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Removes the pending state from the SysTick exception. \n                            This bit is WO. On a register read its value is Unknown."] pub fn pendstclr (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "SysTick exception clear-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Removes the pending state from the SysTick exception. \n                            This bit is WO. On a register read its value is Unknown."] pub fn set_pendstclr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "SysTick exception set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes SysTick exception state to pending. \n                            Read: \n                            0 = SysTick exception is not pending. \n                            1 = SysTick exception is pending."] pub fn pendstset (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "SysTick exception set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes SysTick exception state to pending. \n                            Read: \n                            0 = SysTick exception is not pending. \n                            1 = SysTick exception is pending."] pub fn set_pendstset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "PendSV clear-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Removes the pending state from the PendSV exception."] pub fn pendsvclr (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "PendSV clear-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Removes the pending state from the PendSV exception."] pub fn set_pendsvclr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "PendSV set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes PendSV exception state to pending. \n                            Read: \n                            0 = PendSV exception is not pending. \n                            1 = PendSV exception is pending. \n                            Writing 1 to this bit is the only way to set the PendSV exception state to pending."] pub fn pendsvset (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "PendSV set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes PendSV exception state to pending. \n                            Read: \n                            0 = PendSV exception is not pending. \n                            1 = PendSV exception is pending. \n                            Writing 1 to this bit is the only way to set the PendSV exception state to pending."] pub fn set_pendsvset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. \n                            NMI set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes NMI exception state to pending. \n                            Read: \n                            0 = NMI exception is not pending. \n                            1 = NMI exception is pending. \n                            Because NMI is the highest-priority exception, normally the processor enters the NMI \n                            exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears \n                            this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the \n                            NMI signal is reasserted while the processor is executing that handler."] pub fn nmipendset (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. \n                            NMI set-pending bit. \n                            Write: \n                            0 = No effect. \n                            1 = Changes NMI exception state to pending. \n                            Read: \n                            0 = NMI exception is not pending. \n                            1 = NMI exception is pending. \n                            Because NMI is the highest-priority exception, normally the processor enters the NMI \n                            exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears \n                            this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the \n                            NMI signal is reasserted while the processor is executing that handler."] pub fn set_nmipendset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The VTOR holds the vector table offset address."] pub struct VTOR (u32) ; impl VTOR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bits [31:8] of the indicate the vector table offset address."] pub fn tbloff (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Bits [31:8] of the indicate the vector table offset address."] pub fn set_tbloff (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset."] pub struct AIRCR (u32) ; impl AIRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted.  When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack."] pub fn vectclractive (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted.  When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack."] pub fn set_vectclractive (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device."] pub fn sysresetreq (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device."] pub fn set_sysresetreq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Data endianness implemented: \n                            0 = Little-endian."] pub fn endianess (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Register key: \n                            Reads as Unknown \n                            On writes, write 0x05FA to VECTKEY, otherwise the write is ignored."] pub fn vectkey (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Register key: \n                            Reads as Unknown \n                            On writes, write 0x05FA to VECTKEY, otherwise the write is ignored."] pub fn set_vectkey (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states."] pub struct SCR (u32) ; impl SCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates sleep-on-exit when returning from Handler mode to Thread mode: \n                            0 = Do not sleep when returning to Thread mode. \n                            1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode. \n                            Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application."] pub fn sleeponexit (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Indicates sleep-on-exit when returning from Handler mode to Thread mode: \n                            0 = Do not sleep when returning to Thread mode. \n                            1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode. \n                            Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application."] pub fn set_sleeponexit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Controls whether the processor uses sleep or deep sleep as its low power mode: \n                            0 = Sleep. \n                            1 = Deep sleep."] pub fn sleepdeep (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Controls whether the processor uses sleep or deep sleep as its low power mode: \n                            0 = Sleep. \n                            1 = Deep sleep."] pub fn set_sleepdeep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Send Event on Pending bit: \n                            0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded. \n                            1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor. \n                            When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the \n                            processor is not waiting for an event, the event is registered and affects the next WFE. \n                            The processor also wakes up on execution of an SEV instruction or an external event."] pub fn sevonpend (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Send Event on Pending bit: \n                            0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded. \n                            1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor. \n                            When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the \n                            processor is not waiting for an event, the event is registered and affects the next WFE. \n                            The processor also wakes up on execution of an SEV instruction or an external event."] pub fn set_sevonpend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault."] pub struct CCR (u32) ; impl CCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Always reads as one, indicates that all unaligned accesses generate a HardFault."] pub fn unalign_trp (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Always reads as one, indicates 8-byte stack alignment on exception entry. On exception entry, the processor uses bit[9] of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment."] pub fn stkalign (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall."] pub struct SHPR2 (u32) ; impl SHPR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of system handler 11, SVCall"] pub fn pri_11 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of system handler 11, SVCall"] pub fn set_pri_11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick."] pub struct SHPR3 (u32) ; impl SHPR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Priority of system handler 14, PendSV"] pub fn pri_14 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Priority of system handler 14, PendSV"] pub fn set_pri_14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Priority of system handler 15, SysTick"] pub fn pri_15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Priority of system handler 15, SysTick"] pub fn set_pri_15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the System Handler Control and State Register to determine or clear the pending status of SVCall."] pub struct SHCSR (u32) ; impl SHCSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0 to clear pending SVCall."] pub fn svcallpended (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0 to clear pending SVCall."] pub fn set_svcallpended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports."] pub struct MPU_TYPE (u32) ; impl MPU_TYPE { pub const RESET_VALUE : u32 = 2048u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates support for separate instruction and data address maps. Reads as 0 as ARMv6-M only supports a unified MPU."] pub fn separate (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Number of regions supported by the MPU."] pub fn dregion (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Instruction region. Reads as zero as ARMv6-M only supports a unified MPU."] pub fn iregion (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs."] pub struct MPU_CTRL (u32) ; impl MPU_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map. \n                            0 = MPU disabled. \n                            1 = MPU enabled."] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map. \n                            0 = MPU disabled. \n                            1 = MPU enabled."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour. \n                            When the MPU is enabled: \n                            0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit. \n                            1 = the MPU is enabled during HardFault and NMI handlers."] pub fn hfnmiena (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour. \n                            When the MPU is enabled: \n                            0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit. \n                            1 = the MPU is enabled during HardFault and NMI handlers."] pub fn set_hfnmiena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear. \n                            0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not \n                            covered by any enabled region causes a fault. \n                            1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses. \n                            When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map."] pub fn privdefena (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear. \n                            0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not \n                            covered by any enabled region causes a fault. \n                            1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses. \n                            When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map."] pub fn set_privdefena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR."] pub struct MPU_RNR (u32) ; impl MPU_RNR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers. \n                            The MPU supports 8 memory regions, so the permitted values of this field are 0-7."] pub fn region (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers. \n                            The MPU supports 8 memory regions, so the permitted values of this field are 0-7."] pub fn set_region (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated."] pub struct MPU_RBAR (u32) ; impl MPU_RBAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR."] pub fn region (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR."] pub fn set_region (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region. \n                            Write: \n                            0 = MPU_RNR not changed, and the processor: \n                            Updates the base address for the region specified in the MPU_RNR. \n                            Ignores the value of the REGION field. \n                            1 = The processor: \n                            Updates the value of the MPU_RNR to the value of the REGION field. \n                            Updates the base address for the region specified in the REGION field. \n                            Always reads as zero."] pub fn valid (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region. \n                            Write: \n                            0 = MPU_RNR not changed, and the processor: \n                            Updates the base address for the region specified in the MPU_RNR. \n                            Ignores the value of the REGION field. \n                            1 = The processor: \n                            Updates the value of the MPU_RNR to the value of the REGION field. \n                            Updates the base address for the region specified in the REGION field. \n                            Always reads as zero."] pub fn set_valid (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Base address of the region."] pub fn addr (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Base address of the region."] pub fn set_addr (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region."] pub struct MPU_RASR (u32) ; impl MPU_RASR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enables the region."] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enables the region."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes"] pub fn size (& self) -> u32 { (self . 0 >> 1u32) & 31u32 } # [doc = "Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes"] pub fn set_size (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled."] pub fn srd (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled."] pub fn set_srd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "The MPU Region Attribute field. Use to define the region attribute control. \n                            28 = XN: Instruction access disable bit: \n                            0 = Instruction fetches enabled. \n                            1 = Instruction fetches disabled. \n                            26:24 = AP: Access permission field \n                            18 = S: Shareable bit \n                            17 = C: Cacheable bit \n                            16 = B: Bufferable bit"] pub fn attrs (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "The MPU Region Attribute field. Use to define the region attribute control. \n                            28 = XN: Instruction access disable bit: \n                            0 = Instruction fetches enabled. \n                            1 = Instruction fetches disabled. \n                            26:24 = AP: Access permission field \n                            18 = S: Shareable bit \n                            17 = C: Cacheable bit \n                            16 = B: Bufferable bit"] pub fn set_attrs (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod uart1 { # [doc = "No description"] pub struct UART1 ; impl UART1 { pub const BASE_ADDR : u64 = 1073971200u64 ; } # [doc = "Data Register, UARTDR"] pub struct UARTDR (u32) ; impl UARTDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive (read) data character. Transmit (write) data character."] pub fn data (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive (read) data character. Transmit (write) data character."] pub fn set_data (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn fe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn pe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received."] pub fn be (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it."] pub fn oe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive Status Register/Error Clear Register, UARTRSR/UARTECR"] pub struct UARTRSR (u32) ; impl UARTRSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn fe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn set_fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn pe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn set_pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] pub fn be (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] pub fn set_be (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."] pub fn oe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."] pub fn set_oe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flag Register, UARTFR"] pub struct UARTFR (u32) ; impl UARTFR { pub const RESET_VALUE : u32 = 144u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW."] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW."] pub fn dsr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW."] pub fn dcd (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not."] pub fn busy (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty."] pub fn rxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full."] pub fn txff (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full."] pub fn rxff (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register."] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW."] pub fn ri (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "IrDA Low-Power Counter Register, UARTILPR"] pub struct UARTILPR (u32) ; impl UARTILPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "8-bit low-power divisor value. These bits are cleared to 0 at reset."] pub fn ilpdvsr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "8-bit low-power divisor value. These bits are cleared to 0 at reset."] pub fn set_ilpdvsr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Integer Baud Rate Register, UARTIBRD"] pub struct UARTIBRD (u32) ; impl UARTIBRD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The integer baud rate divisor. These bits are cleared to 0 on reset."] pub fn baud_divint (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "The integer baud rate divisor. These bits are cleared to 0 on reset."] pub fn set_baud_divint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fractional Baud Rate Register, UARTFBRD"] pub struct UARTFBRD (u32) ; impl UARTFBRD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The fractional baud rate divisor. These bits are cleared to 0 on reset."] pub fn baud_divfrac (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "The fractional baud rate divisor. These bits are cleared to 0 on reset."] pub fn set_baud_divfrac (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Line Control Register, UARTLCR_H"] pub struct UARTLCR_H (u32) ; impl UARTLCR_H { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0."] pub fn brk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0."] pub fn set_brk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled."] pub fn pen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled."] pub fn set_pen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn eps (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn set_eps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received."] pub fn stp2 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received."] pub fn set_stp2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode)."] pub fn fen (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode)."] pub fn set_fen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits."] pub fn wlen (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits."] pub fn set_wlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn sps (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn set_sps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control Register, UARTCR"] pub struct UARTCR (u32) ; impl UARTCR { pub const RESET_VALUE : u32 = 768u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit."] pub fn uarten (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit."] pub fn set_uarten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART."] pub fn siren (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART."] pub fn set_siren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances."] pub fn sirlp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances."] pub fn set_sirlp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback."] pub fn lbe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback."] pub fn set_lbe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping."] pub fn txe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping."] pub fn set_txe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping."] pub fn rxe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping."] pub fn set_rxe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW."] pub fn dtr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW."] pub fn set_dtr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW."] pub fn rts (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW."] pub fn set_rts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD)."] pub fn out1 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD)."] pub fn set_out1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI)."] pub fn out2 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI)."] pub fn set_out2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received."] pub fn rtsen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received."] pub fn set_rtsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted."] pub fn ctsen (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted."] pub fn set_ctsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt FIFO Level Select Register, UARTIFLS"] pub struct UARTIFLS (u32) ; impl UARTIFLS { pub const RESET_VALUE : u32 = 18u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved."] pub fn txiflsel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved."] pub fn set_txiflsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved."] pub fn rxiflsel (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved."] pub fn set_rxiflsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Mask Set/Clear Register, UARTIMSC"] pub struct UARTIMSC (u32) ; impl UARTIMSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask."] pub fn rimim (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rimim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask."] pub fn ctsmim (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask."] pub fn set_ctsmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask."] pub fn dcdmim (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask."] pub fn set_dcdmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask."] pub fn dsrmim (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask."] pub fn set_dsrmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask."] pub fn rxim (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rxim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask."] pub fn txim (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask."] pub fn set_txim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask."] pub fn rtim (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rtim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask."] pub fn feim (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_feim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask."] pub fn peim (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_peim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask."] pub fn beim (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_beim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask."] pub fn oeim (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_oeim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupt Status Register, UARTRIS"] pub struct UARTRIS (u32) ; impl UARTRIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt."] pub fn rirmis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt."] pub fn ctsrmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt."] pub fn dcdrmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt."] pub fn dsrrmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt."] pub fn rxris (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt."] pub fn txris (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a"] pub fn rtris (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt."] pub fn feris (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt."] pub fn peris (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt."] pub fn beris (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt."] pub fn oeris (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Masked Interrupt Status Register, UARTMIS"] pub struct UARTMIS (u32) ; impl UARTMIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt."] pub fn rimmis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt."] pub fn ctsmmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt."] pub fn dcdmmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt."] pub fn dsrmmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt."] pub fn rxmis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt."] pub fn txmis (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt."] pub fn rtmis (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt."] pub fn femis (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt."] pub fn pemis (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt."] pub fn bemis (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt."] pub fn oemis (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Clear Register, UARTICR"] pub struct UARTICR (u32) ; impl UARTICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt."] pub fn rimic (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt."] pub fn set_rimic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt."] pub fn ctsmic (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt."] pub fn set_ctsmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt."] pub fn dcdmic (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt."] pub fn set_dcdmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt."] pub fn dsrmic (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt."] pub fn set_dsrmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive interrupt clear. Clears the UARTRXINTR interrupt."] pub fn rxic (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive interrupt clear. Clears the UARTRXINTR interrupt."] pub fn set_rxic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Transmit interrupt clear. Clears the UARTTXINTR interrupt."] pub fn txic (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Transmit interrupt clear. Clears the UARTTXINTR interrupt."] pub fn set_txic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Receive timeout interrupt clear. Clears the UARTRTINTR interrupt."] pub fn rtic (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Receive timeout interrupt clear. Clears the UARTRTINTR interrupt."] pub fn set_rtic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Framing error interrupt clear. Clears the UARTFEINTR interrupt."] pub fn feic (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Framing error interrupt clear. Clears the UARTFEINTR interrupt."] pub fn set_feic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Parity error interrupt clear. Clears the UARTPEINTR interrupt."] pub fn peic (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error interrupt clear. Clears the UARTPEINTR interrupt."] pub fn set_peic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Break error interrupt clear. Clears the UARTBEINTR interrupt."] pub fn beic (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error interrupt clear. Clears the UARTBEINTR interrupt."] pub fn set_beic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Overrun error interrupt clear. Clears the UARTOEINTR interrupt."] pub fn oeic (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error interrupt clear. Clears the UARTOEINTR interrupt."] pub fn set_oeic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Control Register, UARTDMACR"] pub struct UARTDMACR (u32) ; impl UARTDMACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn rxdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn set_rxdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn txdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn set_txdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted."] pub fn dmaonerr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted."] pub fn set_dmaonerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID0 Register"] pub struct UARTPERIPHID0 (u32) ; impl UARTPERIPHID0 { pub const RESET_VALUE : u32 = 17u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x11"] pub fn partnumber0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID1 Register"] pub struct UARTPERIPHID1 (u32) ; impl UARTPERIPHID1 { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0"] pub fn partnumber1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits read back as 0x1"] pub fn designer0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID2 Register"] pub struct UARTPERIPHID2 (u32) ; impl UARTPERIPHID2 { pub const RESET_VALUE : u32 = 52u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x4"] pub fn designer1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3"] pub fn revision (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID3 Register"] pub struct UARTPERIPHID3 (u32) ; impl UARTPERIPHID3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x00"] pub fn configuration (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID0 Register"] pub struct UARTPCELLID0 (u32) ; impl UARTPCELLID0 { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0D"] pub fn uartpcellid0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID1 Register"] pub struct UARTPCELLID1 (u32) ; impl UARTPCELLID1 { pub const RESET_VALUE : u32 = 240u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xF0"] pub fn uartpcellid1 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID2 Register"] pub struct UARTPCELLID2 (u32) ; impl UARTPCELLID2 { pub const RESET_VALUE : u32 = 5u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x05"] pub fn uartpcellid2 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID3 Register"] pub struct UARTPCELLID3 (u32) ; impl UARTPCELLID3 { pub const RESET_VALUE : u32 = 177u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xB1"] pub fn uartpcellid3 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pll_sys { # [doc = "No description"] pub struct PLL_SYS ; impl PLL_SYS { pub const BASE_ADDR : u64 = 1073905664u64 ; } # [doc = "Control and Status \n                    GENERAL CONSTRAINTS: \n                    Reference clock frequency min=5MHz, max=800MHz \n                    Feedback divider min=16, max=320 \n                    VCO frequency min=750MHz, max=1600MHz"] pub struct CS (u32) ; impl CS { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Divides the PLL input reference clock. \n                            Behaviour is undefined for div=0. \n                            PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it."] pub fn refdiv (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Divides the PLL input reference clock. \n                            Behaviour is undefined for div=0. \n                            PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it."] pub fn set_refdiv (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so."] pub fn bypass (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so."] pub fn set_bypass (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "PLL is locked"] pub fn lock (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the PLL power modes."] pub struct PWR (u32) ; impl PWR { pub const RESET_VALUE : u32 = 45u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "PLL powerdown \n                            To save power set high when PLL output not required."] pub fn pd (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "PLL powerdown \n                            To save power set high when PLL output not required."] pub fn set_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "PLL DSM powerdown \n                            Nothing is achieved by setting this low."] pub fn dsmpd (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "PLL DSM powerdown \n                            Nothing is achieved by setting this low."] pub fn set_dsmpd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "PLL post divider powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn postdivpd (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "PLL post divider powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn set_postdivpd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "PLL VCO powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn vcopd (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "PLL VCO powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn set_vcopd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Feedback divisor \n                    (note: this PLL does not support fractional division)"] pub struct FBDIV_INT (u32) ; impl FBDIV_INT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "see ctrl reg description for constraints"] pub fn fbdiv_int (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "see ctrl reg description for constraints"] pub fn set_fbdiv_int (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the PLL post dividers for the primary output \n                    (note: this PLL does not have a secondary output) \n                    the primary output is driven from VCO divided by postdiv1*postdiv2"] pub struct PRIM (u32) ; impl PRIM { pub const RESET_VALUE : u32 = 487424u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "divide by 1-7"] pub fn postdiv2 (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "divide by 1-7"] pub fn set_postdiv2 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "divide by 1-7"] pub fn postdiv1 (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "divide by 1-7"] pub fn set_postdiv1 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pio0 { # [doc = "Programmable IO block"] pub struct PIO0 ; impl PIO0 { pub const BASE_ADDR : u64 = 1344274432u64 ; } # [doc = "PIO control register"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously."] pub fn sm_enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously."] pub fn set_sm_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.\n\n                            Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY.\n\n                            The program counter, the contents of the output shift register and the X/Y scratch registers are not affected."] pub fn sm_restart (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution.\n\n                            Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY.\n\n                            The program counter, the contents of the output shift register and the X/Y scratch registers are not affected."] pub fn set_sm_restart (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.\n\n                            Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n                            Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly."] pub fn clkdiv_restart (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep.\n\n                            Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n                            Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly."] pub fn set_clkdiv_restart (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO status register"] pub struct FSTAT (u32) ; impl FSTAT { pub const RESET_VALUE : u32 = 251662080u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "State machine RX FIFO is full"] pub fn rxfull (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "State machine RX FIFO is empty"] pub fn rxempty (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "State machine TX FIFO is full"] pub fn txfull (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "State machine TX FIFO is empty"] pub fn txempty (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO debug register"] pub struct FDEBUG (u32) ; impl FDEBUG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear."] pub fn rxstall (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear."] pub fn set_rxstall (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error."] pub fn rxunder (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error."] pub fn set_rxunder (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor."] pub fn txover (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor."] pub fn set_txover (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear."] pub fn txstall (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear."] pub fn set_txstall (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO levels"] pub struct FLEVEL (u32) ; impl FLEVEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn tx0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn rx0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "No description"] pub fn tx1 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "No description"] pub fn rx1 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "No description"] pub fn tx2 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "No description"] pub fn rx2 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "No description"] pub fn tx3 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "No description"] pub fn rx3 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF0 (u32) ; impl TXF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF1 (u32) ; impl TXF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF2 (u32) ; impl TXF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."] pub struct TXF3 (u32) ; impl TXF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn txf3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_txf3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF0 (u32) ; impl RXF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF1 (u32) ; impl RXF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF2 (u32) ; impl RXF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."] pub struct RXF3 (u32) ; impl RXF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn rxf3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag.\n\n                    Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE."] pub struct IRQ (u32) ; impl IRQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn irq (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_irq (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines."] pub struct IRQ_FORCE (u32) ; impl IRQ_FORCE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn irq_force (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_irq_force (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. \n                    0 -> input is synchronized (default) \n                    1 -> synchronizer is bypassed \n                    If in doubt, leave this register as all zeroes."] pub struct INPUT_SYNC_BYPASS (u32) ; impl INPUT_SYNC_BYPASS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn input_sync_bypass (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "No description"] pub fn set_input_sync_bypass (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."] pub struct DBG_PADOUT (u32) ; impl DBG_PADOUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn dbg_padout (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."] pub struct DBG_PADOE (u32) ; impl DBG_PADOE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn dbg_padoe (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The PIO hardware has some free parameters that may vary between chip products. \n                    These should be provided in the chip datasheet, but are also exposed here."] pub struct DBG_CFGINFO (u32) ; impl DBG_CFGINFO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The depth of the state machine TX/RX FIFOs, measured in words. \n                            Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double \n                            this depth."] pub fn fifo_depth (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "The number of state machines this PIO instance is equipped with."] pub fn sm_count (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "The size of the instruction memory, measured in units of one instruction"] pub fn imem_size (& self) -> u32 { (self . 0 >> 16u32) & 63u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 0"] pub struct INSTR_MEM0 (u32) ; impl INSTR_MEM0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem0 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem0 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 1"] pub struct INSTR_MEM1 (u32) ; impl INSTR_MEM1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 2"] pub struct INSTR_MEM2 (u32) ; impl INSTR_MEM2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem2 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem2 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 3"] pub struct INSTR_MEM3 (u32) ; impl INSTR_MEM3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem3 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem3 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 4"] pub struct INSTR_MEM4 (u32) ; impl INSTR_MEM4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem4 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem4 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 5"] pub struct INSTR_MEM5 (u32) ; impl INSTR_MEM5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem5 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem5 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 6"] pub struct INSTR_MEM6 (u32) ; impl INSTR_MEM6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem6 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem6 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 7"] pub struct INSTR_MEM7 (u32) ; impl INSTR_MEM7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem7 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem7 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 8"] pub struct INSTR_MEM8 (u32) ; impl INSTR_MEM8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem8 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem8 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 9"] pub struct INSTR_MEM9 (u32) ; impl INSTR_MEM9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem9 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem9 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 10"] pub struct INSTR_MEM10 (u32) ; impl INSTR_MEM10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem10 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem10 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 11"] pub struct INSTR_MEM11 (u32) ; impl INSTR_MEM11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem11 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem11 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 12"] pub struct INSTR_MEM12 (u32) ; impl INSTR_MEM12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem12 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem12 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 13"] pub struct INSTR_MEM13 (u32) ; impl INSTR_MEM13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem13 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem13 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 14"] pub struct INSTR_MEM14 (u32) ; impl INSTR_MEM14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem14 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem14 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 15"] pub struct INSTR_MEM15 (u32) ; impl INSTR_MEM15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem15 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem15 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 16"] pub struct INSTR_MEM16 (u32) ; impl INSTR_MEM16 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem16 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem16 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 17"] pub struct INSTR_MEM17 (u32) ; impl INSTR_MEM17 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem17 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem17 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 18"] pub struct INSTR_MEM18 (u32) ; impl INSTR_MEM18 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem18 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem18 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 19"] pub struct INSTR_MEM19 (u32) ; impl INSTR_MEM19 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem19 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem19 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 20"] pub struct INSTR_MEM20 (u32) ; impl INSTR_MEM20 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem20 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem20 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 21"] pub struct INSTR_MEM21 (u32) ; impl INSTR_MEM21 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem21 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem21 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 22"] pub struct INSTR_MEM22 (u32) ; impl INSTR_MEM22 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem22 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem22 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 23"] pub struct INSTR_MEM23 (u32) ; impl INSTR_MEM23 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem23 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem23 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 24"] pub struct INSTR_MEM24 (u32) ; impl INSTR_MEM24 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem24 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem24 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 25"] pub struct INSTR_MEM25 (u32) ; impl INSTR_MEM25 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem25 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem25 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 26"] pub struct INSTR_MEM26 (u32) ; impl INSTR_MEM26 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem26 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem26 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 27"] pub struct INSTR_MEM27 (u32) ; impl INSTR_MEM27 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem27 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem27 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 28"] pub struct INSTR_MEM28 (u32) ; impl INSTR_MEM28 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem28 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem28 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 29"] pub struct INSTR_MEM29 (u32) ; impl INSTR_MEM29 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem29 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem29 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 30"] pub struct INSTR_MEM30 (u32) ; impl INSTR_MEM30 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem30 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem30 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write-only access to instruction memory location 31"] pub struct INSTR_MEM31 (u32) ; impl INSTR_MEM31 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn instr_mem31 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_instr_mem31 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 0 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM0_CLKDIV (u32) ; impl SM0_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 0"] pub struct SM0_EXECCTRL (u32) ; impl SM0_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 0"] pub struct SM0_SHIFTCTRL (u32) ; impl SM0_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 0"] pub struct SM0_ADDR (u32) ; impl SM0_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 0's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM0_INSTR (u32) ; impl SM0_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm0_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM0_PINCTRL (u32) ; impl SM0_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 1 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM1_CLKDIV (u32) ; impl SM1_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 1"] pub struct SM1_EXECCTRL (u32) ; impl SM1_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 1"] pub struct SM1_SHIFTCTRL (u32) ; impl SM1_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 1"] pub struct SM1_ADDR (u32) ; impl SM1_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm1_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 1's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM1_INSTR (u32) ; impl SM1_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm1_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm1_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM1_PINCTRL (u32) ; impl SM1_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 2 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM2_CLKDIV (u32) ; impl SM2_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 2"] pub struct SM2_EXECCTRL (u32) ; impl SM2_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 2"] pub struct SM2_SHIFTCTRL (u32) ; impl SM2_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 2"] pub struct SM2_ADDR (u32) ; impl SM2_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm2_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 2's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM2_INSTR (u32) ; impl SM2_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm2_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm2_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM2_PINCTRL (u32) ; impl SM2_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor register for state machine 3 \n                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"] pub struct SM3_CLKDIV (u32) ; impl SM3_CLKDIV { pub const RESET_VALUE : u32 = 65536u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional part of clock divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Fractional part of clock divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn int (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Effective frequency is sysclk/(int + frac/256). \n                            Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0."] pub fn set_int (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Execution/behavioural settings for state machine 3"] pub struct SM3_EXECCTRL (u32) ; impl SM3_EXECCTRL { pub const RESET_VALUE : u32 = 126976u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn status_n (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Comparison level for the MOV x, STATUS instruction"] pub fn set_status_n (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn status_sel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Comparison used for the MOV x, STATUS instruction."] pub fn set_status_sel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn wrap_bottom (& self) -> u32 { (self . 0 >> 7u32) & 31u32 } # [doc = "After reaching wrap_top, execution is wrapped to this address."] pub fn set_wrap_bottom (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn wrap_top (& self) -> u32 { (self . 0 >> 12u32) & 31u32 } # [doc = "After reaching this address, execution is wrapped to wrap_bottom. \n                            If the instruction is a jump, and the jump condition is true, the jump takes priority."] pub fn set_wrap_top (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn out_sticky (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Continuously assert the most recent OUT/SET to the pins"] pub fn set_out_sticky (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn inline_out_en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "If 1, use a bit of OUT data as an auxiliary write enable \n                            When used in conjunction with OUT_STICKY, writes with an enable of 0 will \n                            deassert the latest pin write. This can create useful masking/override behaviour \n                            due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)"] pub fn set_inline_out_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Which data bit to use for inline OUT enable"] pub fn out_en_sel (& self) -> u32 { (self . 0 >> 19u32) & 31u32 } # [doc = "Which data bit to use for inline OUT enable"] pub fn set_out_en_sel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn jmp_pin (& self) -> u32 { (self . 0 >> 24u32) & 31u32 } # [doc = "The GPIO number to use as condition for JMP PIN. Unaffected by input mapping."] pub fn set_jmp_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn side_pindir (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "If 1, side-set data is asserted to pin directions, instead of pin values"] pub fn set_side_pindir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn side_en (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit."] pub fn set_side_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes."] pub fn exec_stalled (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control behaviour of the input/output shift registers for state machine 3"] pub struct SM3_SHIFTCTRL (u32) ; impl SM3_SHIFTCTRL { pub const RESET_VALUE : u32 = 786432u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn autopush (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH."] pub fn set_autopush (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn autopull (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH."] pub fn set_autopull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn in_shiftdir (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "1 = shift input shift register to right (data enters from left). 0 = to left."] pub fn set_in_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn out_shiftdir (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "1 = shift out of output shift register to right. 0 = to left."] pub fn set_out_shiftdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn push_thresh (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. \n                            Write 0 for value of 32."] pub fn set_push_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn pull_thresh (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. \n                            Write 0 for value of 32."] pub fn set_pull_thresh (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_tx (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. \n                            RX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_tx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn fjoin_rx (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. \n                            TX FIFO is disabled as a result (always reads as both full and empty). \n                            FIFOs are flushed when this bit is changed."] pub fn set_fjoin_rx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current instruction address of state machine 3"] pub struct SM3_ADDR (u32) ; impl SM3_ADDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm3_addr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read to see the instruction currently addressed by state machine 3's program counter \n                    Write to execute an instruction immediately (including jumps) and then resume execution."] pub struct SM3_INSTR (u32) ; impl SM3_INSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm3_instr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_sm3_instr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "State machine pin control"] pub struct SM3_PINCTRL (u32) ; impl SM3_PINCTRL { pub const RESET_VALUE : u32 = 335544320u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn out_base (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data."] pub fn set_out_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_base (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data."] pub fn set_set_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn sideset_base (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins."] pub fn set_sideset_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn in_base (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number."] pub fn set_in_base (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn out_count (& self) -> u32 { (self . 0 >> 20u32) & 63u32 } # [doc = "The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive."] pub fn set_out_count (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_count (& self) -> u32 { (self . 0 >> 26u32) & 7u32 } # [doc = "The number of pins asserted by a SET. In the range 0 to 5 inclusive."] pub fn set_set_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn sideset_count (& self) -> u32 { (self . 0 >> 29u32) & 7u32 } # [doc = "The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay)."] pub fn set_sideset_count (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for irq0"] pub struct IRQ0_INTE (u32) ; impl IRQ0_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for irq0"] pub struct IRQ0_INTF (u32) ; impl IRQ0_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for irq0"] pub struct IRQ0_INTS (u32) ; impl IRQ0_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for irq1"] pub struct IRQ1_INTE (u32) ; impl IRQ1_INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for irq1"] pub struct IRQ1_INTF (u32) ; impl IRQ1_INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_rxnempty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sm0_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sm1_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_sm2_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_sm3_txnfull (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_sm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_sm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_sm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_sm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for irq1"] pub struct IRQ1_INTS (u32) ; impl IRQ1_INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sm0_rxnempty (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn sm1_rxnempty (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn sm2_rxnempty (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn sm3_rxnempty (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn sm0_txnfull (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn sm1_txnfull (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn sm2_txnfull (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn sm3_txnfull (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn sm0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn sm1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn sm2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn sm3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pads_bank0 { # [doc = "No description"] pub struct PADS_BANK0 ; impl PADS_BANK0 { pub const BASE_ADDR : u64 = 1073856512u64 ; } # [doc = "Voltage select. Per bank control"] pub struct VOLTAGE_SELECT (u32) ; impl VOLTAGE_SELECT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn voltage_select (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_voltage_select (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO0 (u32) ; impl GPIO0 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO1 (u32) ; impl GPIO1 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO2 (u32) ; impl GPIO2 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO3 (u32) ; impl GPIO3 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO4 (u32) ; impl GPIO4 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO5 (u32) ; impl GPIO5 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO6 (u32) ; impl GPIO6 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO7 (u32) ; impl GPIO7 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO8 (u32) ; impl GPIO8 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO9 (u32) ; impl GPIO9 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO10 (u32) ; impl GPIO10 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO11 (u32) ; impl GPIO11 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO12 (u32) ; impl GPIO12 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO13 (u32) ; impl GPIO13 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO14 (u32) ; impl GPIO14 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO15 (u32) ; impl GPIO15 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO16 (u32) ; impl GPIO16 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO17 (u32) ; impl GPIO17 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO18 (u32) ; impl GPIO18 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO19 (u32) ; impl GPIO19 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO20 (u32) ; impl GPIO20 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO21 (u32) ; impl GPIO21 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO22 (u32) ; impl GPIO22 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO23 (u32) ; impl GPIO23 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO24 (u32) ; impl GPIO24 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO25 (u32) ; impl GPIO25 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO26 (u32) ; impl GPIO26 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO27 (u32) ; impl GPIO27 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO28 (u32) ; impl GPIO28 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct GPIO29 (u32) ; impl GPIO29 { pub const RESET_VALUE : u32 = 86u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct SWCLK (u32) ; impl SWCLK { pub const RESET_VALUE : u32 = 218u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pad control register"] pub struct SWD (u32) ; impl SWD { pub const RESET_VALUE : u32 = 90u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn slewfast (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slew rate control. 1 = Fast, 0 = Slow"] pub fn set_slewfast (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable schmitt trigger"] pub fn schmitt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable schmitt trigger"] pub fn set_schmitt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull down enable"] pub fn pde (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pull down enable"] pub fn set_pde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pull up enable"] pub fn pue (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pull up enable"] pub fn set_pue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Drive strength."] pub fn drive (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Drive strength."] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Input enable"] pub fn ie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Input enable"] pub fn set_ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn od (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output disable. Has priority over output enable from peripherals"] pub fn set_od (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod usb_dpram { # [doc = "DPRAM layout for USB device."] pub struct USB_DPRAM ; impl USB_DPRAM { pub const BASE_ADDR : u64 = 1343225856u64 ; } # [doc = "Bytes 0-3 of the SETUP packet from the host."] pub struct SETUP_PACKET_LOW (u32) ; impl SETUP_PACKET_LOW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn bmrequesttype (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_bmrequesttype (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn brequest (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "No description"] pub fn set_brequest (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn wvalue (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_wvalue (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bytes 4-7 of the setup packet from the host."] pub struct SETUP_PACKET_HIGH (u32) ; impl SETUP_PACKET_HIGH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn windex (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "No description"] pub fn set_windex (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn wlength (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "No description"] pub fn set_wlength (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP1_IN_CONTROL (u32) ; impl EP1_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP1_OUT_CONTROL (u32) ; impl EP1_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP2_IN_CONTROL (u32) ; impl EP2_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP2_OUT_CONTROL (u32) ; impl EP2_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP3_IN_CONTROL (u32) ; impl EP3_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP3_OUT_CONTROL (u32) ; impl EP3_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP4_IN_CONTROL (u32) ; impl EP4_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP4_OUT_CONTROL (u32) ; impl EP4_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP5_IN_CONTROL (u32) ; impl EP5_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP5_OUT_CONTROL (u32) ; impl EP5_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP6_IN_CONTROL (u32) ; impl EP6_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP6_OUT_CONTROL (u32) ; impl EP6_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP7_IN_CONTROL (u32) ; impl EP7_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP7_OUT_CONTROL (u32) ; impl EP7_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP8_IN_CONTROL (u32) ; impl EP8_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP8_OUT_CONTROL (u32) ; impl EP8_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP9_IN_CONTROL (u32) ; impl EP9_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP9_OUT_CONTROL (u32) ; impl EP9_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP10_IN_CONTROL (u32) ; impl EP10_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP10_OUT_CONTROL (u32) ; impl EP10_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP11_IN_CONTROL (u32) ; impl EP11_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP11_OUT_CONTROL (u32) ; impl EP11_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP12_IN_CONTROL (u32) ; impl EP12_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP12_OUT_CONTROL (u32) ; impl EP12_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP13_IN_CONTROL (u32) ; impl EP13_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP13_OUT_CONTROL (u32) ; impl EP13_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP14_IN_CONTROL (u32) ; impl EP14_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP14_OUT_CONTROL (u32) ; impl EP14_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP15_IN_CONTROL (u32) ; impl EP15_IN_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct EP15_OUT_CONTROL (u32) ; impl EP15_OUT_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn buffer_address (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM."] pub fn set_buffer_address (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn interrupt_on_nak (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Trigger an interrupt if a NAK is sent. Intended for debug only."] pub fn set_interrupt_on_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn interrupt_on_stall (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Trigger an interrupt if a STALL is sent. Intended for debug only."] pub fn set_interrupt_on_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn endpoint_type (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "No description"] pub fn set_endpoint_type (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn interrupt_per_double_buff (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Trigger an interrupt each time both buffers are done. Only valid in double buffered mode."] pub fn set_interrupt_per_double_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn interrupt_per_buff (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Trigger an interrupt each time a buffer is done."] pub fn set_interrupt_per_buff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "This endpoint is double buffered."] pub fn double_buffered (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "This endpoint is double buffered."] pub fn set_double_buffered (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn enable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP0_IN_BUFFER_CONTROL (u32) ; impl EP0_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP0_OUT_BUFFER_CONTROL (u32) ; impl EP0_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP1_IN_BUFFER_CONTROL (u32) ; impl EP1_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP1_OUT_BUFFER_CONTROL (u32) ; impl EP1_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP2_IN_BUFFER_CONTROL (u32) ; impl EP2_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP2_OUT_BUFFER_CONTROL (u32) ; impl EP2_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP3_IN_BUFFER_CONTROL (u32) ; impl EP3_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP3_OUT_BUFFER_CONTROL (u32) ; impl EP3_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP4_IN_BUFFER_CONTROL (u32) ; impl EP4_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP4_OUT_BUFFER_CONTROL (u32) ; impl EP4_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP5_IN_BUFFER_CONTROL (u32) ; impl EP5_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP5_OUT_BUFFER_CONTROL (u32) ; impl EP5_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP6_IN_BUFFER_CONTROL (u32) ; impl EP6_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP6_OUT_BUFFER_CONTROL (u32) ; impl EP6_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP7_IN_BUFFER_CONTROL (u32) ; impl EP7_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP7_OUT_BUFFER_CONTROL (u32) ; impl EP7_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP8_IN_BUFFER_CONTROL (u32) ; impl EP8_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP8_OUT_BUFFER_CONTROL (u32) ; impl EP8_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP9_IN_BUFFER_CONTROL (u32) ; impl EP9_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP9_OUT_BUFFER_CONTROL (u32) ; impl EP9_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP10_IN_BUFFER_CONTROL (u32) ; impl EP10_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP10_OUT_BUFFER_CONTROL (u32) ; impl EP10_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP11_IN_BUFFER_CONTROL (u32) ; impl EP11_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP11_OUT_BUFFER_CONTROL (u32) ; impl EP11_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP12_IN_BUFFER_CONTROL (u32) ; impl EP12_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP12_OUT_BUFFER_CONTROL (u32) ; impl EP12_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP13_IN_BUFFER_CONTROL (u32) ; impl EP13_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP13_OUT_BUFFER_CONTROL (u32) ; impl EP13_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP14_IN_BUFFER_CONTROL (u32) ; impl EP14_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP14_OUT_BUFFER_CONTROL (u32) ; impl EP14_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP15_IN_BUFFER_CONTROL (u32) ; impl EP15_IN_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. \n                    Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode."] pub struct EP15_OUT_BUFFER_CONTROL (u32) ; impl EP15_OUT_BUFFER_CONTROL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The length of the data in buffer 0."] pub fn length_0 (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The length of the data in buffer 0."] pub fn set_length_0 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Reply with a stall (valid for both buffers)."] pub fn stall (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Reply with a stall (valid for both buffers)."] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Reset the buffer selector to buffer 0."] pub fn reset_field (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reset the buffer selector to buffer 0."] pub fn set_reset_field (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "The data pid of buffer 0."] pub fn pid_0 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "The data pid of buffer 0."] pub fn set_pid_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn last_0 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Buffer 0 is the last buffer of the transfer."] pub fn set_last_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_0 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "The length of the data in buffer 1."] pub fn length_1 (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "The length of the data in buffer 1."] pub fn set_length_1 (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn available_1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back."] pub fn set_available_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn double_buffer_iso_offset (& self) -> u32 { (self . 0 >> 27u32) & 3u32 } # [doc = "The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. \n                            For a non Isochronous endpoint the offset is always 64 bytes."] pub fn set_double_buffer_iso_offset (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "The data pid of buffer 1."] pub fn pid_1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "The data pid of buffer 1."] pub fn set_pid_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn last_1 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Buffer 1 is the last buffer of the transfer."] pub fn set_last_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn full_1 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data."] pub fn set_full_1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2c0 { # [doc = "DW_apb_i2c address block\n\n            List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time):\n\n            IC_ULTRA_FAST_MODE ................ 0x0 \n            IC_UFM_TBUF_CNT_DEFAULT ........... 0x8 \n            IC_UFM_SCL_LOW_COUNT .............. 0x0008 \n            IC_UFM_SCL_HIGH_COUNT ............. 0x0006 \n            IC_TX_TL .......................... 0x0 \n            IC_TX_CMD_BLOCK ................... 0x1 \n            IC_HAS_DMA ........................ 0x1 \n            IC_HAS_ASYNC_FIFO ................. 0x0 \n            IC_SMBUS_ARP ...................... 0x0 \n            IC_FIRST_DATA_BYTE_STATUS ......... 0x1 \n            IC_INTR_IO ........................ 0x1 \n            IC_MASTER_MODE .................... 0x1 \n            IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1 \n            IC_INTR_POL ....................... 0x1 \n            IC_OPTIONAL_SAR ................... 0x0 \n            IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055 \n            IC_DEFAULT_SLAVE_ADDR ............. 0x055 \n            IC_DEFAULT_HS_SPKLEN .............. 0x1 \n            IC_FS_SCL_HIGH_COUNT .............. 0x0006 \n            IC_HS_SCL_LOW_COUNT ............... 0x0008 \n            IC_DEVICE_ID_VALUE ................ 0x0 \n            IC_10BITADDR_MASTER ............... 0x0 \n            IC_CLK_FREQ_OPTIMIZATION .......... 0x0 \n            IC_DEFAULT_FS_SPKLEN .............. 0x7 \n            IC_ADD_ENCODED_PARAMS ............. 0x0 \n            IC_DEFAULT_SDA_HOLD ............... 0x000001 \n            IC_DEFAULT_SDA_SETUP .............. 0x64 \n            IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0 \n            IC_CLOCK_PERIOD ................... 100 \n            IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1 \n            IC_RESTART_EN ..................... 0x1 \n            IC_TX_CMD_BLOCK_DEFAULT ........... 0x0 \n            IC_BUS_CLEAR_FEATURE .............. 0x0 \n            IC_CAP_LOADING .................... 100 \n            IC_FS_SCL_LOW_COUNT ............... 0x000d \n            APB_DATA_WIDTH .................... 32 \n            IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff \n            IC_SLV_DATA_NACK_ONLY ............. 0x1 \n            IC_10BITADDR_SLAVE ................ 0x0 \n            IC_CLK_TYPE ....................... 0x0 \n            IC_SMBUS_UDID_MSB ................. 0x0 \n            IC_SMBUS_SUSPEND_ALERT ............ 0x0 \n            IC_HS_SCL_HIGH_COUNT .............. 0x0006 \n            IC_SLV_RESTART_DET_EN ............. 0x1 \n            IC_SMBUS .......................... 0x0 \n            IC_OPTIONAL_SAR_DEFAULT ........... 0x0 \n            IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0 \n            IC_USE_COUNTS ..................... 0x0 \n            IC_RX_BUFFER_DEPTH ................ 16 \n            IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff \n            IC_RX_FULL_HLD_BUS_EN ............. 0x1 \n            IC_SLAVE_DISABLE .................. 0x1 \n            IC_RX_TL .......................... 0x0 \n            IC_DEVICE_ID ...................... 0x0 \n            IC_HC_COUNT_VALUES ................ 0x0 \n            I2C_DYNAMIC_TAR_UPDATE ............ 0 \n            IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff \n            IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff \n            IC_HS_MASTER_CODE ................. 0x1 \n            IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff \n            IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff \n            IC_SS_SCL_HIGH_COUNT .............. 0x0028 \n            IC_SS_SCL_LOW_COUNT ............... 0x002f \n            IC_MAX_SPEED_MODE ................. 0x2 \n            IC_STAT_FOR_CLK_STRETCH ........... 0x0 \n            IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0 \n            IC_DEFAULT_UFM_SPKLEN ............. 0x1 \n            IC_TX_BUFFER_DEPTH ................ 16"] pub struct I2C0 ; impl I2C0 { pub const BASE_ADDR : u64 = 1074020352u64 ; } # [doc = "I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                    Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only."] pub struct IC_CON (u32) ; impl IC_CON { pub const RESET_VALUE : u32 = 101u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This bit controls whether the DW_apb_i2c master is enabled.\n\n                            NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'."] pub fn master_mode (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This bit controls whether the DW_apb_i2c master is enabled.\n\n                            NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'."] pub fn set_master_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n                            This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n                            1: standard mode (100 kbit/s)\n\n                            2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n                            3: high speed mode (3.4 Mbit/s)\n\n                            Note: This field is not applicable when IC_ULTRA_FAST_MODE=1"] pub fn speed (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n                            This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n                            1: standard mode (100 kbit/s)\n\n                            2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n                            3: high speed mode (3.4 Mbit/s)\n\n                            Note: This field is not applicable when IC_ULTRA_FAST_MODE=1"] pub fn set_speed (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register."] pub fn ic_10bitaddr_slave (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register."] pub fn set_ic_10bitaddr_slave (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing"] pub fn ic_10bitaddr_master (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing"] pub fn set_ic_10bitaddr_master (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: ENABLED"] pub fn ic_restart_en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: ENABLED"] pub fn set_ic_restart_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n                            If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n                            NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0."] pub fn ic_slave_disable (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n                            If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n                            NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0."] pub fn set_ic_slave_disable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n                            NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR)."] pub fn stop_det_ifaddressed (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n                            NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR)."] pub fn set_stop_det_ifaddressed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0."] pub fn tx_empty_ctrl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0."] pub fn set_tx_empty_ctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n                            Reset value: 0x0."] pub fn rx_fifo_full_hld_ctrl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n                            Reset value: 0x0."] pub fn set_rx_fifo_full_hld_ctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Master issues the STOP_DET interrupt irrespective of whether master is active or not"] pub fn stop_det_if_master_active (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Target Address Register\n\n                    This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n                    Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only."] pub struct IC_TAR (u32) ; impl IC_TAR { pub const RESET_VALUE : u32 = 85u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n                            If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave."] pub fn ic_tar (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n                            If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave."] pub fn set_ic_tar (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0"] pub fn gc_or_start (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0"] pub fn set_gc_or_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0"] pub fn special (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0"] pub fn set_special (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Slave Address Register"] pub struct IC_SAR (u32) ; impl IC_SAR { pub const RESET_VALUE : u32 = 85u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values."] pub fn ic_sar (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values."] pub fn set_ic_sar (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n                    The size of the register changes as follows:\n\n                    Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging."] pub struct IC_DATA_CMD (u32) ; impl IC_DATA_CMD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n                            Reset value: 0x0"] pub fn dat (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n                            Reset value: 0x0"] pub fn set_dat (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n                            When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n                            When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n                            Reset value: 0x0"] pub fn cmd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n                            When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n                            When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n                            Reset value: 0x0"] pub fn set_cmd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit controls whether a STOP is issued after the byte is sent or received.\n\n                            - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0"] pub fn stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit controls whether a STOP is issued after the byte is sent or received.\n\n                            - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "This bit controls whether a RESTART is issued before the byte is sent or received.\n\n                            1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            Reset value: 0x0"] pub fn restart (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This bit controls whether a RESTART is issued before the byte is sent or received.\n\n                            1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            Reset value: 0x0"] pub fn set_restart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n                            Reset value : 0x0\n\n                            NOTE:  In case of APB_DATA_WIDTH=8,\n\n                            1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n                            2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n                            3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status."] pub fn first_data_byte (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Standard Speed I2C Clock SCL High Count Register"] pub struct IC_SS_SCL_HCNT (u32) ; impl IC_SS_SCL_HCNT { pub const RESET_VALUE : u32 = 40u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n                            NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10."] pub fn ic_ss_scl_hcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n                            NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10."] pub fn set_ic_ss_scl_hcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Standard Speed I2C Clock SCL Low Count Register"] pub struct IC_SS_SCL_LCNT (u32) ; impl IC_SS_SCL_LCNT { pub const RESET_VALUE : u32 = 47u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed."] pub fn ic_ss_scl_lcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed."] pub fn set_ic_ss_scl_lcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register"] pub struct IC_FS_SCL_HCNT (u32) ; impl IC_FS_SCL_HCNT { pub const RESET_VALUE : u32 = 6u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed."] pub fn ic_fs_scl_hcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed."] pub fn set_ic_fs_scl_hcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register"] pub struct IC_FS_SCL_LCNT (u32) ; impl IC_FS_SCL_LCNT { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8."] pub fn ic_fs_scl_lcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8."] pub fn set_ic_fs_scl_lcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Interrupt Status Register\n\n                    Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register."] pub struct IC_INTR_STAT (u32) ; impl IC_INTR_STAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n                            Reset value: 0x0"] pub fn r_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n                            Reset value: 0x0"] pub fn r_rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n                            Reset value: 0x0"] pub fn r_rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n                            Reset value: 0x0"] pub fn r_tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n                            Reset value: 0x0"] pub fn r_tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n                            Reset value: 0x0"] pub fn r_rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n                            Reset value: 0x0"] pub fn r_tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n                            Reset value: 0x0"] pub fn r_rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n                            Reset value: 0x0"] pub fn r_activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n                            Reset value: 0x0"] pub fn r_stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n                            Reset value: 0x0"] pub fn r_start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n                            Reset value: 0x0"] pub fn r_gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n                            Reset value: 0x0"] pub fn r_restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Interrupt Mask Register.\n\n                    These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt."] pub struct IC_INTR_MASK (u32) ; impl IC_INTR_MASK { pub const RESET_VALUE : u32 = 2303u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_under (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_over (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_full (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_over (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_empty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rd_req (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_abrt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_activity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_stop_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_start_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_gen_call (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_restart_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Raw Interrupt Status Register\n\n                    Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c."] pub struct IC_RAW_INTR_STAT (u32) ; impl IC_RAW_INTR_STAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Reset value: 0x0"] pub fn rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Note:  If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n                            Reset value: 0x0"] pub fn rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n                            Reset value: 0x0"] pub fn rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Reset value: 0x0"] pub fn tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n                            Reset value: 0x0."] pub fn tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n                            Reset value: 0x0"] pub fn rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n                            Note:  The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n                            Reset value: 0x0"] pub fn tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n                            Reset value: 0x0"] pub fn rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n                            Reset value: 0x0"] pub fn activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n                            In Slave Mode: - If IC_CON[7]=1'b1  (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1  (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0  (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0"] pub fn stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n                            Reset value: 0x0"] pub fn start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n                            Reset value: 0x0"] pub fn gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n                            Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n                            Reset value: 0x0"] pub fn restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive FIFO Threshold Register"] pub struct IC_RX_TL (u32) ; impl IC_RX_TL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO Threshold Level.\n\n                            Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries."] pub fn rx_tl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive FIFO Threshold Level.\n\n                            Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries."] pub fn set_rx_tl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit FIFO Threshold Register"] pub struct IC_TX_TL (u32) ; impl IC_TX_TL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO Threshold Level.\n\n                            Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries."] pub fn tx_tl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Transmit FIFO Threshold Level.\n\n                            Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries."] pub fn set_tx_tl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear Combined and Individual Interrupt Register"] pub struct IC_CLR_INTR (u32) ; impl IC_CLR_INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n                            Reset value: 0x0"] pub fn clr_intr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_UNDER Interrupt Register"] pub struct IC_CLR_RX_UNDER (u32) ; impl IC_CLR_RX_UNDER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_OVER Interrupt Register"] pub struct IC_CLR_RX_OVER (u32) ; impl IC_CLR_RX_OVER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_over (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear TX_OVER Interrupt Register"] pub struct IC_CLR_TX_OVER (u32) ; impl IC_CLR_TX_OVER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_tx_over (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RD_REQ Interrupt Register"] pub struct IC_CLR_RD_REQ (u32) ; impl IC_CLR_RD_REQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rd_req (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear TX_ABRT Interrupt Register"] pub struct IC_CLR_TX_ABRT (u32) ; impl IC_CLR_TX_ABRT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n                            Reset value: 0x0"] pub fn clr_tx_abrt (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_DONE Interrupt Register"] pub struct IC_CLR_RX_DONE (u32) ; impl IC_CLR_RX_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_done (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear ACTIVITY Interrupt Register"] pub struct IC_CLR_ACTIVITY (u32) ; impl IC_CLR_ACTIVITY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_activity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear STOP_DET Interrupt Register"] pub struct IC_CLR_STOP_DET (u32) ; impl IC_CLR_STOP_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_stop_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear START_DET Interrupt Register"] pub struct IC_CLR_START_DET (u32) ; impl IC_CLR_START_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_start_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear GEN_CALL Interrupt Register"] pub struct IC_CLR_GEN_CALL (u32) ; impl IC_CLR_GEN_CALL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_gen_call (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Enable Register"] pub struct IC_ENABLE (u32) ; impl IC_ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n                            When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n                            In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n                            Reset value: 0x0"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n                            When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n                            In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n                            Reset value: 0x0"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n                            For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n                            Reset value: 0x0"] pub fn abort (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n                            For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n                            Reset value: 0x0"] pub fn set_abort (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT"] pub fn tx_cmd_block (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT"] pub fn set_tx_cmd_block (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Status Register\n\n                    This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n                    When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0"] pub struct IC_STATUS (u32) ; impl IC_STATUS { pub const RESET_VALUE : u32 = 6u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2C Activity Status. Reset value: 0x0"] pub fn activity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1"] pub fn tfnf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1"] pub fn tfe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0"] pub fn rfne (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0"] pub fn rff (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n                            Reset value: 0x0"] pub fn mst_activity (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0"] pub fn slv_activity (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO."] pub struct IC_TXFLR (u32) ; impl IC_TXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n                            Reset value: 0x0"] pub fn txflr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO."] pub struct IC_RXFLR (u32) ; impl IC_RXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn rxflr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SDA Hold Time Length Register\n\n                    The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n                    The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n                    Writes to this register succeed only when IC_ENABLE[0]=0.\n\n                    The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.\n\n                    The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles."] pub struct IC_SDA_HOLD (u32) ; impl IC_SDA_HOLD { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[15:0]."] pub fn ic_sda_tx_hold (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[15:0]."] pub fn set_ic_sda_tx_hold (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[23:16]."] pub fn ic_sda_rx_hold (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[23:16]."] pub fn set_ic_sda_rx_hold (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit Abort Source Register\n\n                    This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n                    Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted."] pub struct IC_TX_ABRT_SOURCE (u32) ; impl IC_TX_ABRT_SOURCE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_7b_addr_noack (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_10addr1_noack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_10addr2_noack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_txdata_noack (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_gcall_noack (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_gcall_read (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_hs_ackdet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_sbyte_ackdet (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_hs_norstrt (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_sbyte_norstrt (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Receiver"] pub fn abrt_10b_rd_norstrt (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_master_dis (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter"] pub fn arb_lost (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slvflush_txfifo (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note:  Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slv_arblost (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slvrd_intx (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_user_abrt (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter"] pub fn tx_flush_cnt (& self) -> u32 { (self . 0 >> 23u32) & 511u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Generate Slave Data NACK Register\n\n                    The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n                    A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit."] pub struct IC_SLV_DATA_NACK_ONLY (u32) ; impl IC_SLV_DATA_NACK_ONLY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n                            When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0"] pub fn nack (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n                            When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0"] pub fn set_nack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Control Register\n\n                    The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE."] pub struct IC_DMA_CR (u32) ; impl IC_DMA_CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0"] pub fn rdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0"] pub fn set_rdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0"] pub fn tdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0"] pub fn set_tdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Transmit Data Level Register"] pub struct IC_DMA_TDLR (u32) ; impl IC_DMA_TDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n                            Reset value: 0x0"] pub fn dmatdl (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n                            Reset value: 0x0"] pub fn set_dmatdl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive Data Level Register"] pub struct IC_DMA_RDLR (u32) ; impl IC_DMA_RDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn dmardl (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn set_dmardl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SDA Setup Register\n\n                    This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n                    Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n                    Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter."] pub struct IC_SDA_SETUP (u32) ; impl IC_SDA_SETUP { pub const RESET_VALUE : u32 = 100u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2."] pub fn sda_setup (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2."] pub fn set_sda_setup (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C ACK General Call Register\n\n                    The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n                    This register is applicable only when the DW_apb_i2c is in slave mode."] pub struct IC_ACK_GENERAL_CALL (u32) ; impl IC_ACK_GENERAL_CALL { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe)."] pub fn ack_gen_call (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe)."] pub fn set_ack_gen_call (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Enable Status Register\n\n                    The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n                    If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n                    If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n                    Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities."] pub struct IC_ENABLE_STATUS (u32) ; impl IC_ENABLE_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:  The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n                            Reset value: 0x0"] pub fn ic_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n                            (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n                            OR,\n\n                            (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n                            When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n                            Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n                            When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n                            Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n                            Reset value: 0x0"] pub fn slv_disabled_while_busy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n                            Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n                            When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n                            Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n                            Reset value: 0x0"] pub fn slv_rx_data_lost (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SS, FS or FM+ spike suppression limit\n\n                    This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1."] pub struct IC_FS_SPKLEN (u32) ; impl IC_FS_SPKLEN { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'."] pub fn ic_fs_spklen (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'."] pub fn set_ic_fs_spklen (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RESTART_DET Interrupt Register"] pub struct IC_CLR_RESTART_DET (u32) ; impl IC_CLR_RESTART_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_restart_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Component Parameter Register 1\n\n                    Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters"] pub struct IC_COMP_PARAM_1 (u32) ; impl IC_COMP_PARAM_1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "APB data bus width is 32 bits"] pub fn apb_data_width (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "MAX SPEED MODE = FAST MODE"] pub fn max_speed_mode (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Programmable count values for each mode."] pub fn hc_count_values (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "COMBINED Interrupt outputs"] pub fn intr_io (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "DMA handshaking signals are enabled"] pub fn has_dma (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Encoded parameters not visible"] pub fn add_encoded_params (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "RX Buffer Depth = 16"] pub fn rx_buffer_depth (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "TX Buffer Depth = 16"] pub fn tx_buffer_depth (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Component Version Register"] pub struct IC_COMP_VERSION (u32) ; impl IC_COMP_VERSION { pub const RESET_VALUE : u32 = 842019114u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ic_comp_version (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Component Type Register"] pub struct IC_COMP_TYPE (u32) ; impl IC_COMP_TYPE { pub const RESET_VALUE : u32 = 1146552640u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number."] pub fn ic_comp_type (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pll_usb { # [doc = "No description"] pub struct PLL_USB ; impl PLL_USB { pub const BASE_ADDR : u64 = 1073922048u64 ; } # [doc = "Control and Status \n                    GENERAL CONSTRAINTS: \n                    Reference clock frequency min=5MHz, max=800MHz \n                    Feedback divider min=16, max=320 \n                    VCO frequency min=750MHz, max=1600MHz"] pub struct CS (u32) ; impl CS { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Divides the PLL input reference clock. \n                            Behaviour is undefined for div=0. \n                            PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it."] pub fn refdiv (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Divides the PLL input reference clock. \n                            Behaviour is undefined for div=0. \n                            PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it."] pub fn set_refdiv (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so."] pub fn bypass (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so."] pub fn set_bypass (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "PLL is locked"] pub fn lock (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the PLL power modes."] pub struct PWR (u32) ; impl PWR { pub const RESET_VALUE : u32 = 45u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "PLL powerdown \n                            To save power set high when PLL output not required."] pub fn pd (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "PLL powerdown \n                            To save power set high when PLL output not required."] pub fn set_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "PLL DSM powerdown \n                            Nothing is achieved by setting this low."] pub fn dsmpd (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "PLL DSM powerdown \n                            Nothing is achieved by setting this low."] pub fn set_dsmpd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "PLL post divider powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn postdivpd (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "PLL post divider powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn set_postdivpd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "PLL VCO powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn vcopd (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "PLL VCO powerdown \n                            To save power set high when PLL output not required or bypass=1."] pub fn set_vcopd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Feedback divisor \n                    (note: this PLL does not support fractional division)"] pub struct FBDIV_INT (u32) ; impl FBDIV_INT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "see ctrl reg description for constraints"] pub fn fbdiv_int (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "see ctrl reg description for constraints"] pub fn set_fbdiv_int (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the PLL post dividers for the primary output \n                    (note: this PLL does not have a secondary output) \n                    the primary output is driven from VCO divided by postdiv1*postdiv2"] pub struct PRIM (u32) ; impl PRIM { pub const RESET_VALUE : u32 = 487424u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "divide by 1-7"] pub fn postdiv2 (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "divide by 1-7"] pub fn set_postdiv2 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "divide by 1-7"] pub fn postdiv1 (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "divide by 1-7"] pub fn set_postdiv1 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod busctrl { # [doc = "Register block for busfabric control signals and performance counters"] pub struct BUSCTRL ; impl BUSCTRL { pub const BASE_ADDR : u64 = 1073938432u64 ; } # [doc = "Set the priority of each master for bus arbitration."] pub struct BUS_PRIORITY (u32) ; impl BUS_PRIORITY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0 - low priority, 1 - high priority"] pub fn proc0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "0 - low priority, 1 - high priority"] pub fn set_proc0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "0 - low priority, 1 - high priority"] pub fn proc1 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "0 - low priority, 1 - high priority"] pub fn set_proc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "0 - low priority, 1 - high priority"] pub fn dma_r (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "0 - low priority, 1 - high priority"] pub fn set_dma_r (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "0 - low priority, 1 - high priority"] pub fn dma_w (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "0 - low priority, 1 - high priority"] pub fn set_dma_w (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus priority acknowledge"] pub struct BUS_PRIORITY_ACK (u32) ; impl BUS_PRIORITY_ACK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Goes to 1 once all arbiters have registered the new global priority levels. \n                            Arbiters update their local priority when servicing a new nonsequential access. \n                            In normal circumstances this will happen almost immediately."] pub fn bus_priority_ack (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance counter 0"] pub struct PERFCTR0 (u32) ; impl PERFCTR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Busfabric saturating performance counter 0 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL0"] pub fn perfctr0 (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Busfabric saturating performance counter 0 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL0"] pub fn set_perfctr0 (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance event select for PERFCTR0"] pub struct PERFSEL0 (u32) ; impl PERFSEL0 { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Select an event for PERFCTR0. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn perfsel0 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Select an event for PERFCTR0. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn set_perfsel0 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance counter 1"] pub struct PERFCTR1 (u32) ; impl PERFCTR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Busfabric saturating performance counter 1 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL1"] pub fn perfctr1 (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Busfabric saturating performance counter 1 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL1"] pub fn set_perfctr1 (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance event select for PERFCTR1"] pub struct PERFSEL1 (u32) ; impl PERFSEL1 { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Select an event for PERFCTR1. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn perfsel1 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Select an event for PERFCTR1. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn set_perfsel1 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance counter 2"] pub struct PERFCTR2 (u32) ; impl PERFCTR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Busfabric saturating performance counter 2 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL2"] pub fn perfctr2 (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Busfabric saturating performance counter 2 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL2"] pub fn set_perfctr2 (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance event select for PERFCTR2"] pub struct PERFSEL2 (u32) ; impl PERFSEL2 { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Select an event for PERFCTR2. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn perfsel2 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Select an event for PERFCTR2. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn set_perfsel2 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance counter 3"] pub struct PERFCTR3 (u32) ; impl PERFCTR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Busfabric saturating performance counter 3 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL3"] pub fn perfctr3 (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Busfabric saturating performance counter 3 \n                            Count some event signal from the busfabric arbiters. \n                            Write any value to clear. Select an event to count using PERFSEL3"] pub fn set_perfctr3 (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bus fabric performance event select for PERFCTR3"] pub struct PERFSEL3 (u32) ; impl PERFSEL3 { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Select an event for PERFCTR3. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn perfsel3 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Select an event for PERFCTR3. Count either contested accesses, or all accesses, on a downstream port of the main crossbar."] pub fn set_perfsel3 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi1 { # [doc = "No description"] pub struct SPI1 ; impl SPI1 { pub const BASE_ADDR : u64 = 1074003968u64 ; } # [doc = "Control register 0, SSPCR0 on page 3-4"] pub struct SSPCR0 (u32) ; impl SSPCR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data."] pub fn dss (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data."] pub fn set_dss (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation."] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation."] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn spo (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn set_spo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn sph (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn set_sph (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255."] pub fn scr (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255."] pub fn set_scr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 1, SSPCR1 on page 3-5"] pub struct SSPCR1 (u32) ; impl SSPCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally."] pub fn lbm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally."] pub fn set_lbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled."] pub fn sse (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled."] pub fn set_sse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave."] pub fn ms (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave."] pub fn set_ms (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode."] pub fn sod (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode."] pub fn set_sod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register, SSPDR on page 3-6"] pub struct SSPDR (u32) ; impl SSPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies."] pub fn data (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies."] pub fn set_data (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register, SSPSR on page 3-7"] pub struct SSPSR (u32) ; impl SSPSR { pub const RESET_VALUE : u32 = 3u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty."] pub fn tfe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full."] pub fn tnf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty."] pub fn rne (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full."] pub fn rff (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty."] pub fn bsy (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock prescale register, SSPCPSR on page 3-8"] pub struct SSPCPSR (u32) ; impl SSPCPSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads."] pub fn cpsdvsr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads."] pub fn set_cpsdvsr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt mask set or clear register, SSPIMSC on page 3-9"] pub struct SSPIMSC (u32) ; impl SSPIMSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked."] pub fn rorim (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked."] pub fn set_rorim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked."] pub fn rtim (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked."] pub fn set_rtim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked."] pub fn rxim (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked."] pub fn set_rxim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked."] pub fn txim (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked."] pub fn set_txim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw interrupt status register, SSPRIS on page 3-10"] pub struct SSPRIS (u32) ; impl SSPRIS { pub const RESET_VALUE : u32 = 8u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt"] pub fn rorris (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt"] pub fn rtris (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt"] pub fn rxris (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt"] pub fn txris (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Masked interrupt status register, SSPMIS on page 3-11"] pub struct SSPMIS (u32) ; impl SSPMIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt"] pub fn rormis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt"] pub fn rtmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt"] pub fn rxmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt"] pub fn txmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt clear register, SSPICR on page 3-11"] pub struct SSPICR (u32) ; impl SSPICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clears the SSPRORINTR interrupt"] pub fn roric (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clears the SSPRORINTR interrupt"] pub fn set_roric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clears the SSPRTINTR interrupt"] pub fn rtic (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clears the SSPRTINTR interrupt"] pub fn set_rtic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register, SSPDMACR on page 3-12"] pub struct SSPDMACR (u32) ; impl SSPDMACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn rxdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn set_rxdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn txdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn set_txdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID0 (u32) ; impl SSPPERIPHID0 { pub const RESET_VALUE : u32 = 34u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x22"] pub fn partnumber0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID1 (u32) ; impl SSPPERIPHID1 { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0"] pub fn partnumber1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits read back as 0x1"] pub fn designer0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID2 (u32) ; impl SSPPERIPHID2 { pub const RESET_VALUE : u32 = 52u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x4"] pub fn designer1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits return the peripheral revision"] pub fn revision (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID3 (u32) ; impl SSPPERIPHID3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x00"] pub fn configuration (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID0 (u32) ; impl SSPPCELLID0 { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0D"] pub fn ssppcellid0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID1 (u32) ; impl SSPPCELLID1 { pub const RESET_VALUE : u32 = 240u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xF0"] pub fn ssppcellid1 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID2 (u32) ; impl SSPPCELLID2 { pub const RESET_VALUE : u32 = 5u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x05"] pub fn ssppcellid2 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID3 (u32) ; impl SSPPCELLID3 { pub const RESET_VALUE : u32 = 177u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xB1"] pub fn ssppcellid3 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod syscfg { # [doc = "Register block for various chip control signals"] pub struct SYSCFG ; impl SYSCFG { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Processor core 0 NMI source mask"] pub struct PROC0_NMI_MASK (u32) ; impl PROC0_NMI_MASK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set a bit high to enable NMI from that IRQ"] pub fn proc0_nmi_mask (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Set a bit high to enable NMI from that IRQ"] pub fn set_proc0_nmi_mask (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Processor core 1 NMI source mask"] pub struct PROC1_NMI_MASK (u32) ; impl PROC1_NMI_MASK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set a bit high to enable NMI from that IRQ"] pub fn proc1_nmi_mask (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Set a bit high to enable NMI from that IRQ"] pub fn set_proc1_nmi_mask (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration for processors"] pub struct PROC_CONFIG (u32) ; impl PROC_CONFIG { pub const RESET_VALUE : u32 = 268435456u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indication that proc0 has halted"] pub fn proc0_halted (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Indication that proc1 has halted"] pub fn proc1_halted (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Configure proc0 DAP instance ID. \n                            Recommend that this is NOT changed until you require debug access in multi-chip environment \n                            WARNING: do not set to 15 as this is reserved for RescueDP"] pub fn proc0_dap_instid (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Configure proc0 DAP instance ID. \n                            Recommend that this is NOT changed until you require debug access in multi-chip environment \n                            WARNING: do not set to 15 as this is reserved for RescueDP"] pub fn set_proc0_dap_instid (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Configure proc1 DAP instance ID. \n                            Recommend that this is NOT changed until you require debug access in multi-chip environment \n                            WARNING: do not set to 15 as this is reserved for RescueDP"] pub fn proc1_dap_instid (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Configure proc1 DAP instance ID. \n                            Recommend that this is NOT changed until you require debug access in multi-chip environment \n                            WARNING: do not set to 15 as this is reserved for RescueDP"] pub fn set_proc1_dap_instid (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "For each bit, if 1, bypass the input synchronizer between that GPIO \n                    and the GPIO input register in the SIO. The input synchronizers should \n                    generally be unbypassed, to avoid injecting metastabilities into processors. \n                    If you're feeling brave, you can bypass to save two cycles of input \n                    latency. This register applies to GPIO 0...29."] pub struct PROC_IN_SYNC_BYPASS (u32) ; impl PROC_IN_SYNC_BYPASS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn proc_in_sync_bypass (& self) -> u32 { (self . 0 >> 0u32) & 1073741823u32 } # [doc = "No description"] pub fn set_proc_in_sync_bypass (& mut self , value : u32) { let value_masked = value & 1073741823u32 ; self . 0 &= ! (1073741823u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "For each bit, if 1, bypass the input synchronizer between that GPIO \n                    and the GPIO input register in the SIO. The input synchronizers should \n                    generally be unbypassed, to avoid injecting metastabilities into processors. \n                    If you're feeling brave, you can bypass to save two cycles of input \n                    latency. This register applies to GPIO 30...35 (the QSPI IOs)."] pub struct PROC_IN_SYNC_BYPASS_HI (u32) ; impl PROC_IN_SYNC_BYPASS_HI { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn proc_in_sync_bypass_hi (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "No description"] pub fn set_proc_in_sync_bypass_hi (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Directly control the SWD debug port of either processor"] pub struct DBGFORCE (u32) ; impl DBGFORCE { pub const RESET_VALUE : u32 = 102u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Observe the value of processor 0 SWDIO output."] pub fn proc0_swdo (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set"] pub fn proc0_swdi (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set"] pub fn set_proc0_swdi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Directly drive processor 0 SWCLK, if PROC0_ATTACH is set"] pub fn proc0_swclk (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Directly drive processor 0 SWCLK, if PROC0_ATTACH is set"] pub fn set_proc0_swclk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads."] pub fn proc0_attach (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads."] pub fn set_proc0_attach (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Observe the value of processor 1 SWDIO output."] pub fn proc1_swdo (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set"] pub fn proc1_swdi (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set"] pub fn set_proc1_swdi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Directly drive processor 1 SWCLK, if PROC1_ATTACH is set"] pub fn proc1_swclk (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Directly drive processor 1 SWCLK, if PROC1_ATTACH is set"] pub fn set_proc1_swclk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads."] pub fn proc1_attach (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads."] pub fn set_proc1_attach (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control power downs to memories. Set high to power down memories. \n                    Use with extreme caution"] pub struct MEMPOWERDOWN (u32) ; impl MEMPOWERDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn sram0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn sram1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn sram2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn sram3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn sram4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn sram5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn usb (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_usb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn rom (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spare_irq { # [doc = "No description"] pub struct SPARE_IRQ ; impl SPARE_IRQ { pub const BASE_ADDR : u64 = 0u64 ; } }

pub mod i2c1 { # [doc = "DW_apb_i2c address block\n\n            List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time):\n\n            IC_ULTRA_FAST_MODE ................ 0x0 \n            IC_UFM_TBUF_CNT_DEFAULT ........... 0x8 \n            IC_UFM_SCL_LOW_COUNT .............. 0x0008 \n            IC_UFM_SCL_HIGH_COUNT ............. 0x0006 \n            IC_TX_TL .......................... 0x0 \n            IC_TX_CMD_BLOCK ................... 0x1 \n            IC_HAS_DMA ........................ 0x1 \n            IC_HAS_ASYNC_FIFO ................. 0x0 \n            IC_SMBUS_ARP ...................... 0x0 \n            IC_FIRST_DATA_BYTE_STATUS ......... 0x1 \n            IC_INTR_IO ........................ 0x1 \n            IC_MASTER_MODE .................... 0x1 \n            IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1 \n            IC_INTR_POL ....................... 0x1 \n            IC_OPTIONAL_SAR ................... 0x0 \n            IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055 \n            IC_DEFAULT_SLAVE_ADDR ............. 0x055 \n            IC_DEFAULT_HS_SPKLEN .............. 0x1 \n            IC_FS_SCL_HIGH_COUNT .............. 0x0006 \n            IC_HS_SCL_LOW_COUNT ............... 0x0008 \n            IC_DEVICE_ID_VALUE ................ 0x0 \n            IC_10BITADDR_MASTER ............... 0x0 \n            IC_CLK_FREQ_OPTIMIZATION .......... 0x0 \n            IC_DEFAULT_FS_SPKLEN .............. 0x7 \n            IC_ADD_ENCODED_PARAMS ............. 0x0 \n            IC_DEFAULT_SDA_HOLD ............... 0x000001 \n            IC_DEFAULT_SDA_SETUP .............. 0x64 \n            IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0 \n            IC_CLOCK_PERIOD ................... 100 \n            IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1 \n            IC_RESTART_EN ..................... 0x1 \n            IC_TX_CMD_BLOCK_DEFAULT ........... 0x0 \n            IC_BUS_CLEAR_FEATURE .............. 0x0 \n            IC_CAP_LOADING .................... 100 \n            IC_FS_SCL_LOW_COUNT ............... 0x000d \n            APB_DATA_WIDTH .................... 32 \n            IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff \n            IC_SLV_DATA_NACK_ONLY ............. 0x1 \n            IC_10BITADDR_SLAVE ................ 0x0 \n            IC_CLK_TYPE ....................... 0x0 \n            IC_SMBUS_UDID_MSB ................. 0x0 \n            IC_SMBUS_SUSPEND_ALERT ............ 0x0 \n            IC_HS_SCL_HIGH_COUNT .............. 0x0006 \n            IC_SLV_RESTART_DET_EN ............. 0x1 \n            IC_SMBUS .......................... 0x0 \n            IC_OPTIONAL_SAR_DEFAULT ........... 0x0 \n            IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0 \n            IC_USE_COUNTS ..................... 0x0 \n            IC_RX_BUFFER_DEPTH ................ 16 \n            IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff \n            IC_RX_FULL_HLD_BUS_EN ............. 0x1 \n            IC_SLAVE_DISABLE .................. 0x1 \n            IC_RX_TL .......................... 0x0 \n            IC_DEVICE_ID ...................... 0x0 \n            IC_HC_COUNT_VALUES ................ 0x0 \n            I2C_DYNAMIC_TAR_UPDATE ............ 0 \n            IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff \n            IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff \n            IC_HS_MASTER_CODE ................. 0x1 \n            IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff \n            IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff \n            IC_SS_SCL_HIGH_COUNT .............. 0x0028 \n            IC_SS_SCL_LOW_COUNT ............... 0x002f \n            IC_MAX_SPEED_MODE ................. 0x2 \n            IC_STAT_FOR_CLK_STRETCH ........... 0x0 \n            IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0 \n            IC_DEFAULT_UFM_SPKLEN ............. 0x1 \n            IC_TX_BUFFER_DEPTH ................ 16"] pub struct I2C1 ; impl I2C1 { pub const BASE_ADDR : u64 = 1074036736u64 ; } # [doc = "I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                    Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only."] pub struct IC_CON (u32) ; impl IC_CON { pub const RESET_VALUE : u32 = 101u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This bit controls whether the DW_apb_i2c master is enabled.\n\n                            NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'."] pub fn master_mode (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This bit controls whether the DW_apb_i2c master is enabled.\n\n                            NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'."] pub fn set_master_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n                            This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n                            1: standard mode (100 kbit/s)\n\n                            2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n                            3: high speed mode (3.4 Mbit/s)\n\n                            Note: This field is not applicable when IC_ULTRA_FAST_MODE=1"] pub fn speed (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode.\n\n                            This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE.\n\n                            1: standard mode (100 kbit/s)\n\n                            2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n                            3: high speed mode (3.4 Mbit/s)\n\n                            Note: This field is not applicable when IC_ULTRA_FAST_MODE=1"] pub fn set_speed (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register."] pub fn ic_10bitaddr_slave (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register."] pub fn set_ic_10bitaddr_slave (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing"] pub fn ic_10bitaddr_master (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing"] pub fn set_ic_10bitaddr_master (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: ENABLED"] pub fn ic_restart_en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: ENABLED"] pub fn set_ic_restart_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n                            If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n                            NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0."] pub fn ic_slave_disable (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled.\n\n                            If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave.\n\n                            NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0."] pub fn set_ic_slave_disable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n                            NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR)."] pub fn stop_det_ifaddressed (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0\n\n                            NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR)."] pub fn set_stop_det_ifaddressed (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0."] pub fn tx_empty_ctrl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0."] pub fn set_tx_empty_ctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n                            Reset value: 0x0."] pub fn rx_fifo_full_hld_ctrl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter.\n\n                            Reset value: 0x0."] pub fn set_rx_fifo_full_hld_ctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Master issues the STOP_DET interrupt irrespective of whether master is active or not"] pub fn stop_det_if_master_active (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Target Address Register\n\n                    This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n\n                    Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only."] pub struct IC_TAR (u32) ; impl IC_TAR { pub const RESET_VALUE : u32 = 85u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n                            If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave."] pub fn ic_tar (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.\n\n                            If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave."] pub fn set_ic_tar (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0"] pub fn gc_or_start (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0"] pub fn set_gc_or_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0"] pub fn special (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0"] pub fn set_special (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Slave Address Register"] pub struct IC_SAR (u32) ; impl IC_SAR { pub const RESET_VALUE : u32 = 85u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values."] pub fn ic_sar (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values."] pub fn set_ic_sar (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n\n                    The size of the register changes as follows:\n\n                    Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging."] pub struct IC_DATA_CMD (u32) ; impl IC_DATA_CMD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n                            Reset value: 0x0"] pub fn dat (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface.\n\n                            Reset value: 0x0"] pub fn set_dat (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n                            When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n                            When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n                            Reset value: 0x0"] pub fn cmd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master.\n\n                            When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n                            When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n                            Reset value: 0x0"] pub fn set_cmd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit controls whether a STOP is issued after the byte is sent or received.\n\n                            - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0"] pub fn stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit controls whether a STOP is issued after the byte is sent or received.\n\n                            - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "This bit controls whether a RESTART is issued before the byte is sent or received.\n\n                            1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            Reset value: 0x0"] pub fn restart (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This bit controls whether a RESTART is issued before the byte is sent or received.\n\n                            1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n                            Reset value: 0x0"] pub fn set_restart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode.\n\n                            Reset value : 0x0\n\n                            NOTE:  In case of APB_DATA_WIDTH=8,\n\n                            1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit.\n\n                            2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not).\n\n                            3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status."] pub fn first_data_byte (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Standard Speed I2C Clock SCL High Count Register"] pub struct IC_SS_SCL_HCNT (u32) ; impl IC_SS_SCL_HCNT { pub const RESET_VALUE : u32 = 40u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n                            NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10."] pub fn ic_ss_scl_hcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.\n\n                            NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10."] pub fn set_ic_ss_scl_hcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Standard Speed I2C Clock SCL Low Count Register"] pub struct IC_SS_SCL_LCNT (u32) ; impl IC_SS_SCL_LCNT { pub const RESET_VALUE : u32 = 47u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed."] pub fn ic_ss_scl_lcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'\n\n                            This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed."] pub fn set_ic_ss_scl_lcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register"] pub struct IC_FS_SCL_HCNT (u32) ; impl IC_FS_SCL_HCNT { pub const RESET_VALUE : u32 = 6u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed."] pub fn ic_fs_scl_hcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed."] pub fn set_ic_fs_scl_hcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register"] pub struct IC_FS_SCL_LCNT (u32) ; impl IC_FS_SCL_LCNT { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8."] pub fn ic_fs_scl_lcnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'.\n\n                            This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n                            This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n                            The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8."] pub fn set_ic_fs_scl_lcnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Interrupt Status Register\n\n                    Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register."] pub struct IC_INTR_STAT (u32) ; impl IC_INTR_STAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n                            Reset value: 0x0"] pub fn r_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n                            Reset value: 0x0"] pub fn r_rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n                            Reset value: 0x0"] pub fn r_rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n                            Reset value: 0x0"] pub fn r_tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n                            Reset value: 0x0"] pub fn r_tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n                            Reset value: 0x0"] pub fn r_rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n                            Reset value: 0x0"] pub fn r_tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n                            Reset value: 0x0"] pub fn r_rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n                            Reset value: 0x0"] pub fn r_activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n                            Reset value: 0x0"] pub fn r_stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n                            Reset value: 0x0"] pub fn r_start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n                            Reset value: 0x0"] pub fn r_gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n                            Reset value: 0x0"] pub fn r_restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Interrupt Mask Register.\n\n                    These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt."] pub struct IC_INTR_MASK (u32) ; impl IC_INTR_MASK { pub const RESET_VALUE : u32 = 2303u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_under (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_over (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_full (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_over (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_empty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rd_req (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_tx_abrt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_rx_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_activity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_stop_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_start_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn m_gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x1"] pub fn set_m_gen_call (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn m_restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn set_m_restart_det (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Raw Interrupt Status Register\n\n                    Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c."] pub struct IC_RAW_INTR_STAT (u32) ; impl IC_RAW_INTR_STAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Reset value: 0x0"] pub fn rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Note:  If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows.\n\n                            Reset value: 0x0"] pub fn rx_over (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.\n\n                            Reset value: 0x0"] pub fn rx_full (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n                            Reset value: 0x0"] pub fn tx_over (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.\n\n                            Reset value: 0x0."] pub fn tx_empty (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.\n\n                            Reset value: 0x0"] pub fn rd_req (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.\n\n                            Note:  The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface.\n\n                            Reset value: 0x0"] pub fn tx_abrt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.\n\n                            Reset value: 0x0"] pub fn rx_done (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.\n\n                            Reset value: 0x0"] pub fn activity (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n                            In Slave Mode: - If IC_CON[7]=1'b1  (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1  (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0  (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0"] pub fn stop_det (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n                            Reset value: 0x0"] pub fn start_det (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.\n\n                            Reset value: 0x0"] pub fn gen_call (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n                            Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n                            Reset value: 0x0"] pub fn restart_det (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive FIFO Threshold Register"] pub struct IC_RX_TL (u32) ; impl IC_RX_TL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO Threshold Level.\n\n                            Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries."] pub fn rx_tl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive FIFO Threshold Level.\n\n                            Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries."] pub fn set_rx_tl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit FIFO Threshold Register"] pub struct IC_TX_TL (u32) ; impl IC_TX_TL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO Threshold Level.\n\n                            Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries."] pub fn tx_tl (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Transmit FIFO Threshold Level.\n\n                            Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries."] pub fn set_tx_tl (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear Combined and Individual Interrupt Register"] pub struct IC_CLR_INTR (u32) ; impl IC_CLR_INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n                            Reset value: 0x0"] pub fn clr_intr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_UNDER Interrupt Register"] pub struct IC_CLR_RX_UNDER (u32) ; impl IC_CLR_RX_UNDER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_under (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_OVER Interrupt Register"] pub struct IC_CLR_RX_OVER (u32) ; impl IC_CLR_RX_OVER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_over (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear TX_OVER Interrupt Register"] pub struct IC_CLR_TX_OVER (u32) ; impl IC_CLR_TX_OVER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_tx_over (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RD_REQ Interrupt Register"] pub struct IC_CLR_RD_REQ (u32) ; impl IC_CLR_RD_REQ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rd_req (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear TX_ABRT Interrupt Register"] pub struct IC_CLR_TX_ABRT (u32) ; impl IC_CLR_TX_ABRT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n                            Reset value: 0x0"] pub fn clr_tx_abrt (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RX_DONE Interrupt Register"] pub struct IC_CLR_RX_DONE (u32) ; impl IC_CLR_RX_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_rx_done (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear ACTIVITY Interrupt Register"] pub struct IC_CLR_ACTIVITY (u32) ; impl IC_CLR_ACTIVITY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_activity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear STOP_DET Interrupt Register"] pub struct IC_CLR_STOP_DET (u32) ; impl IC_CLR_STOP_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_stop_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear START_DET Interrupt Register"] pub struct IC_CLR_START_DET (u32) ; impl IC_CLR_START_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_start_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear GEN_CALL Interrupt Register"] pub struct IC_CLR_GEN_CALL (u32) ; impl IC_CLR_GEN_CALL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_gen_call (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Enable Register"] pub struct IC_ENABLE (u32) ; impl IC_ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n                            When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n                            In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n                            Reset value: 0x0"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'.\n\n                            When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer.\n\n                            In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c'\n\n                            Reset value: 0x0"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n                            For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n                            Reset value: 0x0"] pub fn abort (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.\n\n                            For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'.\n\n                            Reset value: 0x0"] pub fn set_abort (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT"] pub fn tx_cmd_block (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:  IC_TX_CMD_BLOCK_DEFAULT"] pub fn set_tx_cmd_block (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Status Register\n\n                    This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n\n                    When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0"] pub struct IC_STATUS (u32) ; impl IC_STATUS { pub const RESET_VALUE : u32 = 6u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2C Activity Status. Reset value: 0x0"] pub fn activity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1"] pub fn tfnf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1"] pub fn tfe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0"] pub fn rfne (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0"] pub fn rff (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n                            Reset value: 0x0"] pub fn mst_activity (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0"] pub fn slv_activity (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO."] pub struct IC_TXFLR (u32) ; impl IC_TXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO.\n\n                            Reset value: 0x0"] pub fn txflr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO."] pub struct IC_RXFLR (u32) ; impl IC_RXFLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive FIFO Level. Contains the number of valid data entries in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn rxflr (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SDA Hold Time Length Register\n\n                    The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n                    The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n\n                    Writes to this register succeed only when IC_ENABLE[0]=0.\n\n                    The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented.\n\n                    The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles."] pub struct IC_SDA_HOLD (u32) ; impl IC_SDA_HOLD { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[15:0]."] pub fn ic_sda_tx_hold (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[15:0]."] pub fn set_ic_sda_tx_hold (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[23:16]."] pub fn ic_sda_rx_hold (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver.\n\n                            Reset value: IC_DEFAULT_SDA_HOLD[23:16]."] pub fn set_ic_sda_rx_hold (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Transmit Abort Source Register\n\n                    This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n                    Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted."] pub struct IC_TX_ABRT_SOURCE (u32) ; impl IC_TX_ABRT_SOURCE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_7b_addr_noack (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_10addr1_noack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_10addr2_noack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_txdata_noack (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_gcall_noack (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_gcall_read (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_hs_ackdet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_sbyte_ackdet (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_hs_norstrt (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master"] pub fn abrt_sbyte_norstrt (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Receiver"] pub fn abrt_10b_rd_norstrt (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "This field indicates that the User tries to initiate a Master operation with the Master mode disabled.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Master-Receiver"] pub fn abrt_master_dis (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter"] pub fn arb_lost (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slvflush_txfifo (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note:  Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slv_arblost (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Slave-Transmitter"] pub fn abrt_slvrd_intx (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1])\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter"] pub fn abrt_user_abrt (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n                            Reset value: 0x0\n\n                            Role of DW_apb_i2c:  Master-Transmitter or Slave-Transmitter"] pub fn tx_flush_cnt (& self) -> u32 { (self . 0 >> 23u32) & 511u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Generate Slave Data NACK Register\n\n                    The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n\n                    A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit."] pub struct IC_SLV_DATA_NACK_ONLY (u32) ; impl IC_SLV_DATA_NACK_ONLY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n                            When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0"] pub fn nack (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer.\n\n                            When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0"] pub fn set_nack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Control Register\n\n                    The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE."] pub struct IC_DMA_CR (u32) ; impl IC_DMA_CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0"] pub fn rdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0"] pub fn set_rdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0"] pub fn tdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0"] pub fn set_tdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Transmit Data Level Register"] pub struct IC_DMA_TDLR (u32) ; impl IC_DMA_TDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n                            Reset value: 0x0"] pub fn dmatdl (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n                            Reset value: 0x0"] pub fn set_dmatdl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Receive Data Level Register"] pub struct IC_DMA_RDLR (u32) ; impl IC_DMA_RDLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn dmardl (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.\n\n                            Reset value: 0x0"] pub fn set_dmardl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SDA Setup Register\n\n                    This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n\n                    Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n                    Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter."] pub struct IC_SDA_SETUP (u32) ; impl IC_SDA_SETUP { pub const RESET_VALUE : u32 = 100u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2."] pub fn sda_setup (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2."] pub fn set_sda_setup (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C ACK General Call Register\n\n                    The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n\n                    This register is applicable only when the DW_apb_i2c is in slave mode."] pub struct IC_ACK_GENERAL_CALL (u32) ; impl IC_ACK_GENERAL_CALL { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe)."] pub fn ack_gen_call (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe)."] pub fn set_ack_gen_call (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Enable Status Register\n\n                    The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n\n                    If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n\n                    If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n                    Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities."] pub struct IC_ENABLE_STATUS (u32) ; impl IC_ENABLE_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:  The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n                            Reset value: 0x0"] pub fn ic_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:\n\n                            (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master;\n\n                            OR,\n\n                            (b) address and data bytes of the Slave-Receiver operation from a remote master.\n\n                            When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.\n\n                            Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1.\n\n                            When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle.\n\n                            Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n                            Reset value: 0x0"] pub fn slv_disabled_while_busy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.\n\n                            Note:  If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1.\n\n                            When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.\n\n                            Note:  The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n                            Reset value: 0x0"] pub fn slv_rx_data_lost (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C SS, FS or FM+ spike suppression limit\n\n                    This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1."] pub struct IC_FS_SPKLEN (u32) ; impl IC_FS_SPKLEN { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'."] pub fn ic_fs_spklen (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'."] pub fn set_ic_fs_spklen (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RESTART_DET Interrupt Register"] pub struct IC_CLR_RESTART_DET (u32) ; impl IC_CLR_RESTART_DET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register.\n\n                            Reset value: 0x0"] pub fn clr_restart_det (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Component Parameter Register 1\n\n                    Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters"] pub struct IC_COMP_PARAM_1 (u32) ; impl IC_COMP_PARAM_1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "APB data bus width is 32 bits"] pub fn apb_data_width (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "MAX SPEED MODE = FAST MODE"] pub fn max_speed_mode (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Programmable count values for each mode."] pub fn hc_count_values (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "COMBINED Interrupt outputs"] pub fn intr_io (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "DMA handshaking signals are enabled"] pub fn has_dma (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Encoded parameters not visible"] pub fn add_encoded_params (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "RX Buffer Depth = 16"] pub fn rx_buffer_depth (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "TX Buffer Depth = 16"] pub fn tx_buffer_depth (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Component Version Register"] pub struct IC_COMP_VERSION (u32) ; impl IC_COMP_VERSION { pub const RESET_VALUE : u32 = 842019114u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ic_comp_version (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2C Component Type Register"] pub struct IC_COMP_TYPE (u32) ; impl IC_COMP_TYPE { pub const RESET_VALUE : u32 = 1146552640u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number."] pub fn ic_comp_type (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi0 { # [doc = "No description"] pub struct SPI0 ; impl SPI0 { pub const BASE_ADDR : u64 = 1073987584u64 ; } # [doc = "Control register 0, SSPCR0 on page 3-4"] pub struct SSPCR0 (u32) ; impl SSPCR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data."] pub fn dss (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data."] pub fn set_dss (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation."] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation."] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn spo (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn set_spo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn sph (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10."] pub fn set_sph (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255."] pub fn scr (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255."] pub fn set_scr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 1, SSPCR1 on page 3-5"] pub struct SSPCR1 (u32) ; impl SSPCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally."] pub fn lbm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally."] pub fn set_lbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled."] pub fn sse (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled."] pub fn set_sse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave."] pub fn ms (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave."] pub fn set_ms (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode."] pub fn sod (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode."] pub fn set_sod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register, SSPDR on page 3-6"] pub struct SSPDR (u32) ; impl SSPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies."] pub fn data (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies."] pub fn set_data (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register, SSPSR on page 3-7"] pub struct SSPSR (u32) ; impl SSPSR { pub const RESET_VALUE : u32 = 3u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty."] pub fn tfe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full."] pub fn tnf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty."] pub fn rne (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full."] pub fn rff (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty."] pub fn bsy (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock prescale register, SSPCPSR on page 3-8"] pub struct SSPCPSR (u32) ; impl SSPCPSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads."] pub fn cpsdvsr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads."] pub fn set_cpsdvsr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt mask set or clear register, SSPIMSC on page 3-9"] pub struct SSPIMSC (u32) ; impl SSPIMSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked."] pub fn rorim (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked."] pub fn set_rorim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked."] pub fn rtim (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked."] pub fn set_rtim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked."] pub fn rxim (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked."] pub fn set_rxim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked."] pub fn txim (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked."] pub fn set_txim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw interrupt status register, SSPRIS on page 3-10"] pub struct SSPRIS (u32) ; impl SSPRIS { pub const RESET_VALUE : u32 = 8u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt"] pub fn rorris (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt"] pub fn rtris (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt"] pub fn rxris (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt"] pub fn txris (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Masked interrupt status register, SSPMIS on page 3-11"] pub struct SSPMIS (u32) ; impl SSPMIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt"] pub fn rormis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt"] pub fn rtmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt"] pub fn rxmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt"] pub fn txmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt clear register, SSPICR on page 3-11"] pub struct SSPICR (u32) ; impl SSPICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clears the SSPRORINTR interrupt"] pub fn roric (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clears the SSPRORINTR interrupt"] pub fn set_roric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clears the SSPRTINTR interrupt"] pub fn rtic (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clears the SSPRTINTR interrupt"] pub fn set_rtic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register, SSPDMACR on page 3-12"] pub struct SSPDMACR (u32) ; impl SSPDMACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn rxdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn set_rxdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn txdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn set_txdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID0 (u32) ; impl SSPPERIPHID0 { pub const RESET_VALUE : u32 = 34u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x22"] pub fn partnumber0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID1 (u32) ; impl SSPPERIPHID1 { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0"] pub fn partnumber1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits read back as 0x1"] pub fn designer0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID2 (u32) ; impl SSPPERIPHID2 { pub const RESET_VALUE : u32 = 52u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x4"] pub fn designer1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits return the peripheral revision"] pub fn revision (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral identification registers, SSPPeriphID0-3 on page 3-13"] pub struct SSPPERIPHID3 (u32) ; impl SSPPERIPHID3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x00"] pub fn configuration (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID0 (u32) ; impl SSPPCELLID0 { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0D"] pub fn ssppcellid0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID1 (u32) ; impl SSPPCELLID1 { pub const RESET_VALUE : u32 = 240u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xF0"] pub fn ssppcellid1 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID2 (u32) ; impl SSPPCELLID2 { pub const RESET_VALUE : u32 = 5u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x05"] pub fn ssppcellid2 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PrimeCell identification registers, SSPPCellID0-3 on page 3-16"] pub struct SSPPCELLID3 (u32) ; impl SSPPCELLID3 { pub const RESET_VALUE : u32 = 177u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xB1"] pub fn ssppcellid3 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod resets { # [doc = "No description"] pub struct RESETS ; impl RESETS { pub const BASE_ADDR : u64 = 1073790976u64 ; } # [doc = "Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted."] pub struct RESET (u32) ; impl RESET { pub const RESET_VALUE : u32 = 33554431u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn adc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn busctrl (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_busctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn dma (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_dma (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn i2c0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_i2c0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn i2c1 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_i2c1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn io_bank0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_io_bank0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn io_qspi (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_io_qspi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn jtag (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_jtag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn pads_bank0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_pads_bank0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn pads_qspi (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_pads_qspi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn pio0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_pio0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn pio1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_pio1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn pll_sys (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_pll_sys (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn pll_usb (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_pll_usb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn pwm (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_pwm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn spi0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn spi1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn syscfg (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_syscfg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn sysinfo (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_sysinfo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn tbman (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_tbman (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn timer (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_timer (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn uart0 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn uart1 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn usbctrl (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires."] pub struct WDSEL (u32) ; impl WDSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn adc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn busctrl (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_busctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn dma (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_dma (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn i2c0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_i2c0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn i2c1 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_i2c1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn io_bank0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_io_bank0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn io_qspi (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_io_qspi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn jtag (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_jtag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn pads_bank0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_pads_bank0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn pads_qspi (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_pads_qspi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn pio0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_pio0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn pio1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_pio1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn pll_sys (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_pll_sys (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn pll_usb (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_pll_usb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn pwm (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_pwm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn spi0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn spi1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn syscfg (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_syscfg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn sysinfo (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_sysinfo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn tbman (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_tbman (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn timer (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_timer (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn uart0 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn uart1 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn usbctrl (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed."] pub struct RESET_DONE (u32) ; impl RESET_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn adc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn busctrl (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn dma (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn i2c0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn i2c1 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn io_bank0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn io_qspi (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn jtag (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn pads_bank0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn pads_qspi (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn pio0 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn pio1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn pll_sys (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn pll_usb (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn pwm (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn rtc (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn spi0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn spi1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn syscfg (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn sysinfo (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn tbman (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn timer (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn uart0 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn uart1 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn usbctrl (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rosc { # [doc = "No description"] pub struct ROSC ; impl ROSC { pub const BASE_ADDR : u64 = 1074135040u64 ; } # [doc = "Ring Oscillator control"] pub struct CTRL (u32) ; impl CTRL { pub const RESET_VALUE : u32 = 2720u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Controls the number of delay stages in the ROSC ring \n                            LOW uses stages 0 to 7 \n                            MEDIUM uses stages 2 to 7 \n                            HIGH uses stages 4 to 7 \n                            TOOHIGH uses stages 6 to 7 and should not be used because its frequency exceeds design specifications \n                            The clock output will not glitch when changing the range up one step at a time \n                            The clock output will glitch when changing the range down \n                            Note: the values here are gray coded which is why HIGH comes before TOOHIGH"] pub fn freq_range (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Controls the number of delay stages in the ROSC ring \n                            LOW uses stages 0 to 7 \n                            MEDIUM uses stages 2 to 7 \n                            HIGH uses stages 4 to 7 \n                            TOOHIGH uses stages 6 to 7 and should not be used because its frequency exceeds design specifications \n                            The clock output will not glitch when changing the range up one step at a time \n                            The clock output will glitch when changing the range down \n                            Note: the values here are gray coded which is why HIGH comes before TOOHIGH"] pub fn set_freq_range (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "On power-up this field is initialised to ENABLE \n                            The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up \n                            The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator."] pub fn enable (& self) -> u32 { (self . 0 >> 12u32) & 4095u32 } # [doc = "On power-up this field is initialised to ENABLE \n                            The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up \n                            The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage \n                    The drive strength has 4 levels determined by the number of bits set \n                    Increasing the number of bits set increases the drive strength and increases the oscillation frequency \n                    0 bits set is the default drive strength \n                    1 bit set doubles the drive strength \n                    2 bits set triples drive strength \n                    3 bits set quadruples drive strength"] pub struct FREQA (u32) ; impl FREQA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stage 0 drive strength"] pub fn ds0 (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Stage 0 drive strength"] pub fn set_ds0 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stage 1 drive strength"] pub fn ds1 (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Stage 1 drive strength"] pub fn set_ds1 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stage 2 drive strength"] pub fn ds2 (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Stage 2 drive strength"] pub fn set_ds2 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stage 3 drive strength"] pub fn ds3 (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Stage 3 drive strength"] pub fn set_ds3 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set to 0x9696 to apply the settings \n                            Any other value in this field will set all drive strengths to 0"] pub fn passwd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Set to 0x9696 to apply the settings \n                            Any other value in this field will set all drive strengths to 0"] pub fn set_passwd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "For a detailed description see freqa register"] pub struct FREQB (u32) ; impl FREQB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stage 4 drive strength"] pub fn ds4 (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Stage 4 drive strength"] pub fn set_ds4 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stage 5 drive strength"] pub fn ds5 (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Stage 5 drive strength"] pub fn set_ds5 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stage 6 drive strength"] pub fn ds6 (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Stage 6 drive strength"] pub fn set_ds6 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stage 7 drive strength"] pub fn ds7 (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Stage 7 drive strength"] pub fn set_ds7 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set to 0x9696 to apply the settings \n                            Any other value in this field will set all drive strengths to 0"] pub fn passwd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Set to 0x9696 to apply the settings \n                            Any other value in this field will set all drive strengths to 0"] pub fn set_passwd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Ring Oscillator pause control"] pub struct DORMANT (u32) ; impl DORMANT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This is used to save power by pausing the ROSC \n                            On power-up this field is initialised to WAKE \n                            An invalid write will also select WAKE \n                            Warning: setup the irq before selecting dormant mode"] pub fn dormant (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "This is used to save power by pausing the ROSC \n                            On power-up this field is initialised to WAKE \n                            An invalid write will also select WAKE \n                            Warning: setup the irq before selecting dormant mode"] pub fn set_dormant (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the output divider"] pub struct DIV (u32) ; impl DIV { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "set to 0xaa0 + div where \n                            div = 0 divides by 32 \n                            div = 1-31 divides by div \n                            any other value sets div=31 \n                            this register resets to div=16"] pub fn div (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "set to 0xaa0 + div where \n                            div = 0 divides by 32 \n                            div = 1-31 divides by div \n                            any other value sets div=31 \n                            this register resets to div=16"] pub fn set_div (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls the phase shifted output"] pub struct PHASE (u32) ; impl PHASE { pub const RESET_VALUE : u32 = 8u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "phase shift the phase-shifted output by SHIFT input clocks \n                            this can be changed on-the-fly \n                            must be set to 0 before setting div=1"] pub fn shift (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "phase shift the phase-shifted output by SHIFT input clocks \n                            this can be changed on-the-fly \n                            must be set to 0 before setting div=1"] pub fn set_shift (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "invert the phase-shifted output \n                            this is ignored when div=1"] pub fn flip (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "invert the phase-shifted output \n                            this is ignored when div=1"] pub fn set_flip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "enable the phase-shifted output \n                            this can be changed on-the-fly"] pub fn enable (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "enable the phase-shifted output \n                            this can be changed on-the-fly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "set to 0xaa \n                            any other value enables the output with shift=0"] pub fn passwd (& self) -> u32 { (self . 0 >> 4u32) & 255u32 } # [doc = "set to 0xaa \n                            any other value enables the output with shift=0"] pub fn set_passwd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Ring Oscillator Status"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Oscillator is enabled but not necessarily running and stable \n                            this resets to 0 but transitions to 1 during chip startup"] pub fn enabled (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "post-divider is running \n                            this resets to 0 but transitions to 1 during chip startup"] pub fn div_running (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT"] pub fn badwrite (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT"] pub fn set_badwrite (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Oscillator is running and stable"] pub fn stable (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency"] pub struct RANDOMBIT (u32) ; impl RANDOMBIT { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn randombit (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "A down counter running at the ROSC frequency which counts to zero and stops. \n                    To start the counter write a non-zero value. \n                    Can be used for short software pauses when setting up time sensitive hardware."] pub struct COUNT (u32) ; impl COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn count (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_count (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod usb { # [doc = "USB FS/LS controller device registers"] pub struct USB ; impl USB { pub const BASE_ADDR : u64 = 1343291392u64 ; } # [doc = "Device address and endpoint control"] pub struct ADDR_ENDP (u32) ; impl ADDR_ENDP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with."] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with."] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Device endpoint to send data to. Only valid for HOST mode."] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Device endpoint to send data to. Only valid for HOST mode."] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 1. Only valid for HOST mode."] pub struct ADDR_ENDP1 (u32) ; impl ADDR_ENDP1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 2. Only valid for HOST mode."] pub struct ADDR_ENDP2 (u32) ; impl ADDR_ENDP2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 3. Only valid for HOST mode."] pub struct ADDR_ENDP3 (u32) ; impl ADDR_ENDP3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 4. Only valid for HOST mode."] pub struct ADDR_ENDP4 (u32) ; impl ADDR_ENDP4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 5. Only valid for HOST mode."] pub struct ADDR_ENDP5 (u32) ; impl ADDR_ENDP5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 6. Only valid for HOST mode."] pub struct ADDR_ENDP6 (u32) ; impl ADDR_ENDP6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 7. Only valid for HOST mode."] pub struct ADDR_ENDP7 (u32) ; impl ADDR_ENDP7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 8. Only valid for HOST mode."] pub struct ADDR_ENDP8 (u32) ; impl ADDR_ENDP8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 9. Only valid for HOST mode."] pub struct ADDR_ENDP9 (u32) ; impl ADDR_ENDP9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 10. Only valid for HOST mode."] pub struct ADDR_ENDP10 (u32) ; impl ADDR_ENDP10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 11. Only valid for HOST mode."] pub struct ADDR_ENDP11 (u32) ; impl ADDR_ENDP11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 12. Only valid for HOST mode."] pub struct ADDR_ENDP12 (u32) ; impl ADDR_ENDP12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 13. Only valid for HOST mode."] pub struct ADDR_ENDP13 (u32) ; impl ADDR_ENDP13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 14. Only valid for HOST mode."] pub struct ADDR_ENDP14 (u32) ; impl ADDR_ENDP14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt endpoint 15. Only valid for HOST mode."] pub struct ADDR_ENDP15 (u32) ; impl ADDR_ENDP15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Device address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number of the interrupt endpoint"] pub fn endpoint (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Endpoint number of the interrupt endpoint"] pub fn set_endpoint (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn intep_dir (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direction of the interrupt endpoint. In=0, Out=1"] pub fn set_intep_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn intep_preamble (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Interrupt EP requires preamble (is a low speed device on a full speed hub)"] pub fn set_intep_preamble (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Main control register"] pub struct MAIN_CTRL (u32) ; impl MAIN_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable controller"] pub fn controller_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable controller"] pub fn set_controller_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Device mode = 0, Host mode = 1"] pub fn host_ndevice (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Device mode = 0, Host mode = 1"] pub fn set_host_ndevice (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Reduced timings for simulation"] pub fn sim_timing (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Reduced timings for simulation"] pub fn set_sim_timing (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time."] pub struct SOF_WR (u32) ; impl SOF_WR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn count (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "No description"] pub fn set_count (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host."] pub struct SOF_RD (u32) ; impl SOF_RD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn count (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SIE control register"] pub struct SIE_CTRL (u32) ; impl SIE_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: Start transaction"] pub fn start_trans (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Host: Start transaction"] pub fn set_start_trans (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Host: Send Setup packet"] pub fn send_setup (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Host: Send Setup packet"] pub fn set_send_setup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Host: Send transaction (OUT from host)"] pub fn send_data (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Host: Send transaction (OUT from host)"] pub fn set_send_data (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Host: Receive transaction (IN to host)"] pub fn receive_data (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Host: Receive transaction (IN to host)"] pub fn set_receive_data (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Host: Stop transaction"] pub fn stop_trans (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Host: Stop transaction"] pub fn set_stop_trans (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Host: Preable enable for LS device on FS hub"] pub fn preamble_en (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Host: Preable enable for LS device on FS hub"] pub fn set_preamble_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Host: Delay packet(s) until after SOF"] pub fn sof_sync (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Host: Delay packet(s) until after SOF"] pub fn set_sof_sync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Host: Enable SOF generation (for full speed bus)"] pub fn sof_en (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Host: Enable SOF generation (for full speed bus)"] pub fn set_sof_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Host: Enable keep alive packet (for low speed bus)"] pub fn keep_alive_en (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Host: Enable keep alive packet (for low speed bus)"] pub fn set_keep_alive_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Host: Enable VBUS"] pub fn vbus_en (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Host: Enable VBUS"] pub fn set_vbus_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Device: Remote wakeup. Device can initiate its own resume after suspend."] pub fn resume (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Device: Remote wakeup. Device can initiate its own resume after suspend."] pub fn set_resume (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Host: Reset bus"] pub fn reset_bus (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Host: Reset bus"] pub fn set_reset_bus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Host: Enable pull down resistors"] pub fn pulldown_en (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Host: Enable pull down resistors"] pub fn set_pulldown_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Device: Enable pull up resistor"] pub fn pullup_en (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Device: Enable pull up resistor"] pub fn set_pullup_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Device: Pull-up strength (0=1K2, 1=2k3)"] pub fn rpu_opt (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Device: Pull-up strength (0=1K2, 1=2k3)"] pub fn set_rpu_opt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Power down bus transceiver"] pub fn transceiver_pd (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Power down bus transceiver"] pub fn set_transceiver_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Direct control of DM"] pub fn direct_dm (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Direct control of DM"] pub fn set_direct_dm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Direct control of DP"] pub fn direct_dp (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Direct control of DP"] pub fn set_direct_dp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Direct bus drive enable"] pub fn direct_en (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Direct bus drive enable"] pub fn set_direct_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK"] pub fn ep0_int_nak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK"] pub fn set_ep0_int_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0"] pub fn ep0_int_2buf (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0"] pub fn set_ep0_int_2buf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Device: Set bit in BUFF_STATUS for every buffer completed on EP0"] pub fn ep0_int_1buf (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Device: Set bit in BUFF_STATUS for every buffer completed on EP0"] pub fn set_ep0_int_1buf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Device: EP0 single buffered = 0, double buffered = 1"] pub fn ep0_double_buf (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Device: EP0 single buffered = 0, double buffered = 1"] pub fn set_ep0_double_buf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL"] pub fn ep0_int_stall (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL"] pub fn set_ep0_int_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SIE status register"] pub struct SIE_STATUS (u32) ; impl SIE_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device: VBUS Detected"] pub fn vbus_detected (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "USB bus line state"] pub fn line_state (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Bus in suspended state. Valid for device and host. Host and device will go into suspend if neither Keep Alive / SOF frames are enabled."] pub fn suspended (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Host: device speed. Disconnected = 00, LS = 01, FS = 10"] pub fn speed (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "VBUS over current detected"] pub fn vbus_over_curr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Host: Device has initiated a remote resume. Device: host has initiated a resume."] pub fn resume (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Host: Device has initiated a remote resume. Device: host has initiated a resume."] pub fn set_resume (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Device: connected"] pub fn connected (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Device: Setup packet received"] pub fn setup_rec (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Device: Setup packet received"] pub fn set_setup_rec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Transaction complete.\n\n                            Raised by device if:\n\n                            * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register\n\n                            Raised by host if:\n\n                            * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set"] pub fn trans_complete (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Transaction complete.\n\n                            Raised by device if:\n\n                            * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register\n\n                            Raised by host if:\n\n                            * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set"] pub fn set_trans_complete (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Device: bus reset received"] pub fn bus_reset (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Device: bus reset received"] pub fn set_bus_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "CRC Error. Raised by the Serial RX engine."] pub fn crc_error (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "CRC Error. Raised by the Serial RX engine."] pub fn set_crc_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Bit Stuff Error. Raised by the Serial RX engine."] pub fn bit_stuff_error (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Bit Stuff Error. Raised by the Serial RX engine."] pub fn set_bit_stuff_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "RX overflow is raised by the Serial RX engine if the incoming data is too fast."] pub fn rx_overflow (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "RX overflow is raised by the Serial RX engine if the incoming data is too fast."] pub fn set_rx_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec."] pub fn rx_timeout (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec."] pub fn set_rx_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Host: NAK received"] pub fn nak_rec (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Host: NAK received"] pub fn set_nak_rec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Host: STALL received"] pub fn stall_rec (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Host: STALL received"] pub fn set_stall_rec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "ACK received. Raised by both host and device."] pub fn ack_rec (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "ACK received. Raised by both host and device."] pub fn set_ack_rec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Data Sequence Error.\n\n                            The device can raise a sequence error in the following conditions:\n\n                            * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM\n\n                            The host can raise a data sequence error in the following conditions:\n\n                            * An IN packet from the device has the wrong data PID"] pub fn data_seq_error (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Data Sequence Error.\n\n                            The device can raise a sequence error in the following conditions:\n\n                            * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM\n\n                            The host can raise a data sequence error in the following conditions:\n\n                            * An IN packet from the device has the wrong data PID"] pub fn set_data_seq_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "interrupt endpoint control register"] pub struct INT_EP_CTRL (u32) ; impl INT_EP_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: Enable interrupt endpoint 1 => 15"] pub fn int_ep_active (& self) -> u32 { (self . 0 >> 1u32) & 32767u32 } # [doc = "Host: Enable interrupt endpoint 1 => 15"] pub fn set_int_ep_active (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle."] pub struct BUFF_STATUS (u32) ; impl BUFF_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ep1_in (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ep1_out (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ep2_in (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ep2_out (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ep3_in (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ep3_out (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn ep4_in (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn ep4_out (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn ep5_in (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn ep5_out (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn ep6_in (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn ep6_out (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn ep7_in (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn ep7_out (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn ep8_in (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn ep8_out (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn ep9_in (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn ep9_out (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn ep10_in (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn ep10_out (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn ep11_in (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn ep11_out (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn ep12_in (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn ep12_out (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn ep13_in (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn ep13_out (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn ep14_in (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn ep14_out (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn ep15_in (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn ep15_out (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered."] pub struct BUFF_CPU_SHOULD_HANDLE (u32) ; impl BUFF_CPU_SHOULD_HANDLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn ep1_in (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn ep1_out (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn ep2_in (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn ep2_out (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn ep3_in (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn ep3_out (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn ep4_in (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn ep4_out (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn ep5_in (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn ep5_out (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn ep6_in (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn ep6_out (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn ep7_in (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn ep7_out (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn ep8_in (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn ep8_out (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn ep9_in (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn ep9_out (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn ep10_in (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn ep10_out (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn ep11_in (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn ep11_out (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn ep12_in (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn ep12_out (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn ep13_in (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn ep13_out (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn ep14_in (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn ep14_out (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn ep15_in (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn ep15_out (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register."] pub struct EP_ABORT (u32) ; impl EP_ABORT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ep1_in (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ep1_out (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ep2_in (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ep2_out (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ep3_in (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ep3_out (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn ep4_in (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn ep4_out (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn ep5_in (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn ep5_out (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn ep6_in (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn ep6_out (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn ep7_in (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn ep7_out (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn ep8_in (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn ep8_out (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn ep9_in (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn ep9_out (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn ep10_in (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn ep10_out (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn ep11_in (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn ep11_out (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn ep12_in (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn ep12_out (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn ep13_in (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn ep13_out (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn ep14_in (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn ep14_out (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn ep15_in (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn ep15_out (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register."] pub struct EP_ABORT_DONE (u32) ; impl EP_ABORT_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ep1_in (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ep1_out (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ep2_in (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ep2_out (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ep3_in (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ep3_out (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn ep4_in (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn ep4_out (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn ep5_in (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn ep5_out (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn ep6_in (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn ep6_out (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn ep7_in (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn ep7_out (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn ep8_in (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn ep8_out (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn ep9_in (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn ep9_out (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn ep10_in (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn ep10_out (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn ep11_in (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn ep11_out (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn ep12_in (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn ep12_out (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn ep13_in (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn ep13_out (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn ep14_in (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn ep14_out (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn ep15_in (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn ep15_out (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received."] pub struct EP_STALL_ARM (u32) ; impl EP_STALL_ARM { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK."] pub struct NAK_POLL (u32) ; impl NAK_POLL { pub const RESET_VALUE : u32 = 1048592u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "NAK polling interval for a low speed device"] pub fn delay_ls (& self) -> u32 { (self . 0 >> 0u32) & 1023u32 } # [doc = "NAK polling interval for a low speed device"] pub fn set_delay_ls (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NAK polling interval for a full speed device"] pub fn delay_fs (& self) -> u32 { (self . 0 >> 16u32) & 1023u32 } # [doc = "NAK polling interval for a full speed device"] pub fn set_delay_fs (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register."] pub struct EP_STATUS_STALL_NAK (u32) ; impl EP_STATUS_STALL_NAK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn ep0_in (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn ep0_out (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_ep0_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn ep1_in (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn ep1_out (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_ep1_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn ep2_in (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn ep2_out (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_ep2_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn ep3_in (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn ep3_out (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_ep3_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn ep4_in (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn ep4_out (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_ep4_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn ep5_in (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn ep5_out (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_ep5_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn ep6_in (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn ep6_out (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_ep6_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn ep7_in (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn ep7_out (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_ep7_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn ep8_in (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn ep8_out (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_ep8_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn ep9_in (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn ep9_out (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_ep9_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn ep10_in (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn ep10_out (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_ep10_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn ep11_in (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn ep11_out (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_ep11_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn ep12_in (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn ep12_out (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_ep12_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn ep13_in (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn ep13_out (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_ep13_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn ep14_in (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn ep14_out (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_ep14_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn ep15_in (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_in (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn ep15_out (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_ep15_out (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Where to connect the USB controller. Should be to_phy by default."] pub struct USB_MUXING (u32) ; impl USB_MUXING { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn to_phy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_to_phy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn to_extphy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_to_extphy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn to_digital_pad (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_to_digital_pad (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn softcon (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_softcon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable so switch over to the override value."] pub struct USB_PWR (u32) ; impl USB_PWR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn vbus_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_vbus_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn vbus_en_override_en (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_vbus_en_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn vbus_detect (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_vbus_detect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn vbus_detect_override_en (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_vbus_detect_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn overcurr_detect (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_overcurr_detect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn overcurr_detect_en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_overcurr_detect_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Note that most functions are driven directly from usb_fsls controller.  This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation \n                    Use in conjunction with usbphy_direct_override register"] pub struct USBPHY_DIRECT (u32) ; impl USBPHY_DIRECT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "when dp_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2"] pub fn dp_pullup_hisel (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "when dp_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2"] pub fn set_dp_pullup_hisel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller"] pub fn dp_pullup_en (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller"] pub fn set_dp_pullup_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpd on DPP"] pub fn dp_pulldn_en (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpd on DPP"] pub fn set_dp_pulldn_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "when dm_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2"] pub fn dm_pullup_hisel (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "when dm_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2"] pub fn set_dm_pullup_hisel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpu on DPM"] pub fn dm_pullup_en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpu on DPM"] pub fn set_dm_pullup_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpd on DPM"] pub fn dm_pulldn_en (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            1 - Enable Rpd on DPM"] pub fn set_dm_pulldn_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving \n                            TX_SEMODE=1, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving"] pub fn tx_dp_oe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving \n                            TX_SEMODE=1, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving"] pub fn set_tx_dp_oe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Ignored. \n                            TX_SEMODE=1, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving"] pub fn tx_dm_oe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Ignored. \n                            TX_SEMODE=1, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving"] pub fn set_tx_dm_oe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP \n                            TX_SEMODE=1, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP"] pub fn tx_dp (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP \n                            TX_SEMODE=1, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP"] pub fn set_tx_dp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Ignored \n                            TX_SEMODE=1, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM"] pub fn tx_dm (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller \n                            TX_SEMODE=0, Ignored \n                            TX_SEMODE=1, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM"] pub fn set_tx_dm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn rx_pd (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_rx_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn tx_pd (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_tx_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn tx_fsslew (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_tx_fsslew (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn tx_diffmode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_tx_diffmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Status bit from USB PHY \n                            RX Diff data"] pub fn rx_dd (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Status bit from USB PHY \n                            DPP pin state"] pub fn rx_dp (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Status bit from USB PHY \n                            DPM pin state"] pub fn rx_dm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Status bit from USB PHY"] pub fn dp_ovcn (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Status bit from USB PHY"] pub fn dm_ovcn (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Status bit from USB PHY"] pub fn dp_ovv (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Status bit from USB PHY"] pub fn dm_ovv (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct USBPHY_DIRECT_OVERRIDE (u32) ; impl USBPHY_DIRECT_OVERRIDE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn dp_pullup_hisel_override_en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_dp_pullup_hisel_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn dm_pullup_hisel_override_en (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_dm_pullup_hisel_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn dp_pullup_en_override_en (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_dp_pullup_en_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn dp_pulldn_en_override_en (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_dp_pulldn_en_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn dm_pulldn_en_override_en (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_dm_pulldn_en_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn tx_dp_oe_override_en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_tx_dp_oe_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn tx_dm_oe_override_en (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_tx_dm_oe_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn tx_dp_override_en (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_tx_dp_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn tx_dm_override_en (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Override default value or value driven from USB Controller to PHY"] pub fn set_tx_dm_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn rx_pd_override_en (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_rx_pd_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn tx_pd_override_en (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_tx_pd_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn tx_fsslew_override_en (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_tx_fsslew_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn dm_pullup_override_en (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_dm_pullup_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn tx_diffmode_override_en (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_tx_diffmode_override_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Note that most functions are driven directly from usb_fsls controller.  This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation"] pub struct USBPHY_TRIM (u32) ; impl USBPHY_TRIM { pub const RESET_VALUE : u32 = 7967u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value to drive to USB PHY \n                            DP pulldown resistor trim control \n                            Experimental data suggests that the reset value will work, but this register allows adjustment if required"] pub fn dp_pulldn_trim (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Value to drive to USB PHY \n                            DP pulldown resistor trim control \n                            Experimental data suggests that the reset value will work, but this register allows adjustment if required"] pub fn set_dp_pulldn_trim (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Value to drive to USB PHY \n                            DM pulldown resistor trim control \n                            Experimental data suggests that the reset value will work, but this register allows adjustment if required"] pub fn dm_pulldn_trim (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "Value to drive to USB PHY \n                            DM pulldown resistor trim control \n                            Experimental data suggests that the reset value will work, but this register allows adjustment if required"] pub fn set_dm_pulldn_trim (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn host_conn_dis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn host_resume (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn host_sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn trans_complete (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn buff_status (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn error_data_seq (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn error_rx_timeout (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn error_rx_overflow (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn error_bit_stuff (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn error_crc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn stall (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn vbus_detect (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn bus_reset (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn dev_conn_dis (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn dev_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn dev_resume_from_host (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn setup_req (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn dev_sof (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn abort_done (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn ep_stall_nak (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn host_conn_dis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn set_host_conn_dis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn host_resume (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn set_host_resume (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn host_sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn set_host_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn trans_complete (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn set_trans_complete (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn buff_status (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn set_buff_status (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn error_data_seq (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn set_error_data_seq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn error_rx_timeout (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn set_error_rx_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn error_rx_overflow (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn set_error_rx_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn error_bit_stuff (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn set_error_bit_stuff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn error_crc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn set_error_crc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn stall (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn vbus_detect (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn set_vbus_detect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn bus_reset (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn set_bus_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn dev_conn_dis (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn set_dev_conn_dis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn dev_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn set_dev_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn dev_resume_from_host (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn set_dev_resume_from_host (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn setup_req (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn set_setup_req (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn dev_sof (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn set_dev_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn abort_done (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn set_abort_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn ep_stall_nak (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn set_ep_stall_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn host_conn_dis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn set_host_conn_dis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn host_resume (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn set_host_resume (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn host_sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn set_host_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn trans_complete (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn set_trans_complete (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn buff_status (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn set_buff_status (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn error_data_seq (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn set_error_data_seq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn error_rx_timeout (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn set_error_rx_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn error_rx_overflow (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn set_error_rx_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn error_bit_stuff (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn set_error_bit_stuff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn error_crc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn set_error_crc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn stall (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn vbus_detect (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn set_vbus_detect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn bus_reset (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn set_bus_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn dev_conn_dis (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn set_dev_conn_dis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn dev_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn set_dev_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn dev_resume_from_host (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn set_dev_resume_from_host (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn setup_req (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn set_setup_req (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn dev_sof (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn set_dev_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn abort_done (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn set_abort_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn ep_stall_nak (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn set_ep_stall_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED"] pub fn host_conn_dis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn host_resume (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD"] pub fn host_sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit."] pub fn trans_complete (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS."] pub fn buff_status (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Source: SIE_STATUS.DATA_SEQ_ERROR"] pub fn error_data_seq (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_TIMEOUT"] pub fn error_rx_timeout (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Source: SIE_STATUS.RX_OVERFLOW"] pub fn error_rx_overflow (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Source: SIE_STATUS.BIT_STUFF_ERROR"] pub fn error_bit_stuff (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Source: SIE_STATUS.CRC_ERROR"] pub fn error_crc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Source: SIE_STATUS.STALL_REC"] pub fn stall (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Source: SIE_STATUS.VBUS_DETECT"] pub fn vbus_detect (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Source: SIE_STATUS.BUS_RESET"] pub fn bus_reset (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED"] pub fn dev_conn_dis (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED"] pub fn dev_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE"] pub fn dev_resume_from_host (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Device. Source: SIE_STATUS.SETUP_REC"] pub fn setup_req (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD"] pub fn dev_sof (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE."] pub fn abort_done (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK."] pub fn ep_stall_nak (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod uart0 { # [doc = "No description"] pub struct UART0 ; impl UART0 { pub const BASE_ADDR : u64 = 1073954816u64 ; } # [doc = "Data Register, UARTDR"] pub struct UARTDR (u32) ; impl UARTDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive (read) data character. Transmit (write) data character."] pub fn data (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Receive (read) data character. Transmit (write) data character."] pub fn set_data (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn fe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn pe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received."] pub fn be (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it."] pub fn oe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive Status Register/Error Clear Register, UARTRSR/UARTECR"] pub struct UARTRSR (u32) ; impl UARTRSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn fe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn set_fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn pe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."] pub fn set_pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] pub fn be (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] pub fn set_be (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."] pub fn oe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."] pub fn set_oe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flag Register, UARTFR"] pub struct UARTFR (u32) ; impl UARTFR { pub const RESET_VALUE : u32 = 144u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW."] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW."] pub fn dsr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW."] pub fn dcd (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not."] pub fn busy (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty."] pub fn rxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full."] pub fn txff (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full."] pub fn rxff (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register."] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW."] pub fn ri (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "IrDA Low-Power Counter Register, UARTILPR"] pub struct UARTILPR (u32) ; impl UARTILPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "8-bit low-power divisor value. These bits are cleared to 0 at reset."] pub fn ilpdvsr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "8-bit low-power divisor value. These bits are cleared to 0 at reset."] pub fn set_ilpdvsr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Integer Baud Rate Register, UARTIBRD"] pub struct UARTIBRD (u32) ; impl UARTIBRD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The integer baud rate divisor. These bits are cleared to 0 on reset."] pub fn baud_divint (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "The integer baud rate divisor. These bits are cleared to 0 on reset."] pub fn set_baud_divint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Fractional Baud Rate Register, UARTFBRD"] pub struct UARTFBRD (u32) ; impl UARTFBRD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The fractional baud rate divisor. These bits are cleared to 0 on reset."] pub fn baud_divfrac (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "The fractional baud rate divisor. These bits are cleared to 0 on reset."] pub fn set_baud_divfrac (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Line Control Register, UARTLCR_H"] pub struct UARTLCR_H (u32) ; impl UARTLCR_H { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0."] pub fn brk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0."] pub fn set_brk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled."] pub fn pen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled."] pub fn set_pen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn eps (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn set_eps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received."] pub fn stp2 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received."] pub fn set_stp2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode)."] pub fn fen (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode)."] pub fn set_fen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits."] pub fn wlen (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits."] pub fn set_wlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn sps (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation."] pub fn set_sps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control Register, UARTCR"] pub struct UARTCR (u32) ; impl UARTCR { pub const RESET_VALUE : u32 = 768u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit."] pub fn uarten (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit."] pub fn set_uarten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART."] pub fn siren (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART."] pub fn set_siren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances."] pub fn sirlp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances."] pub fn set_sirlp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback."] pub fn lbe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback."] pub fn set_lbe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping."] pub fn txe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping."] pub fn set_txe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping."] pub fn rxe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping."] pub fn set_rxe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW."] pub fn dtr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW."] pub fn set_dtr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW."] pub fn rts (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW."] pub fn set_rts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD)."] pub fn out1 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD)."] pub fn set_out1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI)."] pub fn out2 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI)."] pub fn set_out2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received."] pub fn rtsen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received."] pub fn set_rtsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted."] pub fn ctsen (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted."] pub fn set_ctsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt FIFO Level Select Register, UARTIFLS"] pub struct UARTIFLS (u32) ; impl UARTIFLS { pub const RESET_VALUE : u32 = 18u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved."] pub fn txiflsel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved."] pub fn set_txiflsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved."] pub fn rxiflsel (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved."] pub fn set_rxiflsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Mask Set/Clear Register, UARTIMSC"] pub struct UARTIMSC (u32) ; impl UARTIMSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask."] pub fn rimim (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rimim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask."] pub fn ctsmim (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask."] pub fn set_ctsmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask."] pub fn dcdmim (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask."] pub fn set_dcdmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask."] pub fn dsrmim (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask."] pub fn set_dsrmim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask."] pub fn rxim (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rxim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask."] pub fn txim (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask."] pub fn set_txim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask."] pub fn rtim (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask."] pub fn set_rtim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask."] pub fn feim (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_feim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask."] pub fn peim (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_peim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask."] pub fn beim (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_beim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask."] pub fn oeim (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask."] pub fn set_oeim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupt Status Register, UARTRIS"] pub struct UARTRIS (u32) ; impl UARTRIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt."] pub fn rirmis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt."] pub fn ctsrmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt."] pub fn dcdrmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt."] pub fn dsrrmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt."] pub fn rxris (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt."] pub fn txris (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a"] pub fn rtris (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt."] pub fn feris (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt."] pub fn peris (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt."] pub fn beris (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt."] pub fn oeris (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Masked Interrupt Status Register, UARTMIS"] pub struct UARTMIS (u32) ; impl UARTMIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt."] pub fn rimmis (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt."] pub fn ctsmmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt."] pub fn dcdmmis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt."] pub fn dsrmmis (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt."] pub fn rxmis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt."] pub fn txmis (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt."] pub fn rtmis (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt."] pub fn femis (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt."] pub fn pemis (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt."] pub fn bemis (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt."] pub fn oemis (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Clear Register, UARTICR"] pub struct UARTICR (u32) ; impl UARTICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt."] pub fn rimic (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt."] pub fn set_rimic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt."] pub fn ctsmic (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt."] pub fn set_ctsmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt."] pub fn dcdmic (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt."] pub fn set_dcdmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt."] pub fn dsrmic (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt."] pub fn set_dsrmic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive interrupt clear. Clears the UARTRXINTR interrupt."] pub fn rxic (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive interrupt clear. Clears the UARTRXINTR interrupt."] pub fn set_rxic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Transmit interrupt clear. Clears the UARTTXINTR interrupt."] pub fn txic (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Transmit interrupt clear. Clears the UARTTXINTR interrupt."] pub fn set_txic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Receive timeout interrupt clear. Clears the UARTRTINTR interrupt."] pub fn rtic (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Receive timeout interrupt clear. Clears the UARTRTINTR interrupt."] pub fn set_rtic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Framing error interrupt clear. Clears the UARTFEINTR interrupt."] pub fn feic (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Framing error interrupt clear. Clears the UARTFEINTR interrupt."] pub fn set_feic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Parity error interrupt clear. Clears the UARTPEINTR interrupt."] pub fn peic (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Parity error interrupt clear. Clears the UARTPEINTR interrupt."] pub fn set_peic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Break error interrupt clear. Clears the UARTBEINTR interrupt."] pub fn beic (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Break error interrupt clear. Clears the UARTBEINTR interrupt."] pub fn set_beic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Overrun error interrupt clear. Clears the UARTOEINTR interrupt."] pub fn oeic (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Overrun error interrupt clear. Clears the UARTOEINTR interrupt."] pub fn set_oeic (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA Control Register, UARTDMACR"] pub struct UARTDMACR (u32) ; impl UARTDMACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn rxdmae (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled."] pub fn set_rxdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn txdmae (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled."] pub fn set_txdmae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted."] pub fn dmaonerr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted."] pub fn set_dmaonerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID0 Register"] pub struct UARTPERIPHID0 (u32) ; impl UARTPERIPHID0 { pub const RESET_VALUE : u32 = 17u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x11"] pub fn partnumber0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID1 Register"] pub struct UARTPERIPHID1 (u32) ; impl UARTPERIPHID1 { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0"] pub fn partnumber1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "These bits read back as 0x1"] pub fn designer0 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID2 Register"] pub struct UARTPERIPHID2 (u32) ; impl UARTPERIPHID2 { pub const RESET_VALUE : u32 = 52u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x4"] pub fn designer1 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3"] pub fn revision (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPeriphID3 Register"] pub struct UARTPERIPHID3 (u32) ; impl UARTPERIPHID3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x00"] pub fn configuration (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID0 Register"] pub struct UARTPCELLID0 (u32) ; impl UARTPCELLID0 { pub const RESET_VALUE : u32 = 13u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x0D"] pub fn uartpcellid0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID1 Register"] pub struct UARTPCELLID1 (u32) ; impl UARTPCELLID1 { pub const RESET_VALUE : u32 = 240u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xF0"] pub fn uartpcellid1 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID2 Register"] pub struct UARTPCELLID2 (u32) ; impl UARTPCELLID2 { pub const RESET_VALUE : u32 = 5u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0x05"] pub fn uartpcellid2 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UARTPCellID3 Register"] pub struct UARTPCELLID3 (u32) ; impl UARTPCELLID3 { pub const RESET_VALUE : u32 = 177u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "These bits read back as 0xB1"] pub fn uartpcellid3 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod io_bank0 { # [doc = "No description"] pub struct IO_BANK0 ; impl IO_BANK0 { pub const BASE_ADDR : u64 = 1073823744u64 ; } # [doc = "GPIO status"] pub struct GPIO0_STATUS (u32) ; impl GPIO0_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO0_CTRL (u32) ; impl GPIO0_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO1_STATUS (u32) ; impl GPIO1_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO1_CTRL (u32) ; impl GPIO1_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO2_STATUS (u32) ; impl GPIO2_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO2_CTRL (u32) ; impl GPIO2_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO3_STATUS (u32) ; impl GPIO3_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO3_CTRL (u32) ; impl GPIO3_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO4_STATUS (u32) ; impl GPIO4_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO4_CTRL (u32) ; impl GPIO4_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO5_STATUS (u32) ; impl GPIO5_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO5_CTRL (u32) ; impl GPIO5_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO6_STATUS (u32) ; impl GPIO6_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO6_CTRL (u32) ; impl GPIO6_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO7_STATUS (u32) ; impl GPIO7_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO7_CTRL (u32) ; impl GPIO7_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO8_STATUS (u32) ; impl GPIO8_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO8_CTRL (u32) ; impl GPIO8_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO9_STATUS (u32) ; impl GPIO9_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO9_CTRL (u32) ; impl GPIO9_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO10_STATUS (u32) ; impl GPIO10_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO10_CTRL (u32) ; impl GPIO10_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO11_STATUS (u32) ; impl GPIO11_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO11_CTRL (u32) ; impl GPIO11_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO12_STATUS (u32) ; impl GPIO12_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO12_CTRL (u32) ; impl GPIO12_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO13_STATUS (u32) ; impl GPIO13_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO13_CTRL (u32) ; impl GPIO13_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO14_STATUS (u32) ; impl GPIO14_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO14_CTRL (u32) ; impl GPIO14_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO15_STATUS (u32) ; impl GPIO15_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO15_CTRL (u32) ; impl GPIO15_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO16_STATUS (u32) ; impl GPIO16_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO16_CTRL (u32) ; impl GPIO16_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO17_STATUS (u32) ; impl GPIO17_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO17_CTRL (u32) ; impl GPIO17_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO18_STATUS (u32) ; impl GPIO18_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO18_CTRL (u32) ; impl GPIO18_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO19_STATUS (u32) ; impl GPIO19_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO19_CTRL (u32) ; impl GPIO19_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO20_STATUS (u32) ; impl GPIO20_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO20_CTRL (u32) ; impl GPIO20_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO21_STATUS (u32) ; impl GPIO21_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO21_CTRL (u32) ; impl GPIO21_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO22_STATUS (u32) ; impl GPIO22_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO22_CTRL (u32) ; impl GPIO22_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO23_STATUS (u32) ; impl GPIO23_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO23_CTRL (u32) ; impl GPIO23_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO24_STATUS (u32) ; impl GPIO24_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO24_CTRL (u32) ; impl GPIO24_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO25_STATUS (u32) ; impl GPIO25_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO25_CTRL (u32) ; impl GPIO25_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO26_STATUS (u32) ; impl GPIO26_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO26_CTRL (u32) ; impl GPIO26_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO27_STATUS (u32) ; impl GPIO27_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO27_CTRL (u32) ; impl GPIO27_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO28_STATUS (u32) ; impl GPIO28_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO28_CTRL (u32) ; impl GPIO28_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO status"] pub struct GPIO29_STATUS (u32) ; impl GPIO29_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "output signal from selected peripheral, before register override is applied"] pub fn outfromperi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "output signal to pad after register override is applied"] pub fn outtopad (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "output enable from selected peripheral, before register override is applied"] pub fn oefromperi (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "output enable to pad after register override is applied"] pub fn oetopad (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "input signal from pad, before override is applied"] pub fn infrompad (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "input signal to peripheral, after override is applied"] pub fn intoperi (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "interrupt from pad before override is applied"] pub fn irqfrompad (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "interrupt to processors, after override is applied"] pub fn irqtoproc (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO control including function select and overrides."] pub struct GPIO29_CTRL (u32) ; impl GPIO29_CTRL { pub const RESET_VALUE : u32 = 31u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn funcsel (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "0-31 -> selects pin function according to the gpio table \n                            31 == NULL"] pub fn set_funcsel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn outover (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "No description"] pub fn set_outover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn oeover (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "No description"] pub fn set_oeover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn inover (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "No description"] pub fn set_inover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn irqover (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "No description"] pub fn set_irqover (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR0 (u32) ; impl INTR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR1 (u32) ; impl INTR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR2 (u32) ; impl INTR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR3 (u32) ; impl INTR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc0"] pub struct PROC0_INTE0 (u32) ; impl PROC0_INTE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc0"] pub struct PROC0_INTE1 (u32) ; impl PROC0_INTE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc0"] pub struct PROC0_INTE2 (u32) ; impl PROC0_INTE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc0"] pub struct PROC0_INTE3 (u32) ; impl PROC0_INTE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc0"] pub struct PROC0_INTF0 (u32) ; impl PROC0_INTF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc0"] pub struct PROC0_INTF1 (u32) ; impl PROC0_INTF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc0"] pub struct PROC0_INTF2 (u32) ; impl PROC0_INTF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc0"] pub struct PROC0_INTF3 (u32) ; impl PROC0_INTF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc0"] pub struct PROC0_INTS0 (u32) ; impl PROC0_INTS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc0"] pub struct PROC0_INTS1 (u32) ; impl PROC0_INTS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc0"] pub struct PROC0_INTS2 (u32) ; impl PROC0_INTS2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc0"] pub struct PROC0_INTS3 (u32) ; impl PROC0_INTS3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc1"] pub struct PROC1_INTE0 (u32) ; impl PROC1_INTE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc1"] pub struct PROC1_INTE1 (u32) ; impl PROC1_INTE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc1"] pub struct PROC1_INTE2 (u32) ; impl PROC1_INTE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for proc1"] pub struct PROC1_INTE3 (u32) ; impl PROC1_INTE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc1"] pub struct PROC1_INTF0 (u32) ; impl PROC1_INTF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc1"] pub struct PROC1_INTF1 (u32) ; impl PROC1_INTF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc1"] pub struct PROC1_INTF2 (u32) ; impl PROC1_INTF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for proc1"] pub struct PROC1_INTF3 (u32) ; impl PROC1_INTF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc1"] pub struct PROC1_INTS0 (u32) ; impl PROC1_INTS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc1"] pub struct PROC1_INTS1 (u32) ; impl PROC1_INTS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc1"] pub struct PROC1_INTS2 (u32) ; impl PROC1_INTS2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for proc1"] pub struct PROC1_INTS3 (u32) ; impl PROC1_INTS3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for dormant_wake"] pub struct DORMANT_WAKE_INTE0 (u32) ; impl DORMANT_WAKE_INTE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for dormant_wake"] pub struct DORMANT_WAKE_INTE1 (u32) ; impl DORMANT_WAKE_INTE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for dormant_wake"] pub struct DORMANT_WAKE_INTE2 (u32) ; impl DORMANT_WAKE_INTE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable for dormant_wake"] pub struct DORMANT_WAKE_INTE3 (u32) ; impl DORMANT_WAKE_INTE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for dormant_wake"] pub struct DORMANT_WAKE_INTF0 (u32) ; impl DORMANT_WAKE_INTF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio0_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio1_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio2_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio3_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio4_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio5_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio6_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio7_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for dormant_wake"] pub struct DORMANT_WAKE_INTF1 (u32) ; impl DORMANT_WAKE_INTF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio8_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio9_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio10_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio11_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio12_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio13_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio14_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio15_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for dormant_wake"] pub struct DORMANT_WAKE_INTF2 (u32) ; impl DORMANT_WAKE_INTF2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio16_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio17_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio18_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio19_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio20_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio21_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_gpio22_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_gpio23_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force for dormant_wake"] pub struct DORMANT_WAKE_INTF3 (u32) ; impl DORMANT_WAKE_INTF3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_gpio24_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_gpio25_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_gpio26_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_gpio27_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_gpio28_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_level_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_low (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_gpio29_edge_high (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for dormant_wake"] pub struct DORMANT_WAKE_INTS0 (u32) ; impl DORMANT_WAKE_INTS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio0_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio0_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio0_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio1_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio1_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio2_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio2_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio3_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio3_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio4_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio4_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio5_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio5_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio6_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio6_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio7_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio7_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for dormant_wake"] pub struct DORMANT_WAKE_INTS1 (u32) ; impl DORMANT_WAKE_INTS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio8_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio8_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio8_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio9_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio9_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio10_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio10_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio11_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio11_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio12_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio12_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio13_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio13_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio14_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio14_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio15_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio15_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for dormant_wake"] pub struct DORMANT_WAKE_INTS2 (u32) ; impl DORMANT_WAKE_INTS2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio16_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio16_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio16_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio17_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio17_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio18_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio18_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio19_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio19_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio20_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio20_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio21_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio21_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_low (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn gpio22_level_high (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_low (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn gpio22_edge_high (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_low (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn gpio23_level_high (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_low (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn gpio23_edge_high (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing for dormant_wake"] pub struct DORMANT_WAKE_INTS3 (u32) ; impl DORMANT_WAKE_INTS3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gpio24_level_low (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn gpio24_level_high (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_low (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn gpio24_edge_high (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_low (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn gpio25_level_high (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_low (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn gpio25_edge_high (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_low (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn gpio26_level_high (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_low (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn gpio26_edge_high (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_low (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn gpio27_level_high (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_low (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn gpio27_edge_high (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_low (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn gpio28_level_high (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_low (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn gpio28_edge_high (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_low (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn gpio29_level_high (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_low (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn gpio29_edge_high (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod sysinfo { # [doc = "No description"] pub struct SYSINFO ; impl SYSINFO { pub const BASE_ADDR : u64 = 1073741824u64 ; } # [doc = "JEDEC JEP-106 compliant chip identifier."] pub struct CHIP_ID (u32) ; impl CHIP_ID { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn manufacturer (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "No description"] pub fn part (& self) -> u32 { (self . 0 >> 12u32) & 65535u32 } # [doc = "No description"] pub fn revision (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Platform register. Allows software to know what environment it is running in."] pub struct PLATFORM (u32) ; impl PLATFORM { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fpga (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn asic (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Git hash of the chip source. Used to identify chip version."] pub struct GITREF_RP2040 (u32) ; impl GITREF_RP2040 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn gitref_rp2040 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod clocks { # [doc = "No description"] pub struct CLOCKS ; impl CLOCKS { pub const BASE_ADDR : u64 = 1073774592u64 ; } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_GPOUT0_CTRL (u32) ; impl CLK_GPOUT0_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 15u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enables duty cycle correction for odd divisors"] pub fn dc50 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enables duty cycle correction for odd divisors"] pub fn set_dc50 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_GPOUT0_DIV (u32) ; impl CLK_GPOUT0_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_GPOUT0_SELECTED (u32) ; impl CLK_GPOUT0_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_gpout0_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_GPOUT1_CTRL (u32) ; impl CLK_GPOUT1_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 15u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enables duty cycle correction for odd divisors"] pub fn dc50 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enables duty cycle correction for odd divisors"] pub fn set_dc50 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_GPOUT1_DIV (u32) ; impl CLK_GPOUT1_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_GPOUT1_SELECTED (u32) ; impl CLK_GPOUT1_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_gpout1_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_GPOUT2_CTRL (u32) ; impl CLK_GPOUT2_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 15u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enables duty cycle correction for odd divisors"] pub fn dc50 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enables duty cycle correction for odd divisors"] pub fn set_dc50 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_GPOUT2_DIV (u32) ; impl CLK_GPOUT2_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_GPOUT2_SELECTED (u32) ; impl CLK_GPOUT2_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_gpout2_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_GPOUT3_CTRL (u32) ; impl CLK_GPOUT3_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 15u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enables duty cycle correction for odd divisors"] pub fn dc50 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enables duty cycle correction for odd divisors"] pub fn set_dc50 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_GPOUT3_DIV (u32) ; impl CLK_GPOUT3_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_GPOUT3_SELECTED (u32) ; impl CLK_GPOUT3_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_gpout3_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_REF_CTRL (u32) ; impl CLK_REF_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the clock source glitchlessly, can be changed on-the-fly"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Selects the clock source glitchlessly, can be changed on-the-fly"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_REF_DIV (u32) ; impl CLK_REF_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_REF_SELECTED (u32) ; impl CLK_REF_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s."] pub fn clk_ref_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_SYS_CTRL (u32) ; impl CLK_SYS_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the clock source glitchlessly, can be changed on-the-fly"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Selects the clock source glitchlessly, can be changed on-the-fly"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_SYS_DIV (u32) ; impl CLK_SYS_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_SYS_SELECTED (u32) ; impl CLK_SYS_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s."] pub fn clk_sys_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_PERI_CTRL (u32) ; impl CLK_PERI_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_PERI_DIV (u32) ; impl CLK_PERI_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_PERI_SELECTED (u32) ; impl CLK_PERI_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_peri_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_USB_CTRL (u32) ; impl CLK_USB_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_USB_DIV (u32) ; impl CLK_USB_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_USB_SELECTED (u32) ; impl CLK_USB_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_usb_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_ADC_CTRL (u32) ; impl CLK_ADC_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_ADC_DIV (u32) ; impl CLK_ADC_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_ADC_SELECTED (u32) ; impl CLK_ADC_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_adc_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control, can be changed on-the-fly (except for auxsrc)"] pub struct CLK_RTC_CTRL (u32) ; impl CLK_RTC_CTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn auxsrc (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "Selects the auxiliary clock source, will glitch when switching"] pub fn set_auxsrc (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Asynchronously kills the clock generator"] pub fn kill (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Asynchronously kills the clock generator"] pub fn set_kill (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Starts and stops the clock generator cleanly"] pub fn enable (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Starts and stops the clock generator cleanly"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn phase (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "This delays the enable signal by up to 3 cycles of the input clock \n                            This must be set before the clock is enabled to have any effect"] pub fn set_phase (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn nudge (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "An edge on this signal shifts the phase of the output by 1 cycle of the input clock \n                            This can be done at any time"] pub fn set_nudge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock divisor, can be changed on-the-fly"] pub struct CLK_RTC_DIV (u32) ; impl CLK_RTC_DIV { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Fractional component of the divisor"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Fractional component of the divisor"] pub fn set_frac (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn int (& self) -> u32 { (self . 0 >> 8u32) & 16777215u32 } # [doc = "Integer component of the divisor, 0 -> divide by 2^16"] pub fn set_int (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates which SRC is currently selected by the glitchless mux (one-hot)."] pub struct CLK_RTC_SELECTED (u32) ; impl CLK_RTC_SELECTED { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1."] pub fn clk_rtc_selected (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct CLK_SYS_RESUS_CTRL (u32) ; impl CLK_SYS_RESUS_CTRL { pub const RESET_VALUE : u32 = 255u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "This is expressed as a number of clk_ref cycles \n                            and must be >= 2x clk_ref_freq/min_clk_tst_freq"] pub fn timeout (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "This is expressed as a number of clk_ref cycles \n                            and must be >= 2x clk_ref_freq/min_clk_tst_freq"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable resus"] pub fn enable (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable resus"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Force a resus, for test purposes only"] pub fn frce (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Force a resus, for test purposes only"] pub fn set_frce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "For clearing the resus after the fault that triggered it has been corrected"] pub fn clear (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "For clearing the resus after the fault that triggered it has been corrected"] pub fn set_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No description"] pub struct CLK_SYS_RESUS_STATUS (u32) ; impl CLK_SYS_RESUS_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock has been resuscitated, correct the error then send ctrl_clear=1"] pub fn resussed (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reference clock frequency in kHz"] pub struct FC0_REF_KHZ (u32) ; impl FC0_REF_KHZ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_ref_khz (& self) -> u32 { (self . 0 >> 0u32) & 1048575u32 } # [doc = "No description"] pub fn set_fc0_ref_khz (& mut self , value : u32) { let value_masked = value & 1048575u32 ; self . 0 &= ! (1048575u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags"] pub struct FC0_MIN_KHZ (u32) ; impl FC0_MIN_KHZ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_min_khz (& self) -> u32 { (self . 0 >> 0u32) & 33554431u32 } # [doc = "No description"] pub fn set_fc0_min_khz (& mut self , value : u32) { let value_masked = value & 33554431u32 ; self . 0 &= ! (33554431u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags"] pub struct FC0_MAX_KHZ (u32) ; impl FC0_MAX_KHZ { pub const RESET_VALUE : u32 = 33554431u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_max_khz (& self) -> u32 { (self . 0 >> 0u32) & 33554431u32 } # [doc = "No description"] pub fn set_fc0_max_khz (& mut self , value : u32) { let value_masked = value & 33554431u32 ; self . 0 &= ! (33554431u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Delays the start of frequency counting to allow the mux to settle \n                    Delay is measured in multiples of the reference clock period"] pub struct FC0_DELAY (u32) ; impl FC0_DELAY { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_delay (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "No description"] pub fn set_fc0_delay (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval \n                    The default gives a test interval of 250us"] pub struct FC0_INTERVAL (u32) ; impl FC0_INTERVAL { pub const RESET_VALUE : u32 = 8u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_interval (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "No description"] pub fn set_fc0_interval (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock sent to frequency counter, set to 0 when not required \n                    Writing to this register initiates the frequency count"] pub struct FC0_SRC (u32) ; impl FC0_SRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn fc0_src (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "No description"] pub fn set_fc0_src (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Frequency counter status"] pub struct FC0_STATUS (u32) ; impl FC0_STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Test passed"] pub fn pass (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Test complete"] pub fn done (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Test running"] pub fn running (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Waiting for test clock to start"] pub fn waiting (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Test failed"] pub fn fail (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Test clock slower than expected, only valid when status_done=1"] pub fn slow (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Test clock faster than expected, only valid when status_done=1"] pub fn fast (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Test clock stopped during test"] pub fn died (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Result of frequency measurement, only valid when status_done=1"] pub struct FC0_RESULT (u32) ; impl FC0_RESULT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn frac (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "No description"] pub fn khz (& self) -> u32 { (self . 0 >> 5u32) & 33554431u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "enable clock in wake mode"] pub struct WAKE_EN0 (u32) ; impl WAKE_EN0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_clocks (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_clocks (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn clk_adc_adc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_clk_adc_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clk_sys_adc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn clk_sys_busctrl (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_busctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn clk_sys_busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_busfabric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn clk_sys_dma (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_dma (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn clk_sys_i2c0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_i2c0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn clk_sys_i2c1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_i2c1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn clk_sys_io (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_io (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn clk_sys_jtag (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_jtag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn clk_sys_vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_vreg_and_chip_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn clk_sys_pads (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pads (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn clk_sys_pio0 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pio0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn clk_sys_pio1 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pio1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn clk_sys_pll_sys (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pll_sys (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn clk_sys_pll_usb (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pll_usb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn clk_sys_psm (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_psm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn clk_sys_pwm (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pwm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn clk_sys_resets (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_resets (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn clk_sys_rom (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn clk_sys_rosc (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn clk_rtc_rtc (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_clk_rtc_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn clk_sys_rtc (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn clk_sys_sio (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sio (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn clk_peri_spi0 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn clk_sys_spi0 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn clk_peri_spi1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn clk_sys_spi1 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn clk_sys_sram0 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn clk_sys_sram1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn clk_sys_sram2 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn clk_sys_sram3 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "enable clock in wake mode"] pub struct WAKE_EN1 (u32) ; impl WAKE_EN1 { pub const RESET_VALUE : u32 = 32767u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_sram4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn clk_sys_sram5 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clk_sys_syscfg (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_syscfg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn clk_sys_sysinfo (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sysinfo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn clk_sys_tbman (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_tbman (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn clk_sys_timer (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_timer (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn clk_peri_uart0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn clk_sys_uart0 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn clk_peri_uart1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn clk_sys_uart1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn clk_sys_usbctrl (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn clk_usb_usbctrl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_clk_usb_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn clk_sys_watchdog (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_watchdog (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn clk_sys_xip (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_xip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn clk_sys_xosc (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_xosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "enable clock in sleep mode"] pub struct SLEEP_EN0 (u32) ; impl SLEEP_EN0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_clocks (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_clocks (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn clk_adc_adc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_clk_adc_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clk_sys_adc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_adc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn clk_sys_busctrl (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_busctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn clk_sys_busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_busfabric (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn clk_sys_dma (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_dma (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn clk_sys_i2c0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_i2c0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn clk_sys_i2c1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_i2c1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn clk_sys_io (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_io (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn clk_sys_jtag (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_jtag (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn clk_sys_vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_vreg_and_chip_reset (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn clk_sys_pads (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pads (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn clk_sys_pio0 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pio0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn clk_sys_pio1 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pio1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn clk_sys_pll_sys (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pll_sys (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "No description"] pub fn clk_sys_pll_usb (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pll_usb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "No description"] pub fn clk_sys_psm (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_psm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "No description"] pub fn clk_sys_pwm (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_pwm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "No description"] pub fn clk_sys_resets (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_resets (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "No description"] pub fn clk_sys_rom (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "No description"] pub fn clk_sys_rosc (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "No description"] pub fn clk_rtc_rtc (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn set_clk_rtc_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "No description"] pub fn clk_sys_rtc (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_rtc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "No description"] pub fn clk_sys_sio (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sio (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "No description"] pub fn clk_peri_spi0 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "No description"] pub fn clk_sys_spi0 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_spi0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "No description"] pub fn clk_peri_spi1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "No description"] pub fn clk_sys_spi1 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_spi1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "No description"] pub fn clk_sys_sram0 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "No description"] pub fn clk_sys_sram1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "No description"] pub fn clk_sys_sram2 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "No description"] pub fn clk_sys_sram3 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "enable clock in sleep mode"] pub struct SLEEP_EN1 (u32) ; impl SLEEP_EN1 { pub const RESET_VALUE : u32 = 32767u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_sram4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "No description"] pub fn clk_sys_sram5 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sram5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "No description"] pub fn clk_sys_syscfg (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_syscfg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "No description"] pub fn clk_sys_sysinfo (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_sysinfo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "No description"] pub fn clk_sys_tbman (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_tbman (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "No description"] pub fn clk_sys_timer (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_timer (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "No description"] pub fn clk_peri_uart0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "No description"] pub fn clk_sys_uart0 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_uart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "No description"] pub fn clk_peri_uart1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn set_clk_peri_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "No description"] pub fn clk_sys_uart1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_uart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "No description"] pub fn clk_sys_usbctrl (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "No description"] pub fn clk_usb_usbctrl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn set_clk_usb_usbctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "No description"] pub fn clk_sys_watchdog (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_watchdog (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "No description"] pub fn clk_sys_xip (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_xip (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "No description"] pub fn clk_sys_xosc (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_xosc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "indicates the state of the clock enable"] pub struct ENABLED0 (u32) ; impl ENABLED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_clocks (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn clk_adc_adc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_adc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_busctrl (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_busfabric (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_dma (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_i2c0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_i2c1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_io (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_jtag (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_vreg_and_chip_reset (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pads (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pio0 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pio1 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pll_sys (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pll_usb (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_psm (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_pwm (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_resets (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_rom (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_rosc (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "No description"] pub fn clk_rtc_rtc (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_rtc (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sio (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "No description"] pub fn clk_peri_spi0 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_spi0 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "No description"] pub fn clk_peri_spi1 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_spi1 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sram0 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sram1 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sram2 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sram3 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "indicates the state of the clock enable"] pub struct ENABLED1 (u32) ; impl ENABLED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_sram4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sram5 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_syscfg (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_sysinfo (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_tbman (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_timer (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "No description"] pub fn clk_peri_uart0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_uart0 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "No description"] pub fn clk_peri_uart1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_uart1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_usbctrl (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "No description"] pub fn clk_usb_usbctrl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_watchdog (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_xip (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "No description"] pub fn clk_sys_xosc (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Raw Interrupts"] pub struct INTR (u32) ; impl INTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_resus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Enable"] pub struct INTE (u32) ; impl INTE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_resus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_resus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt Force"] pub struct INTF (u32) ; impl INTF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_resus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No description"] pub fn set_clk_sys_resus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Interrupt status after masking & forcing"] pub struct INTS (u32) ; impl INTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No description"] pub fn clk_sys_resus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }
