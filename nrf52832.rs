// Generated by LabWired Codegen
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
pub mod spim2 { # [doc = "Serial Peripheral Interface Master with EasyDMA 2"] pub struct SPIM2 ; impl SPIM2 { pub const BASE_ADDR : u64 = 1073885184u64 ; } # [doc = "Start SPI transaction"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop SPI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend SPI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume SPI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI transaction has stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer and TXD buffer reached"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of TXD buffer reached"] pub struct EVENTS_ENDTX (u32) ; impl EVENTS_ENDTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transaction started"] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and START task"] pub fn end_start (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Shortcut between END event and START task"] pub fn set_end_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPIM"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPIM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPIM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency. Accuracy depends on the HFCLK source selected."] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct RXD_LIST (u32) ; impl RXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct TXD_LIST (u32) ; impl TXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod temp { # [doc = "Temperature Sensor"] pub struct TEMP_PERIPHERAL ; impl TEMP_PERIPHERAL { pub const BASE_ADDR : u64 = 1073790976u64 ; } # [doc = "Start temperature measurement"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop temperature measurement"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Temperature measurement complete, data ready"] pub struct EVENTS_DATARDY (u32) ; impl EVENTS_DATARDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for DATARDY event"] pub fn datardy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DATARDY event"] pub fn set_datardy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for DATARDY event"] pub fn datardy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DATARDY event"] pub fn set_datardy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Temperature in degC (0.25deg steps)"] pub struct TEMP (u32) ; impl TEMP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Temperature in degC (0.25deg steps)"] pub fn temp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Temperature in degC (0.25deg steps)"] pub fn set_temp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 1st piece wise linear function"] pub struct A0 (u32) ; impl A0 { pub const RESET_VALUE : u32 = 800u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 1st piece wise linear function"] pub fn a0 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 1st piece wise linear function"] pub fn set_a0 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 2nd piece wise linear function"] pub struct A1 (u32) ; impl A1 { pub const RESET_VALUE : u32 = 835u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 2nd piece wise linear function"] pub fn a1 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 2nd piece wise linear function"] pub fn set_a1 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 3rd piece wise linear function"] pub struct A2 (u32) ; impl A2 { pub const RESET_VALUE : u32 = 861u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 3rd piece wise linear function"] pub fn a2 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 3rd piece wise linear function"] pub fn set_a2 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 4th piece wise linear function"] pub struct A3 (u32) ; impl A3 { pub const RESET_VALUE : u32 = 1024u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 4th piece wise linear function"] pub fn a3 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 4th piece wise linear function"] pub fn set_a3 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 5th piece wise linear function"] pub struct A4 (u32) ; impl A4 { pub const RESET_VALUE : u32 = 1151u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 5th piece wise linear function"] pub fn a4 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 5th piece wise linear function"] pub fn set_a4 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope of 6th piece wise linear function"] pub struct A5 (u32) ; impl A5 { pub const RESET_VALUE : u32 = 891u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slope of 6th piece wise linear function"] pub fn a5 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Slope of 6th piece wise linear function"] pub fn set_a5 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 1st piece wise linear function"] pub struct B0 (u32) ; impl B0 { pub const RESET_VALUE : u32 = 16332u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 1st piece wise linear function"] pub fn b0 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 1st piece wise linear function"] pub fn set_b0 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 2nd piece wise linear function"] pub struct B1 (u32) ; impl B1 { pub const RESET_VALUE : u32 = 16280u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 2nd piece wise linear function"] pub fn b1 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 2nd piece wise linear function"] pub fn set_b1 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 3rd piece wise linear function"] pub struct B2 (u32) ; impl B2 { pub const RESET_VALUE : u32 = 16280u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 3rd piece wise linear function"] pub fn b2 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 3rd piece wise linear function"] pub fn set_b2 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 4th piece wise linear function"] pub struct B3 (u32) ; impl B3 { pub const RESET_VALUE : u32 = 18u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 4th piece wise linear function"] pub fn b3 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 4th piece wise linear function"] pub fn set_b3 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 5th piece wise linear function"] pub struct B4 (u32) ; impl B4 { pub const RESET_VALUE : u32 = 106u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 5th piece wise linear function"] pub fn b4 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 5th piece wise linear function"] pub fn set_b4 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept of 6th piece wise linear function"] pub struct B5 (u32) ; impl B5 { pub const RESET_VALUE : u32 = 15824u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "y-intercept of 6th piece wise linear function"] pub fn b5 (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "y-intercept of 6th piece wise linear function"] pub fn set_b5 (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End point of 1st piece wise linear function"] pub struct T0 (u32) ; impl T0 { pub const RESET_VALUE : u32 = 226u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End point of 1st piece wise linear function"] pub fn t0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "End point of 1st piece wise linear function"] pub fn set_t0 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End point of 2nd piece wise linear function"] pub struct T1 (u32) ; impl T1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End point of 2nd piece wise linear function"] pub fn t1 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "End point of 2nd piece wise linear function"] pub fn set_t1 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End point of 3rd piece wise linear function"] pub struct T2 (u32) ; impl T2 { pub const RESET_VALUE : u32 = 20u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End point of 3rd piece wise linear function"] pub fn t2 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "End point of 3rd piece wise linear function"] pub fn set_t2 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End point of 4th piece wise linear function"] pub struct T3 (u32) ; impl T3 { pub const RESET_VALUE : u32 = 25u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End point of 4th piece wise linear function"] pub fn t3 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "End point of 4th piece wise linear function"] pub fn set_t3 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End point of 5th piece wise linear function"] pub struct T4 (u32) ; impl T4 { pub const RESET_VALUE : u32 = 80u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End point of 5th piece wise linear function"] pub fn t4 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "End point of 5th piece wise linear function"] pub fn set_t4 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twi1 { # [doc = "I2C compatible Two-Wire Interface 1"] pub struct TWI1 ; impl TWI1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Start TWI receive sequence"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start TWI transmit sequence"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop TWI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI RXD byte received"] pub struct EVENTS_RXDREADY (u32) ; impl EVENTS_RXDREADY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI TXD byte sent"] pub struct EVENTS_TXDSENT (u32) ; impl EVENTS_TXDSENT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI byte boundary, generated before each byte that is sent or received"] pub struct EVENTS_BB (u32) ; impl EVENTS_BB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI entered the suspended state"] pub struct EVENTS_SUSPENDED (u32) ; impl EVENTS_SUSPENDED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between BB event and SUSPEND task"] pub fn bb_suspend (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between BB event and SUSPEND task"] pub fn set_bb_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between BB event and STOP task"] pub fn bb_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between BB event and STOP task"] pub fn set_bb_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for RXDREADY event"] pub fn rxdready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXDREADY event"] pub fn set_rxdready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TXDSENT event"] pub fn txdsent (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXDSENT event"] pub fn set_txdsent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for BB event"] pub fn bb (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for BB event"] pub fn set_bb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for RXDREADY event"] pub fn rxdready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXDREADY event"] pub fn set_rxdready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TXDSENT event"] pub fn txdsent (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXDSENT event"] pub fn set_txdsent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for BB event"] pub fn bb (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for BB event"] pub fn set_bb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn anack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn set_anack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWI"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWI"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWI"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL"] pub struct PSELSCL (u32) ; impl PSELSCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for TWI SCL signal"] pub fn pselscl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for TWI SCL signal"] pub fn set_pselscl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA"] pub struct PSELSDA (u32) ; impl PSELSDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for TWI SDA signal"] pub fn pselsda (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for TWI SDA signal"] pub fn set_pselsda (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD register"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RXD register"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD register"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TXD register"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI master clock frequency"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TWI master clock frequency"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address used in the TWI transfer"] pub struct ADDRESS (u32) ; impl ADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address used in the TWI transfer"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Address used in the TWI transfer"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi2 { # [doc = "Software interrupt 2"] pub struct SWI2 ; impl SWI2 { pub const BASE_ADDR : u64 = 1073831936u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2s { # [doc = "Inter-IC Sound"] pub struct I2S ; impl I2S { pub const BASE_ADDR : u64 = 1073893376u64 ; } # [doc = "Starts continuous I2S transfer. Also starts MCK generator when this is enabled."] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the {event:STOPPED} event to be generated."] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin."] pub struct EVENTS_RXPTRUPD (u32) ; impl EVENTS_RXPTRUPD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S transfer stopped."] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin."] pub struct EVENTS_TXPTRUPD (u32) ; impl EVENTS_TXPTRUPD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for RXPTRUPD event"] pub fn rxptrupd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for RXPTRUPD event"] pub fn set_rxptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TXPTRUPD event"] pub fn txptrupd (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TXPTRUPD event"] pub fn set_txptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for RXPTRUPD event"] pub fn rxptrupd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXPTRUPD event"] pub fn set_rxptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TXPTRUPD event"] pub fn txptrupd (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXPTRUPD event"] pub fn set_txptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for RXPTRUPD event"] pub fn rxptrupd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXPTRUPD event"] pub fn set_rxptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TXPTRUPD event"] pub fn txptrupd (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXPTRUPD event"] pub fn set_txptrupd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable I2S module."] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable I2S module."] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable I2S module."] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S mode."] pub struct CONFIG_MODE (u32) ; impl CONFIG_MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S mode."] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "I2S mode."] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reception (RX) enable."] pub struct CONFIG_RXEN (u32) ; impl CONFIG_RXEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reception (RX) enable."] pub fn rxen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Reception (RX) enable."] pub fn set_rxen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmission (TX) enable."] pub struct CONFIG_TXEN (u32) ; impl CONFIG_TXEN { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmission (TX) enable."] pub fn txen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmission (TX) enable."] pub fn set_txen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Master clock generator enable."] pub struct CONFIG_MCKEN (u32) ; impl CONFIG_MCKEN { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master clock generator enable."] pub fn mcken (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Master clock generator enable."] pub fn set_mcken (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Master clock generator frequency."] pub struct CONFIG_MCKFREQ (u32) ; impl CONFIG_MCKFREQ { pub const RESET_VALUE : u32 = 536870912u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master clock generator frequency."] pub fn mckfreq (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Master clock generator frequency."] pub fn set_mckfreq (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "MCK / LRCK ratio."] pub struct CONFIG_RATIO (u32) ; impl CONFIG_RATIO { pub const RESET_VALUE : u32 = 6u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MCK / LRCK ratio."] pub fn ratio (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "MCK / LRCK ratio."] pub fn set_ratio (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sample width."] pub struct CONFIG_SWIDTH (u32) ; impl CONFIG_SWIDTH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sample width."] pub fn swidth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Sample width."] pub fn set_swidth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Alignment of sample within a frame."] pub struct CONFIG_ALIGN (u32) ; impl CONFIG_ALIGN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alignment of sample within a frame."] pub fn align (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Alignment of sample within a frame."] pub fn set_align (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Frame format."] pub struct CONFIG_FORMAT (u32) ; impl CONFIG_FORMAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Frame format."] pub fn format (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Frame format."] pub fn set_format (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable channels."] pub struct CONFIG_CHANNELS (u32) ; impl CONFIG_CHANNELS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable channels."] pub fn channels (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Enable channels."] pub fn set_channels (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive buffer RAM start address."] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address."] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address."] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit buffer RAM start address."] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address."] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address."] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Size of RXD and TXD buffers."] pub struct RXTXD_MAXCNT (u32) ; impl RXTXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Size of RXD and TXD buffers in number of 32 bit words."] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "Size of RXD and TXD buffers in number of 32 bit words."] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MCK signal."] pub struct PSEL_MCK (u32) ; impl PSEL_MCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK signal."] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for LRCK signal."] pub struct PSEL_LRCK (u32) ; impl PSEL_LRCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDIN signal."] pub struct PSEL_SDIN (u32) ; impl PSEL_SDIN { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDOUT signal."] pub struct PSEL_SDOUT (u32) ; impl PSEL_SDOUT { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pwm0 { # [doc = "Pulse Width Modulation Unit 0"] pub struct PWM0 ; impl PWM0 { pub const BASE_ADDR : u64 = 1073856512u64 ; } # [doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART0 (u32) ; impl TASKS_SEQSTART0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART1 (u32) ; impl TASKS_SEQSTART1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start it was not running."] pub struct TASKS_NEXTSTEP (u32) ; impl TASKS_NEXTSTEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Response to STOP task, emitted when PWM pulses are no longer generated"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED0 (u32) ; impl EVENTS_SEQSTARTED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED1 (u32) ; impl EVENTS_SEQSTARTED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND0 (u32) ; impl EVENTS_SEQEND0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND1 (u32) ; impl EVENTS_SEQEND1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Emitted at the end of each PWM period"] pub struct EVENTS_PWMPERIODEND (u32) ; impl EVENTS_PWMPERIODEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"] pub struct EVENTS_LOOPSDONE (u32) ; impl EVENTS_LOOPSDONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn seqend0_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn set_seqend0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn seqend1_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn set_seqend1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn loopsdone_seqstart0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn set_loopsdone_seqstart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn loopsdone_seqstart1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn set_loopsdone_seqstart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn loopsdone_stop (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn set_loopsdone_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PWM module enable register"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable PWM module"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable PWM module"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Selects operating mode of the wave counter"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects up or up and down as wave counter mode"] pub fn updown (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Selects up or up and down as wave counter mode"] pub fn set_updown (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Value up to which the pulse generator counter counts"] pub struct COUNTERTOP (u32) ; impl COUNTERTOP { pub const RESET_VALUE : u32 = 1023u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn countertop (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn set_countertop (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration for PWM_CLK"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pre-scaler of PWM_CLK"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Pre-scaler of PWM_CLK"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of the decoder"] pub struct DECODER (u32) ; impl DECODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn load (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn set_load (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Selects source for advancing the active sequence"] pub fn mode (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Selects source for advancing the active sequence"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Amount of playback of a loop"] pub struct LOOP (u32) ; impl LOOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of playback of pattern cycles"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Amount of playback of pattern cycles"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ0_PTR (u32) ; impl SEQ0_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ0_CNT (u32) ; impl SEQ0_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ0_REFRESH (u32) ; impl SEQ0_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ0_ENDDELAY (u32) ; impl SEQ0_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ1_PTR (u32) ; impl SEQ1_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ1_CNT (u32) ; impl SEQ1_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ1_REFRESH (u32) ; impl SEQ1_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ1_ENDDELAY (u32) ; impl SEQ1_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT0 (u32) ; impl PSEL_OUT0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT1 (u32) ; impl PSEL_OUT1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT2 (u32) ; impl PSEL_OUT2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT3 (u32) ; impl PSEL_OUT3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod p0 { # [doc = "GPIO Port 1"] pub struct P0 ; impl P0 { pub const BASE_ADDR : u64 = 1342177280u64 ; } # [doc = "Write GPIO port"] pub struct OUT (u32) ; impl OUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set individual bits in GPIO port"] pub struct OUTSET (u32) ; impl OUTSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear individual bits in GPIO port"] pub struct OUTCLR (u32) ; impl OUTCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read GPIO port"] pub struct IN (u32) ; impl IN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Direction of GPIO pins"] pub struct DIR (u32) ; impl DIR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DIR set register"] pub struct DIRSET (u32) ; impl DIRSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set as output pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Set as output pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Set as output pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Set as output pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set as output pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Set as output pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Set as output pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Set as output pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Set as output pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Set as output pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Set as output pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Set as output pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Set as output pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Set as output pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Set as output pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Set as output pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Set as output pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Set as output pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Set as output pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Set as output pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Set as output pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Set as output pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Set as output pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Set as output pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Set as output pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Set as output pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set as output pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set as output pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Set as output pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set as output pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Set as output pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Set as output pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Set as output pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Set as output pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Set as output pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Set as output pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Set as output pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Set as output pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Set as output pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Set as output pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Set as output pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Set as output pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Set as output pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Set as output pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Set as output pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Set as output pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Set as output pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Set as output pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Set as output pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Set as output pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Set as output pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Set as output pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Set as output pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Set as output pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Set as output pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Set as output pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Set as output pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Set as output pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Set as output pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Set as output pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Set as output pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Set as output pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Set as output pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Set as output pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DIR clear register"] pub struct DIRCLR (u32) ; impl DIRCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set as input pin 0"] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Set as input pin 0"] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Set as input pin 1"] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Set as input pin 1"] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Set as input pin 2"] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Set as input pin 2"] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Set as input pin 3"] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Set as input pin 3"] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Set as input pin 4"] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Set as input pin 4"] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Set as input pin 5"] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Set as input pin 5"] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Set as input pin 6"] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Set as input pin 6"] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Set as input pin 7"] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Set as input pin 7"] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Set as input pin 8"] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Set as input pin 8"] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Set as input pin 9"] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Set as input pin 9"] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Set as input pin 10"] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Set as input pin 10"] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Set as input pin 11"] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Set as input pin 11"] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Set as input pin 12"] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Set as input pin 12"] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Set as input pin 13"] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Set as input pin 13"] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Set as input pin 14"] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Set as input pin 14"] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Set as input pin 15"] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Set as input pin 15"] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Set as input pin 16"] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Set as input pin 16"] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Set as input pin 17"] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Set as input pin 17"] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Set as input pin 18"] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Set as input pin 18"] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Set as input pin 19"] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Set as input pin 19"] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Set as input pin 20"] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Set as input pin 20"] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Set as input pin 21"] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Set as input pin 21"] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Set as input pin 22"] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Set as input pin 22"] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Set as input pin 23"] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Set as input pin 23"] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Set as input pin 24"] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Set as input pin 24"] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Set as input pin 25"] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Set as input pin 25"] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Set as input pin 26"] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Set as input pin 26"] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Set as input pin 27"] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Set as input pin 27"] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Set as input pin 28"] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Set as input pin 28"] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Set as input pin 29"] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Set as input pin 29"] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Set as input pin 30"] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Set as input pin 30"] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Set as input pin 31"] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Set as input pin 31"] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers"] pub struct LATCH (u32) ; impl LATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear."] pub fn pin0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear."] pub fn set_pin0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear."] pub fn pin1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear."] pub fn set_pin1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear."] pub fn pin2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear."] pub fn set_pin2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear."] pub fn pin3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear."] pub fn set_pin3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear."] pub fn pin4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear."] pub fn set_pin4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear."] pub fn pin5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear."] pub fn set_pin5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear."] pub fn pin6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear."] pub fn set_pin6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear."] pub fn pin7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear."] pub fn set_pin7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear."] pub fn pin8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear."] pub fn set_pin8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear."] pub fn pin9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear."] pub fn set_pin9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear."] pub fn pin10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear."] pub fn set_pin10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear."] pub fn pin11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear."] pub fn set_pin11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear."] pub fn pin12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear."] pub fn set_pin12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear."] pub fn pin13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear."] pub fn set_pin13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear."] pub fn pin14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear."] pub fn set_pin14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear."] pub fn pin15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear."] pub fn set_pin15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear."] pub fn pin16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear."] pub fn set_pin16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear."] pub fn pin17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear."] pub fn set_pin17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear."] pub fn pin18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear."] pub fn set_pin18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear."] pub fn pin19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear."] pub fn set_pin19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear."] pub fn pin20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear."] pub fn set_pin20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear."] pub fn pin21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear."] pub fn set_pin21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear."] pub fn pin22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear."] pub fn set_pin22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear."] pub fn pin23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear."] pub fn set_pin23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear."] pub fn pin24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear."] pub fn set_pin24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear."] pub fn pin25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear."] pub fn set_pin25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear."] pub fn pin26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear."] pub fn set_pin26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear."] pub fn pin27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear."] pub fn set_pin27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear."] pub fn pin28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear."] pub fn set_pin28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear."] pub fn pin29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear."] pub fn set_pin29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear."] pub fn pin30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear."] pub fn set_pin30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear."] pub fn pin31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear."] pub fn set_pin31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Select between default DETECT signal behaviour and LDETECT mode"] pub struct DETECTMODE (u32) ; impl DETECTMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Select between default DETECT signal behaviour and LDETECT mode"] pub fn detectmode (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Select between default DETECT signal behaviour and LDETECT mode"] pub fn set_detectmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF0 (u32) ; impl PIN_CNF0 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF1 (u32) ; impl PIN_CNF1 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF2 (u32) ; impl PIN_CNF2 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF3 (u32) ; impl PIN_CNF3 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF4 (u32) ; impl PIN_CNF4 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF5 (u32) ; impl PIN_CNF5 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF6 (u32) ; impl PIN_CNF6 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF7 (u32) ; impl PIN_CNF7 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF8 (u32) ; impl PIN_CNF8 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF9 (u32) ; impl PIN_CNF9 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF10 (u32) ; impl PIN_CNF10 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF11 (u32) ; impl PIN_CNF11 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF12 (u32) ; impl PIN_CNF12 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF13 (u32) ; impl PIN_CNF13 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF14 (u32) ; impl PIN_CNF14 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF15 (u32) ; impl PIN_CNF15 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF16 (u32) ; impl PIN_CNF16 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF17 (u32) ; impl PIN_CNF17 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF18 (u32) ; impl PIN_CNF18 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF19 (u32) ; impl PIN_CNF19 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF20 (u32) ; impl PIN_CNF20 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF21 (u32) ; impl PIN_CNF21 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF22 (u32) ; impl PIN_CNF22 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF23 (u32) ; impl PIN_CNF23 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF24 (u32) ; impl PIN_CNF24 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF25 (u32) ; impl PIN_CNF25 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF26 (u32) ; impl PIN_CNF26 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF27 (u32) ; impl PIN_CNF27 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF28 (u32) ; impl PIN_CNF28 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF29 (u32) ; impl PIN_CNF29 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF30 (u32) ; impl PIN_CNF30 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration of GPIO pins"] pub struct PIN_CNF31 (u32) ; impl PIN_CNF31 { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin direction. Same physical register as DIR register"] pub fn dir (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pin direction. Same physical register as DIR register"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connect or disconnect input buffer"] pub fn input (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Connect or disconnect input buffer"] pub fn set_input (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pull configuration"] pub fn pull (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Pull configuration"] pub fn set_pull (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Drive configuration"] pub fn drive (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Drive configuration"] pub fn set_drive (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pin sensing mechanism"] pub fn sense (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin sensing mechanism"] pub fn set_sense (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer0 { # [doc = "Timer/Counter 0"] pub struct TIMER0 ; impl TIMER0 { pub const BASE_ADDR : u64 = 1073774592u64 ; } # [doc = "Start Timer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop Timer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Increment Timer (Counter mode only)"] pub struct TASKS_COUNT (u32) ; impl TASKS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear time"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Shut down timer"] pub struct TASKS_SHUTDOWN (u32) ; impl TASKS_SHUTDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE0 (u32) ; impl TASKS_CAPTURE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE1 (u32) ; impl TASKS_CAPTURE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE2 (u32) ; impl TASKS_CAPTURE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE3 (u32) ; impl TASKS_CAPTURE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn compare0_clear (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn set_compare0_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn compare1_clear (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn set_compare1_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn compare2_clear (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn set_compare2_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn compare3_clear (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn set_compare3_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn compare0_stop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn set_compare0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn compare1_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn set_compare1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn compare2_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn set_compare2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn compare3_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn set_compare3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer mode selection"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configure the number of bits used by the TIMER"] pub struct BITMODE (u32) ; impl BITMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer bit width"] pub fn bitmode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer bit width"] pub fn set_bitmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer prescaler register"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twim1 { # [doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"] pub struct TWIM1 ; impl TWIM1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Start TWI receive sequence"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start TWI transmit sequence"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."] pub struct EVENTS_SUSPENDED (u32) ; impl EVENTS_SUSPENDED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive sequence started"] pub struct EVENTS_RXSTARTED (u32) ; impl EVENTS_RXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit sequence started"] pub struct EVENTS_TXSTARTED (u32) ; impl EVENTS_TXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Byte boundary, starting to receive the last byte"] pub struct EVENTS_LASTRX (u32) ; impl EVENTS_LASTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Byte boundary, starting to transmit the last byte"] pub struct EVENTS_LASTTX (u32) ; impl EVENTS_LASTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between LASTTX event and STARTRX task"] pub fn lasttx_startrx (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Shortcut between LASTTX event and STARTRX task"] pub fn set_lasttx_startrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Shortcut between LASTTX event and SUSPEND task"] pub fn lasttx_suspend (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between LASTTX event and SUSPEND task"] pub fn set_lasttx_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between LASTTX event and STOP task"] pub fn lasttx_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between LASTTX event and STOP task"] pub fn set_lasttx_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between LASTRX event and STARTTX task"] pub fn lastrx_starttx (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between LASTRX event and STARTTX task"] pub fn set_lastrx_starttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between LASTRX event and STOP task"] pub fn lastrx_stop (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Shortcut between LASTRX event and STOP task"] pub fn set_lastrx_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable or disable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable or disable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable or disable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Write '1' to Enable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Write '1' to Disable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn anack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn set_anack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWIM"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWIM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWIM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL signal"] pub struct PSEL_SCL (u32) ; impl PSEL_SCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA signal"] pub struct PSEL_SDA (u32) ; impl PSEL_SDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI master clock frequency"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TWI master clock frequency"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct RXD_LIST (u32) ; impl RXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct TXD_LIST (u32) ; impl TXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address used in the TWI transfer"] pub struct ADDRESS (u32) ; impl ADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address used in the TWI transfer"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Address used in the TWI transfer"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ppi { # [doc = "Programmable Peripheral Interconnect"] pub struct PPI ; impl PPI { pub const BASE_ADDR : u64 = 1073868800u64 ; } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG0_EN (u32) ; impl TASKS_CHG0_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG0_DIS (u32) ; impl TASKS_CHG0_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG1_EN (u32) ; impl TASKS_CHG1_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG1_DIS (u32) ; impl TASKS_CHG1_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG2_EN (u32) ; impl TASKS_CHG2_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG2_DIS (u32) ; impl TASKS_CHG2_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG3_EN (u32) ; impl TASKS_CHG3_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG3_DIS (u32) ; impl TASKS_CHG3_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG4_EN (u32) ; impl TASKS_CHG4_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG4_DIS (u32) ; impl TASKS_CHG4_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Enable channel group 0"] pub struct TASKS_CHG5_EN (u32) ; impl TASKS_CHG5_EN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Disable channel group 0"] pub struct TASKS_CHG5_DIS (u32) ; impl TASKS_CHG5_DIS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Channel enable register"] pub struct CHEN (u32) ; impl CHEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable or disable channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable or disable channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Enable or disable channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable or disable channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Enable or disable channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable or disable channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable or disable channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable or disable channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable or disable channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable or disable channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable or disable channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable or disable channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable or disable channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Enable or disable channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable or disable channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable or disable channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable or disable channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable or disable channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable or disable channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable or disable channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable or disable channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Channel enable set register"] pub struct CHENSET (u32) ; impl CHENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel 0 enable set register.  Writing '0' has no effect"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel 0 enable set register.  Writing '0' has no effect"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel 1 enable set register.  Writing '0' has no effect"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel 1 enable set register.  Writing '0' has no effect"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Channel 2 enable set register.  Writing '0' has no effect"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Channel 2 enable set register.  Writing '0' has no effect"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Channel 3 enable set register.  Writing '0' has no effect"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Channel 3 enable set register.  Writing '0' has no effect"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Channel 4 enable set register.  Writing '0' has no effect"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Channel 4 enable set register.  Writing '0' has no effect"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Channel 5 enable set register.  Writing '0' has no effect"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Channel 5 enable set register.  Writing '0' has no effect"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Channel 6 enable set register.  Writing '0' has no effect"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Channel 6 enable set register.  Writing '0' has no effect"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Channel 7 enable set register.  Writing '0' has no effect"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Channel 7 enable set register.  Writing '0' has no effect"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Channel 8 enable set register.  Writing '0' has no effect"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Channel 8 enable set register.  Writing '0' has no effect"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Channel 9 enable set register.  Writing '0' has no effect"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Channel 9 enable set register.  Writing '0' has no effect"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Channel 10 enable set register.  Writing '0' has no effect"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Channel 10 enable set register.  Writing '0' has no effect"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Channel 11 enable set register.  Writing '0' has no effect"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Channel 11 enable set register.  Writing '0' has no effect"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Channel 12 enable set register.  Writing '0' has no effect"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Channel 12 enable set register.  Writing '0' has no effect"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Channel 13 enable set register.  Writing '0' has no effect"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Channel 13 enable set register.  Writing '0' has no effect"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Channel 14 enable set register.  Writing '0' has no effect"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Channel 14 enable set register.  Writing '0' has no effect"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Channel 15 enable set register.  Writing '0' has no effect"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Channel 15 enable set register.  Writing '0' has no effect"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Channel 16 enable set register.  Writing '0' has no effect"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Channel 16 enable set register.  Writing '0' has no effect"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Channel 17 enable set register.  Writing '0' has no effect"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Channel 17 enable set register.  Writing '0' has no effect"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Channel 18 enable set register.  Writing '0' has no effect"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Channel 18 enable set register.  Writing '0' has no effect"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Channel 19 enable set register.  Writing '0' has no effect"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Channel 19 enable set register.  Writing '0' has no effect"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Channel 20 enable set register.  Writing '0' has no effect"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Channel 20 enable set register.  Writing '0' has no effect"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Channel 21 enable set register.  Writing '0' has no effect"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Channel 21 enable set register.  Writing '0' has no effect"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Channel 22 enable set register.  Writing '0' has no effect"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Channel 22 enable set register.  Writing '0' has no effect"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Channel 23 enable set register.  Writing '0' has no effect"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Channel 23 enable set register.  Writing '0' has no effect"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel 24 enable set register.  Writing '0' has no effect"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Channel 24 enable set register.  Writing '0' has no effect"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Channel 25 enable set register.  Writing '0' has no effect"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Channel 25 enable set register.  Writing '0' has no effect"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Channel 26 enable set register.  Writing '0' has no effect"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Channel 26 enable set register.  Writing '0' has no effect"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Channel 27 enable set register.  Writing '0' has no effect"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Channel 27 enable set register.  Writing '0' has no effect"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Channel 28 enable set register.  Writing '0' has no effect"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Channel 28 enable set register.  Writing '0' has no effect"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Channel 29 enable set register.  Writing '0' has no effect"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Channel 29 enable set register.  Writing '0' has no effect"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel 30 enable set register.  Writing '0' has no effect"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel 30 enable set register.  Writing '0' has no effect"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel 31 enable set register.  Writing '0' has no effect"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel 31 enable set register.  Writing '0' has no effect"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Channel enable clear register"] pub struct CHENCLR (u32) ; impl CHENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel 0 enable clear register.  Writing '0' has no effect"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel 0 enable clear register.  Writing '0' has no effect"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel 1 enable clear register.  Writing '0' has no effect"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel 1 enable clear register.  Writing '0' has no effect"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Channel 2 enable clear register.  Writing '0' has no effect"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Channel 2 enable clear register.  Writing '0' has no effect"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Channel 3 enable clear register.  Writing '0' has no effect"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Channel 3 enable clear register.  Writing '0' has no effect"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Channel 4 enable clear register.  Writing '0' has no effect"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Channel 4 enable clear register.  Writing '0' has no effect"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Channel 5 enable clear register.  Writing '0' has no effect"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Channel 5 enable clear register.  Writing '0' has no effect"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Channel 6 enable clear register.  Writing '0' has no effect"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Channel 6 enable clear register.  Writing '0' has no effect"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Channel 7 enable clear register.  Writing '0' has no effect"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Channel 7 enable clear register.  Writing '0' has no effect"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Channel 8 enable clear register.  Writing '0' has no effect"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Channel 8 enable clear register.  Writing '0' has no effect"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Channel 9 enable clear register.  Writing '0' has no effect"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Channel 9 enable clear register.  Writing '0' has no effect"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Channel 10 enable clear register.  Writing '0' has no effect"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Channel 10 enable clear register.  Writing '0' has no effect"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Channel 11 enable clear register.  Writing '0' has no effect"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Channel 11 enable clear register.  Writing '0' has no effect"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Channel 12 enable clear register.  Writing '0' has no effect"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Channel 12 enable clear register.  Writing '0' has no effect"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Channel 13 enable clear register.  Writing '0' has no effect"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Channel 13 enable clear register.  Writing '0' has no effect"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Channel 14 enable clear register.  Writing '0' has no effect"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Channel 14 enable clear register.  Writing '0' has no effect"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Channel 15 enable clear register.  Writing '0' has no effect"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Channel 15 enable clear register.  Writing '0' has no effect"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Channel 16 enable clear register.  Writing '0' has no effect"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Channel 16 enable clear register.  Writing '0' has no effect"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Channel 17 enable clear register.  Writing '0' has no effect"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Channel 17 enable clear register.  Writing '0' has no effect"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Channel 18 enable clear register.  Writing '0' has no effect"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Channel 18 enable clear register.  Writing '0' has no effect"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Channel 19 enable clear register.  Writing '0' has no effect"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Channel 19 enable clear register.  Writing '0' has no effect"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Channel 20 enable clear register.  Writing '0' has no effect"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Channel 20 enable clear register.  Writing '0' has no effect"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Channel 21 enable clear register.  Writing '0' has no effect"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Channel 21 enable clear register.  Writing '0' has no effect"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Channel 22 enable clear register.  Writing '0' has no effect"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Channel 22 enable clear register.  Writing '0' has no effect"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Channel 23 enable clear register.  Writing '0' has no effect"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Channel 23 enable clear register.  Writing '0' has no effect"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel 24 enable clear register.  Writing '0' has no effect"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Channel 24 enable clear register.  Writing '0' has no effect"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Channel 25 enable clear register.  Writing '0' has no effect"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Channel 25 enable clear register.  Writing '0' has no effect"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Channel 26 enable clear register.  Writing '0' has no effect"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Channel 26 enable clear register.  Writing '0' has no effect"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Channel 27 enable clear register.  Writing '0' has no effect"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Channel 27 enable clear register.  Writing '0' has no effect"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Channel 28 enable clear register.  Writing '0' has no effect"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Channel 28 enable clear register.  Writing '0' has no effect"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Channel 29 enable clear register.  Writing '0' has no effect"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Channel 29 enable clear register.  Writing '0' has no effect"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel 30 enable clear register.  Writing '0' has no effect"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel 30 enable clear register.  Writing '0' has no effect"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel 31 enable clear register.  Writing '0' has no effect"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel 31 enable clear register.  Writing '0' has no effect"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH0_EEP (u32) ; impl CH0_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH0_TEP (u32) ; impl CH0_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH1_EEP (u32) ; impl CH1_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH1_TEP (u32) ; impl CH1_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH2_EEP (u32) ; impl CH2_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH2_TEP (u32) ; impl CH2_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH3_EEP (u32) ; impl CH3_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH3_TEP (u32) ; impl CH3_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH4_EEP (u32) ; impl CH4_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH4_TEP (u32) ; impl CH4_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH5_EEP (u32) ; impl CH5_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH5_TEP (u32) ; impl CH5_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH6_EEP (u32) ; impl CH6_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH6_TEP (u32) ; impl CH6_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH7_EEP (u32) ; impl CH7_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH7_TEP (u32) ; impl CH7_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH8_EEP (u32) ; impl CH8_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH8_TEP (u32) ; impl CH8_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH9_EEP (u32) ; impl CH9_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH9_TEP (u32) ; impl CH9_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH10_EEP (u32) ; impl CH10_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH10_TEP (u32) ; impl CH10_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH11_EEP (u32) ; impl CH11_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH11_TEP (u32) ; impl CH11_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH12_EEP (u32) ; impl CH12_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH12_TEP (u32) ; impl CH12_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH13_EEP (u32) ; impl CH13_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH13_TEP (u32) ; impl CH13_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH14_EEP (u32) ; impl CH14_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH14_TEP (u32) ; impl CH14_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH15_EEP (u32) ; impl CH15_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH15_TEP (u32) ; impl CH15_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH16_EEP (u32) ; impl CH16_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH16_TEP (u32) ; impl CH16_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH17_EEP (u32) ; impl CH17_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH17_TEP (u32) ; impl CH17_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH18_EEP (u32) ; impl CH18_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH18_TEP (u32) ; impl CH18_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 event end-point"] pub struct CH19_EEP (u32) ; impl CH19_EEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn eep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to event register. Accepts only addresses to registers from the Event group."] pub fn set_eep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct CH19_TEP (u32) ; impl CH19_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register. Accepts only addresses to registers from the Task group."] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG0 (u32) ; impl CHG0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG1 (u32) ; impl CHG1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG2 (u32) ; impl CHG2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG3 (u32) ; impl CHG3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG4 (u32) ; impl CHG4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Channel group 0"] pub struct CHG5 (u32) ; impl CHG5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude channel 0"] pub fn ch0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude channel 0"] pub fn set_ch0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude channel 1"] pub fn ch1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude channel 1"] pub fn set_ch1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude channel 2"] pub fn ch2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude channel 2"] pub fn set_ch2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude channel 3"] pub fn ch3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude channel 3"] pub fn set_ch3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude channel 4"] pub fn ch4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude channel 4"] pub fn set_ch4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude channel 5"] pub fn ch5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude channel 5"] pub fn set_ch5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude channel 6"] pub fn ch6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude channel 6"] pub fn set_ch6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude channel 7"] pub fn ch7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude channel 7"] pub fn set_ch7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude channel 8"] pub fn ch8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude channel 8"] pub fn set_ch8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude channel 9"] pub fn ch9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude channel 9"] pub fn set_ch9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude channel 10"] pub fn ch10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude channel 10"] pub fn set_ch10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude channel 11"] pub fn ch11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude channel 11"] pub fn set_ch11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude channel 12"] pub fn ch12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude channel 12"] pub fn set_ch12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude channel 13"] pub fn ch13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude channel 13"] pub fn set_ch13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude channel 14"] pub fn ch14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude channel 14"] pub fn set_ch14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude channel 15"] pub fn ch15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude channel 15"] pub fn set_ch15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude channel 16"] pub fn ch16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude channel 16"] pub fn set_ch16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude channel 17"] pub fn ch17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude channel 17"] pub fn set_ch17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude channel 18"] pub fn ch18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude channel 18"] pub fn set_ch18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude channel 19"] pub fn ch19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude channel 19"] pub fn set_ch19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude channel 20"] pub fn ch20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude channel 20"] pub fn set_ch20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude channel 21"] pub fn ch21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude channel 21"] pub fn set_ch21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude channel 22"] pub fn ch22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude channel 22"] pub fn set_ch22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude channel 23"] pub fn ch23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude channel 23"] pub fn set_ch23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude channel 24"] pub fn ch24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude channel 24"] pub fn set_ch24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude channel 25"] pub fn ch25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude channel 25"] pub fn set_ch25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude channel 26"] pub fn ch26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude channel 26"] pub fn set_ch26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude channel 27"] pub fn ch27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude channel 27"] pub fn set_ch27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude channel 28"] pub fn ch28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude channel 28"] pub fn set_ch28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude channel 29"] pub fn ch29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude channel 29"] pub fn set_ch29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude channel 30"] pub fn ch30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude channel 30"] pub fn set_ch30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude channel 31"] pub fn ch31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude channel 31"] pub fn set_ch31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK0_TEP (u32) ; impl FORK0_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK1_TEP (u32) ; impl FORK1_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK2_TEP (u32) ; impl FORK2_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK3_TEP (u32) ; impl FORK3_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK4_TEP (u32) ; impl FORK4_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK5_TEP (u32) ; impl FORK5_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK6_TEP (u32) ; impl FORK6_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK7_TEP (u32) ; impl FORK7_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK8_TEP (u32) ; impl FORK8_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK9_TEP (u32) ; impl FORK9_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK10_TEP (u32) ; impl FORK10_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK11_TEP (u32) ; impl FORK11_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK12_TEP (u32) ; impl FORK12_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK13_TEP (u32) ; impl FORK13_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK14_TEP (u32) ; impl FORK14_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK15_TEP (u32) ; impl FORK15_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK16_TEP (u32) ; impl FORK16_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK17_TEP (u32) ; impl FORK17_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK18_TEP (u32) ; impl FORK18_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK19_TEP (u32) ; impl FORK19_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK20_TEP (u32) ; impl FORK20_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK21_TEP (u32) ; impl FORK21_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK22_TEP (u32) ; impl FORK22_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK23_TEP (u32) ; impl FORK23_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK24_TEP (u32) ; impl FORK24_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK25_TEP (u32) ; impl FORK25_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK26_TEP (u32) ; impl FORK26_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK27_TEP (u32) ; impl FORK27_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK28_TEP (u32) ; impl FORK28_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK29_TEP (u32) ; impl FORK29_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK30_TEP (u32) ; impl FORK30_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Channel 0 task end-point"] pub struct FORK31_TEP (u32) ; impl FORK31_TEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to task register"] pub fn tep (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to task register"] pub fn set_tep (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod uicr { # [doc = "User Information Configuration Registers"] pub struct UICR ; impl UICR { pub const BASE_ADDR : u64 = 268439552u64 ; } # [doc = "Unspecified"] pub struct UNUSED0 (u32) ; impl UNUSED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Unspecified"] pub struct UNUSED1 (u32) ; impl UNUSED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Unspecified"] pub struct UNUSED2 (u32) ; impl UNUSED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Unspecified"] pub struct UNUSED3 (u32) ; impl UNUSED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW0 (u32) ; impl NRFFW0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW1 (u32) ; impl NRFFW1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW2 (u32) ; impl NRFFW2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW3 (u32) ; impl NRFFW3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW4 (u32) ; impl NRFFW4 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW5 (u32) ; impl NRFFW5 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW6 (u32) ; impl NRFFW6 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW7 (u32) ; impl NRFFW7 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW8 (u32) ; impl NRFFW8 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW9 (u32) ; impl NRFFW9 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW10 (u32) ; impl NRFFW10 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW11 (u32) ; impl NRFFW11 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW12 (u32) ; impl NRFFW12 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW13 (u32) ; impl NRFFW13 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic firmware design"] pub struct NRFFW14 (u32) ; impl NRFFW14 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic firmware design"] pub fn nrffw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic firmware design"] pub fn set_nrffw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW0 (u32) ; impl NRFHW0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW1 (u32) ; impl NRFHW1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW2 (u32) ; impl NRFHW2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW3 (u32) ; impl NRFHW3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW4 (u32) ; impl NRFHW4 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW5 (u32) ; impl NRFHW5 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW6 (u32) ; impl NRFHW6 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW7 (u32) ; impl NRFHW7 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW8 (u32) ; impl NRFHW8 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW9 (u32) ; impl NRFHW9 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW10 (u32) ; impl NRFHW10 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for Nordic hardware design"] pub struct NRFHW11 (u32) ; impl NRFHW11 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for Nordic hardware design"] pub fn nrfhw (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for Nordic hardware design"] pub fn set_nrfhw (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER0 (u32) ; impl CUSTOMER0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER1 (u32) ; impl CUSTOMER1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER2 (u32) ; impl CUSTOMER2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER3 (u32) ; impl CUSTOMER3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER4 (u32) ; impl CUSTOMER4 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER5 (u32) ; impl CUSTOMER5 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER6 (u32) ; impl CUSTOMER6 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER7 (u32) ; impl CUSTOMER7 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER8 (u32) ; impl CUSTOMER8 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER9 (u32) ; impl CUSTOMER9 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER10 (u32) ; impl CUSTOMER10 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER11 (u32) ; impl CUSTOMER11 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER12 (u32) ; impl CUSTOMER12 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER13 (u32) ; impl CUSTOMER13 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER14 (u32) ; impl CUSTOMER14 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER15 (u32) ; impl CUSTOMER15 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER16 (u32) ; impl CUSTOMER16 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER17 (u32) ; impl CUSTOMER17 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER18 (u32) ; impl CUSTOMER18 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER19 (u32) ; impl CUSTOMER19 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER20 (u32) ; impl CUSTOMER20 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER21 (u32) ; impl CUSTOMER21 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER22 (u32) ; impl CUSTOMER22 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER23 (u32) ; impl CUSTOMER23 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER24 (u32) ; impl CUSTOMER24 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER25 (u32) ; impl CUSTOMER25 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER26 (u32) ; impl CUSTOMER26 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER27 (u32) ; impl CUSTOMER27 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER28 (u32) ; impl CUSTOMER28 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER29 (u32) ; impl CUSTOMER29 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER30 (u32) ; impl CUSTOMER30 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reserved for customer"] pub struct CUSTOMER31 (u32) ; impl CUSTOMER31 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for customer"] pub fn customer (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for customer"] pub fn set_customer (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Mapping of the nRESET function (see POWER chapter for details)"] pub struct PSELRESET0 (u32) ; impl PSELRESET0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "GPIO number P0.n onto which Reset is exposed"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "GPIO number P0.n onto which Reset is exposed"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Mapping of the nRESET function (see POWER chapter for details)"] pub struct PSELRESET1 (u32) ; impl PSELRESET1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "GPIO number P0.n onto which Reset is exposed"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "GPIO number P0.n onto which Reset is exposed"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Access Port protection"] pub struct APPROTECT (u32) ; impl APPROTECT { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable Access Port protection. Any other value than 0xFF being written to this field will enable protection."] pub fn pall (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Enable or disable Access Port protection. Any other value than 0xFF being written to this field will enable protection."] pub fn set_pall (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Setting of pins dedicated to NFC functionality: NFC antenna or GPIO"] pub struct NFCPINS (u32) ; impl NFCPINS { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Setting of pins dedicated to NFC functionality"] pub fn protect (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Setting of pins dedicated to NFC functionality"] pub fn set_protect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod qdec { # [doc = "Quadrature Decoder"] pub struct QDEC ; impl QDEC { pub const BASE_ADDR : u64 = 1073815552u64 ; } # [doc = "Task starting the quadrature decoder"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Task stopping the quadrature decoder"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read and clear ACC and ACCDBL"] pub struct TASKS_READCLRACC (u32) ; impl TASKS_READCLRACC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read and clear ACC"] pub struct TASKS_RDCLRACC (u32) ; impl TASKS_RDCLRACC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read and clear ACCDBL"] pub struct TASKS_RDCLRDBL (u32) ; impl TASKS_RDCLRDBL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event being generated for every new sample value written to the SAMPLE register"] pub struct EVENTS_SAMPLERDY (u32) ; impl EVENTS_SAMPLERDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Non-null report ready"] pub struct EVENTS_REPORTRDY (u32) ; impl EVENTS_REPORTRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "ACC or ACCDBL register overflow"] pub struct EVENTS_ACCOF (u32) ; impl EVENTS_ACCOF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Double displacement(s) detected"] pub struct EVENTS_DBLRDY (u32) ; impl EVENTS_DBLRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "QDEC has been stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between REPORTRDY event and READCLRACC task"] pub fn reportrdy_readclracc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between REPORTRDY event and READCLRACC task"] pub fn set_reportrdy_readclracc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between SAMPLERDY event and STOP task"] pub fn samplerdy_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between SAMPLERDY event and STOP task"] pub fn set_samplerdy_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between REPORTRDY event and RDCLRACC task"] pub fn reportrdy_rdclracc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between REPORTRDY event and RDCLRACC task"] pub fn set_reportrdy_rdclracc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between REPORTRDY event and STOP task"] pub fn reportrdy_stop (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between REPORTRDY event and STOP task"] pub fn set_reportrdy_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between DBLRDY event and RDCLRDBL task"] pub fn dblrdy_rdclrdbl (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between DBLRDY event and RDCLRDBL task"] pub fn set_dblrdy_rdclrdbl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Shortcut between DBLRDY event and STOP task"] pub fn dblrdy_stop (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Shortcut between DBLRDY event and STOP task"] pub fn set_dblrdy_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Shortcut between SAMPLERDY event and READCLRACC task"] pub fn samplerdy_readclracc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Shortcut between SAMPLERDY event and READCLRACC task"] pub fn set_samplerdy_readclracc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for SAMPLERDY event"] pub fn samplerdy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SAMPLERDY event"] pub fn set_samplerdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for REPORTRDY event"] pub fn reportrdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REPORTRDY event"] pub fn set_reportrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ACCOF event"] pub fn accof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ACCOF event"] pub fn set_accof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for DBLRDY event"] pub fn dblrdy (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DBLRDY event"] pub fn set_dblrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for SAMPLERDY event"] pub fn samplerdy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SAMPLERDY event"] pub fn set_samplerdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for REPORTRDY event"] pub fn reportrdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REPORTRDY event"] pub fn set_reportrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ACCOF event"] pub fn accof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ACCOF event"] pub fn set_accof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for DBLRDY event"] pub fn dblrdy (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DBLRDY event"] pub fn set_dblrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable the quadrature decoder"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable the quadrature decoder"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable the quadrature decoder"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "LED output pin polarity"] pub struct LEDPOL (u32) ; impl LEDPOL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "LED output pin polarity"] pub fn ledpol (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "LED output pin polarity"] pub fn set_ledpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sample period"] pub struct SAMPLEPER (u32) ; impl SAMPLEPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sample period. The SAMPLE register will be updated for every new sample"] pub fn sampleper (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Sample period. The SAMPLE register will be updated for every new sample"] pub fn set_sampleper (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Motion sample value"] pub struct SAMPLE (u32) ; impl SAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Last motion sample"] pub fn sample (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Last motion sample"] pub fn set_sample (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"] pub struct REPORTPER (u32) ; impl REPORTPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated"] pub fn reportper (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated"] pub fn set_reportper (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Register accumulating the valid transitions"] pub struct ACC (u32) ; impl ACC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register accumulating all valid samples (not double transition) read from the SAMPLE register"] pub fn acc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Register accumulating all valid samples (not double transition) read from the SAMPLE register"] pub fn set_acc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task"] pub struct ACCREAD (u32) ; impl ACCREAD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Snapshot of the ACC register."] pub fn accread (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Snapshot of the ACC register."] pub fn set_accread (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for LED signal"] pub struct PSEL_LED (u32) ; impl PSEL_LED { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for A signal"] pub struct PSEL_A (u32) ; impl PSEL_A { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for B signal"] pub struct PSEL_B (u32) ; impl PSEL_B { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable input debounce filters"] pub struct DBFEN (u32) ; impl DBFEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable input debounce filters"] pub fn dbfen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable input debounce filters"] pub fn set_dbfen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Time period the LED is switched ON prior to sampling"] pub struct LEDPRE (u32) ; impl LEDPRE { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Period in us the LED is switched on prior to sampling"] pub fn ledpre (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Period in us the LED is switched on prior to sampling"] pub fn set_ledpre (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Register accumulating the number of detected double transitions"] pub struct ACCDBL (u32) ; impl ACCDBL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."] pub fn accdbl (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."] pub fn set_accdbl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"] pub struct ACCDBLREAD (u32) ; impl ACCDBLREAD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."] pub fn accdblread (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."] pub fn set_accdblread (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pwm2 { # [doc = "Pulse Width Modulation Unit 2"] pub struct PWM2 ; impl PWM2 { pub const BASE_ADDR : u64 = 1073881088u64 ; } # [doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART0 (u32) ; impl TASKS_SEQSTART0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART1 (u32) ; impl TASKS_SEQSTART1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start it was not running."] pub struct TASKS_NEXTSTEP (u32) ; impl TASKS_NEXTSTEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Response to STOP task, emitted when PWM pulses are no longer generated"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED0 (u32) ; impl EVENTS_SEQSTARTED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED1 (u32) ; impl EVENTS_SEQSTARTED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND0 (u32) ; impl EVENTS_SEQEND0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND1 (u32) ; impl EVENTS_SEQEND1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Emitted at the end of each PWM period"] pub struct EVENTS_PWMPERIODEND (u32) ; impl EVENTS_PWMPERIODEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"] pub struct EVENTS_LOOPSDONE (u32) ; impl EVENTS_LOOPSDONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn seqend0_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn set_seqend0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn seqend1_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn set_seqend1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn loopsdone_seqstart0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn set_loopsdone_seqstart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn loopsdone_seqstart1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn set_loopsdone_seqstart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn loopsdone_stop (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn set_loopsdone_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PWM module enable register"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable PWM module"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable PWM module"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Selects operating mode of the wave counter"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects up or up and down as wave counter mode"] pub fn updown (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Selects up or up and down as wave counter mode"] pub fn set_updown (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Value up to which the pulse generator counter counts"] pub struct COUNTERTOP (u32) ; impl COUNTERTOP { pub const RESET_VALUE : u32 = 1023u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn countertop (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn set_countertop (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration for PWM_CLK"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pre-scaler of PWM_CLK"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Pre-scaler of PWM_CLK"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of the decoder"] pub struct DECODER (u32) ; impl DECODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn load (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn set_load (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Selects source for advancing the active sequence"] pub fn mode (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Selects source for advancing the active sequence"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Amount of playback of a loop"] pub struct LOOP (u32) ; impl LOOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of playback of pattern cycles"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Amount of playback of pattern cycles"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ0_PTR (u32) ; impl SEQ0_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ0_CNT (u32) ; impl SEQ0_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ0_REFRESH (u32) ; impl SEQ0_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ0_ENDDELAY (u32) ; impl SEQ0_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ1_PTR (u32) ; impl SEQ1_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ1_CNT (u32) ; impl SEQ1_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ1_REFRESH (u32) ; impl SEQ1_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ1_ENDDELAY (u32) ; impl SEQ1_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT0 (u32) ; impl PSEL_OUT0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT1 (u32) ; impl PSEL_OUT1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT2 (u32) ; impl PSEL_OUT2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT3 (u32) ; impl PSEL_OUT3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod nvmc { # [doc = "Non Volatile Memory Controller"] pub struct NVMC ; impl NVMC { pub const BASE_ADDR : u64 = 1073864704u64 ; } # [doc = "Ready flag"] pub struct READY (u32) ; impl READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "NVMC is ready or busy"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "NVMC is ready or busy"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."] pub fn wen (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."] pub fn set_wen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Register for erasing a page in Code area"] pub struct ERASEPAGE (u32) ; impl ERASEPAGE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register for starting erase of a page in Code area"] pub fn erasepage (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Register for starting erase of a page in Code area"] pub fn set_erasepage (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE."] pub struct ERASEPCR1 (u32) ; impl ERASEPCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register for erasing a page in Code area. Equivalent to ERASEPAGE."] pub fn erasepcr1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Register for erasing a page in Code area. Equivalent to ERASEPAGE."] pub fn set_erasepcr1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Register for erasing all non-volatile user memory"] pub struct ERASEALL (u32) ; impl ERASEALL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Erase all non-volatile memory including UICR registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased."] pub fn eraseall (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Erase all non-volatile memory including UICR registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased."] pub fn set_eraseall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE."] pub struct ERASEPCR0 (u32) ; impl ERASEPCR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register for starting erase of a page in Code area. Equivalent to ERASEPAGE."] pub fn erasepcr0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Register for starting erase of a page in Code area. Equivalent to ERASEPAGE."] pub fn set_erasepcr0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Register for erasing User Information Configuration Registers"] pub struct ERASEUICR (u32) ; impl ERASEUICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Register starting erase of all User Information Configuration Registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased."] pub fn eraseuicr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Register starting erase of all User Information Configuration Registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased."] pub fn set_eraseuicr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I-Code cache configuration register."] pub struct ICACHECNF (u32) ; impl ICACHECNF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Cache enable"] pub fn cacheen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Cache enable"] pub fn set_cacheen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Cache profiling enable"] pub fn cacheprofen (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Cache profiling enable"] pub fn set_cacheprofen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I-Code cache hit counter."] pub struct IHIT (u32) ; impl IHIT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of cache hits"] pub fn hits (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Number of cache hits"] pub fn set_hits (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I-Code cache miss counter."] pub struct IMISS (u32) ; impl IMISS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of cache misses"] pub fn misses (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Number of cache misses"] pub fn set_misses (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod uarte0 { # [doc = "UART with EasyDMA"] pub struct UARTE0 ; impl UARTE0 { pub const BASE_ADDR : u64 = 1073750016u64 ; } # [doc = "Start UART receiver"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop UART receiver"] pub struct TASKS_STOPRX (u32) ; impl TASKS_STOPRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start UART transmitter"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop UART transmitter"] pub struct TASKS_STOPTX (u32) ; impl TASKS_STOPTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flush RX FIFO into RX buffer"] pub struct TASKS_FLUSHRX (u32) ; impl TASKS_FLUSHRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CTS is activated (set low). Clear To Send."] pub struct EVENTS_CTS (u32) ; impl EVENTS_CTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CTS is deactivated (set high). Not Clear To Send."] pub struct EVENTS_NCTS (u32) ; impl EVENTS_NCTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data received in RXD (but potentially not yet transferred to Data RAM)"] pub struct EVENTS_RXDRDY (u32) ; impl EVENTS_RXDRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive buffer is filled up"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data sent from TXD"] pub struct EVENTS_TXDRDY (u32) ; impl EVENTS_TXDRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Last TX byte transmitted"] pub struct EVENTS_ENDTX (u32) ; impl EVENTS_ENDTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error detected"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receiver timeout"] pub struct EVENTS_RXTO (u32) ; impl EVENTS_RXTO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UART receiver has started"] pub struct EVENTS_RXSTARTED (u32) ; impl EVENTS_RXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "UART transmitter has started"] pub struct EVENTS_TXSTARTED (u32) ; impl EVENTS_TXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmitter stopped"] pub struct EVENTS_TXSTOPPED (u32) ; impl EVENTS_TXSTOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between ENDRX event and STARTRX task"] pub fn endrx_startrx (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Shortcut between ENDRX event and STARTRX task"] pub fn set_endrx_startrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Shortcut between ENDRX event and STOPRX task"] pub fn endrx_stoprx (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Shortcut between ENDRX event and STOPRX task"] pub fn set_endrx_stoprx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for CTS event"] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for CTS event"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for NCTS event"] pub fn ncts (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for NCTS event"] pub fn set_ncts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for RXDRDY event"] pub fn rxdrdy (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for RXDRDY event"] pub fn set_rxdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TXDRDY event"] pub fn txdrdy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TXDRDY event"] pub fn set_txdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for RXTO event"] pub fn rxto (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable interrupt for RXTO event"] pub fn set_rxto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for TXSTOPPED event"] pub fn txstopped (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTOPPED event"] pub fn set_txstopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for CTS event"] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CTS event"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for NCTS event"] pub fn ncts (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for NCTS event"] pub fn set_ncts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for RXDRDY event"] pub fn rxdrdy (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXDRDY event"] pub fn set_rxdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TXDRDY event"] pub fn txdrdy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXDRDY event"] pub fn set_txdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for RXTO event"] pub fn rxto (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXTO event"] pub fn set_rxto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTOPPED event"] pub fn txstopped (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTOPPED event"] pub fn set_txstopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for CTS event"] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CTS event"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for NCTS event"] pub fn ncts (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for NCTS event"] pub fn set_ncts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for RXDRDY event"] pub fn rxdrdy (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXDRDY event"] pub fn set_rxdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TXDRDY event"] pub fn txdrdy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXDRDY event"] pub fn set_txdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for RXTO event"] pub fn rxto (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXTO event"] pub fn set_rxto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTOPPED event"] pub fn txstopped (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTOPPED event"] pub fn set_txstopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity error"] pub fn parity (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity error"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Framing error occurred"] pub fn framing (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Framing error occurred"] pub fn set_framing (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Break condition"] pub fn r#break (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Break condition"] pub fn set_break (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable UART"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable UARTE"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable UARTE"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for RTS signal"] pub struct PSEL_RTS (u32) ; impl PSEL_RTS { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for TXD signal"] pub struct PSEL_TXD (u32) ; impl PSEL_TXD { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for CTS signal"] pub struct PSEL_CTS (u32) ; impl PSEL_CTS { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for RXD signal"] pub struct PSEL_RXD (u32) ; impl PSEL_RXD { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate. Accuracy depends on the HFCLK source selected."] pub struct BAUDRATE (u32) ; impl BAUDRATE { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Baud rate"] pub fn baudrate (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Baud rate"] pub fn set_baudrate (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of parity and hardware flow control"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Hardware flow control"] pub fn hwfc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Hardware flow control"] pub fn set_hwfc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity"] pub fn parity (& self) -> u32 { (self . 0 >> 1u32) & 7u32 } # [doc = "Parity"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi1 { # [doc = "Serial Peripheral Interface 1"] pub struct SPI1 ; impl SPI1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "TXD byte sent and RXD byte received"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI SCK signal"] pub fn pselsck (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI SCK signal"] pub fn set_pselsck (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn pselmosi (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn set_pselmosi (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MISO signal"] pub fn pselmiso (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MISO signal"] pub fn set_pselmiso (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX data received. Double buffered"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RX data received. Double buffered"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX data to send. Double buffered"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TX data to send. Double buffered"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod bprot { # [doc = "Block Protect"] pub struct BPROT ; impl BPROT { pub const BASE_ADDR : u64 = 1073741824u64 ; } # [doc = "Block protect configuration register 0"] pub struct CONFIG0 (u32) ; impl CONFIG0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable protection for region 0. Write '0' has no effect."] pub fn region0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable protection for region 0. Write '0' has no effect."] pub fn set_region0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable protection for region 1. Write '0' has no effect."] pub fn region1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable protection for region 1. Write '0' has no effect."] pub fn set_region1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable protection for region 2. Write '0' has no effect."] pub fn region2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable protection for region 2. Write '0' has no effect."] pub fn set_region2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable protection for region 3. Write '0' has no effect."] pub fn region3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable protection for region 3. Write '0' has no effect."] pub fn set_region3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable protection for region 4. Write '0' has no effect."] pub fn region4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable protection for region 4. Write '0' has no effect."] pub fn set_region4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable protection for region 5. Write '0' has no effect."] pub fn region5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable protection for region 5. Write '0' has no effect."] pub fn set_region5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable protection for region 6. Write '0' has no effect."] pub fn region6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable protection for region 6. Write '0' has no effect."] pub fn set_region6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable protection for region 7. Write '0' has no effect."] pub fn region7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable protection for region 7. Write '0' has no effect."] pub fn set_region7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable protection for region 8. Write '0' has no effect."] pub fn region8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable protection for region 8. Write '0' has no effect."] pub fn set_region8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable protection for region 9. Write '0' has no effect."] pub fn region9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable protection for region 9. Write '0' has no effect."] pub fn set_region9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable protection for region 10. Write '0' has no effect."] pub fn region10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable protection for region 10. Write '0' has no effect."] pub fn set_region10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable protection for region 11. Write '0' has no effect."] pub fn region11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable protection for region 11. Write '0' has no effect."] pub fn set_region11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable protection for region 12. Write '0' has no effect."] pub fn region12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable protection for region 12. Write '0' has no effect."] pub fn set_region12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable protection for region 13. Write '0' has no effect."] pub fn region13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable protection for region 13. Write '0' has no effect."] pub fn set_region13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable protection for region 14. Write '0' has no effect."] pub fn region14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable protection for region 14. Write '0' has no effect."] pub fn set_region14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable protection for region 15. Write '0' has no effect."] pub fn region15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable protection for region 15. Write '0' has no effect."] pub fn set_region15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable protection for region 16. Write '0' has no effect."] pub fn region16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable protection for region 16. Write '0' has no effect."] pub fn set_region16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable protection for region 17. Write '0' has no effect."] pub fn region17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable protection for region 17. Write '0' has no effect."] pub fn set_region17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable protection for region 18. Write '0' has no effect."] pub fn region18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable protection for region 18. Write '0' has no effect."] pub fn set_region18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable protection for region 19. Write '0' has no effect."] pub fn region19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable protection for region 19. Write '0' has no effect."] pub fn set_region19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable protection for region 20. Write '0' has no effect."] pub fn region20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable protection for region 20. Write '0' has no effect."] pub fn set_region20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable protection for region 21. Write '0' has no effect."] pub fn region21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable protection for region 21. Write '0' has no effect."] pub fn set_region21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Enable protection for region 22. Write '0' has no effect."] pub fn region22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable protection for region 22. Write '0' has no effect."] pub fn set_region22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Enable protection for region 23. Write '0' has no effect."] pub fn region23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable protection for region 23. Write '0' has no effect."] pub fn set_region23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable protection for region 24. Write '0' has no effect."] pub fn region24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable protection for region 24. Write '0' has no effect."] pub fn set_region24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable protection for region 25. Write '0' has no effect."] pub fn region25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable protection for region 25. Write '0' has no effect."] pub fn set_region25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable protection for region 26. Write '0' has no effect."] pub fn region26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable protection for region 26. Write '0' has no effect."] pub fn set_region26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable protection for region 27. Write '0' has no effect."] pub fn region27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable protection for region 27. Write '0' has no effect."] pub fn set_region27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Enable protection for region 28. Write '0' has no effect."] pub fn region28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable protection for region 28. Write '0' has no effect."] pub fn set_region28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable protection for region 29. Write '0' has no effect."] pub fn region29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable protection for region 29. Write '0' has no effect."] pub fn set_region29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable protection for region 30. Write '0' has no effect."] pub fn region30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable protection for region 30. Write '0' has no effect."] pub fn set_region30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable protection for region 31. Write '0' has no effect."] pub fn region31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable protection for region 31. Write '0' has no effect."] pub fn set_region31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Block protect configuration register 1"] pub struct CONFIG1 (u32) ; impl CONFIG1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable protection for region 32. Write '0' has no effect."] pub fn region32 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable protection for region 32. Write '0' has no effect."] pub fn set_region32 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable protection for region 33. Write '0' has no effect."] pub fn region33 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable protection for region 33. Write '0' has no effect."] pub fn set_region33 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable protection for region 34. Write '0' has no effect."] pub fn region34 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable protection for region 34. Write '0' has no effect."] pub fn set_region34 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable protection for region 35. Write '0' has no effect."] pub fn region35 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable protection for region 35. Write '0' has no effect."] pub fn set_region35 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable protection for region 36. Write '0' has no effect."] pub fn region36 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable protection for region 36. Write '0' has no effect."] pub fn set_region36 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable protection for region 37. Write '0' has no effect."] pub fn region37 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable protection for region 37. Write '0' has no effect."] pub fn set_region37 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable protection for region 38. Write '0' has no effect."] pub fn region38 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable protection for region 38. Write '0' has no effect."] pub fn set_region38 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable protection for region 39. Write '0' has no effect."] pub fn region39 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable protection for region 39. Write '0' has no effect."] pub fn set_region39 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable protection for region 40. Write '0' has no effect."] pub fn region40 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable protection for region 40. Write '0' has no effect."] pub fn set_region40 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable protection for region 41. Write '0' has no effect."] pub fn region41 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable protection for region 41. Write '0' has no effect."] pub fn set_region41 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable protection for region 42. Write '0' has no effect."] pub fn region42 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable protection for region 42. Write '0' has no effect."] pub fn set_region42 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable protection for region 43. Write '0' has no effect."] pub fn region43 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable protection for region 43. Write '0' has no effect."] pub fn set_region43 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable protection for region 44. Write '0' has no effect."] pub fn region44 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable protection for region 44. Write '0' has no effect."] pub fn set_region44 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable protection for region 45. Write '0' has no effect."] pub fn region45 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable protection for region 45. Write '0' has no effect."] pub fn set_region45 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable protection for region 46. Write '0' has no effect."] pub fn region46 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable protection for region 46. Write '0' has no effect."] pub fn set_region46 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable protection for region 47. Write '0' has no effect."] pub fn region47 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable protection for region 47. Write '0' has no effect."] pub fn set_region47 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable protection for region 48. Write '0' has no effect."] pub fn region48 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable protection for region 48. Write '0' has no effect."] pub fn set_region48 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable protection for region 49. Write '0' has no effect."] pub fn region49 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable protection for region 49. Write '0' has no effect."] pub fn set_region49 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable protection for region 50. Write '0' has no effect."] pub fn region50 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable protection for region 50. Write '0' has no effect."] pub fn set_region50 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable protection for region 51. Write '0' has no effect."] pub fn region51 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable protection for region 51. Write '0' has no effect."] pub fn set_region51 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable protection for region 52. Write '0' has no effect."] pub fn region52 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable protection for region 52. Write '0' has no effect."] pub fn set_region52 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable protection for region 53. Write '0' has no effect."] pub fn region53 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable protection for region 53. Write '0' has no effect."] pub fn set_region53 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Enable protection for region 54. Write '0' has no effect."] pub fn region54 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable protection for region 54. Write '0' has no effect."] pub fn set_region54 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Enable protection for region 55. Write '0' has no effect."] pub fn region55 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable protection for region 55. Write '0' has no effect."] pub fn set_region55 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable protection for region 56. Write '0' has no effect."] pub fn region56 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable protection for region 56. Write '0' has no effect."] pub fn set_region56 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable protection for region 57. Write '0' has no effect."] pub fn region57 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable protection for region 57. Write '0' has no effect."] pub fn set_region57 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable protection for region 58. Write '0' has no effect."] pub fn region58 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable protection for region 58. Write '0' has no effect."] pub fn set_region58 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable protection for region 59. Write '0' has no effect."] pub fn region59 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable protection for region 59. Write '0' has no effect."] pub fn set_region59 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Enable protection for region 60. Write '0' has no effect."] pub fn region60 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable protection for region 60. Write '0' has no effect."] pub fn set_region60 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable protection for region 61. Write '0' has no effect."] pub fn region61 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable protection for region 61. Write '0' has no effect."] pub fn set_region61 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable protection for region 62. Write '0' has no effect."] pub fn region62 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable protection for region 62. Write '0' has no effect."] pub fn set_region62 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable protection for region 63. Write '0' has no effect."] pub fn region63 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable protection for region 63. Write '0' has no effect."] pub fn set_region63 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable protection mechanism in debug interface mode"] pub struct DISABLEINDEBUG (u32) ; impl DISABLEINDEBUG { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Disable the protection mechanism for NVM regions while in debug interface mode. This register will only disable the protection mechanism if the device is in debug interface mode."] pub fn disableindebug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Disable the protection mechanism for NVM regions while in debug interface mode. This register will only disable the protection mechanism if the device is in debug interface mode."] pub fn set_disableindebug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Unspecified"] pub struct UNUSED0 (u32) ; impl UNUSED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Block protect configuration register 2"] pub struct CONFIG2 (u32) ; impl CONFIG2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable protection for region 64. Write '0' has no effect."] pub fn region64 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable protection for region 64. Write '0' has no effect."] pub fn set_region64 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable protection for region 65. Write '0' has no effect."] pub fn region65 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable protection for region 65. Write '0' has no effect."] pub fn set_region65 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable protection for region 66. Write '0' has no effect."] pub fn region66 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable protection for region 66. Write '0' has no effect."] pub fn set_region66 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable protection for region 67. Write '0' has no effect."] pub fn region67 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable protection for region 67. Write '0' has no effect."] pub fn set_region67 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable protection for region 68. Write '0' has no effect."] pub fn region68 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable protection for region 68. Write '0' has no effect."] pub fn set_region68 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable protection for region 69. Write '0' has no effect."] pub fn region69 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable protection for region 69. Write '0' has no effect."] pub fn set_region69 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable protection for region 70. Write '0' has no effect."] pub fn region70 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable protection for region 70. Write '0' has no effect."] pub fn set_region70 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable protection for region 71. Write '0' has no effect."] pub fn region71 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable protection for region 71. Write '0' has no effect."] pub fn set_region71 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable protection for region 72. Write '0' has no effect."] pub fn region72 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable protection for region 72. Write '0' has no effect."] pub fn set_region72 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable protection for region 73. Write '0' has no effect."] pub fn region73 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable protection for region 73. Write '0' has no effect."] pub fn set_region73 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable protection for region 74. Write '0' has no effect."] pub fn region74 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable protection for region 74. Write '0' has no effect."] pub fn set_region74 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable protection for region 75. Write '0' has no effect."] pub fn region75 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable protection for region 75. Write '0' has no effect."] pub fn set_region75 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable protection for region 76. Write '0' has no effect."] pub fn region76 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable protection for region 76. Write '0' has no effect."] pub fn set_region76 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable protection for region 77. Write '0' has no effect."] pub fn region77 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable protection for region 77. Write '0' has no effect."] pub fn set_region77 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable protection for region 78. Write '0' has no effect."] pub fn region78 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable protection for region 78. Write '0' has no effect."] pub fn set_region78 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable protection for region 79. Write '0' has no effect."] pub fn region79 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable protection for region 79. Write '0' has no effect."] pub fn set_region79 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable protection for region 80. Write '0' has no effect."] pub fn region80 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable protection for region 80. Write '0' has no effect."] pub fn set_region80 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable protection for region 81. Write '0' has no effect."] pub fn region81 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable protection for region 81. Write '0' has no effect."] pub fn set_region81 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable protection for region 82. Write '0' has no effect."] pub fn region82 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable protection for region 82. Write '0' has no effect."] pub fn set_region82 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable protection for region 83. Write '0' has no effect."] pub fn region83 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable protection for region 83. Write '0' has no effect."] pub fn set_region83 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable protection for region 84. Write '0' has no effect."] pub fn region84 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable protection for region 84. Write '0' has no effect."] pub fn set_region84 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable protection for region 85. Write '0' has no effect."] pub fn region85 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable protection for region 85. Write '0' has no effect."] pub fn set_region85 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Enable protection for region 86. Write '0' has no effect."] pub fn region86 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable protection for region 86. Write '0' has no effect."] pub fn set_region86 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Enable protection for region 87. Write '0' has no effect."] pub fn region87 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable protection for region 87. Write '0' has no effect."] pub fn set_region87 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable protection for region 88. Write '0' has no effect."] pub fn region88 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable protection for region 88. Write '0' has no effect."] pub fn set_region88 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable protection for region 89. Write '0' has no effect."] pub fn region89 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable protection for region 89. Write '0' has no effect."] pub fn set_region89 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable protection for region 90. Write '0' has no effect."] pub fn region90 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable protection for region 90. Write '0' has no effect."] pub fn set_region90 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable protection for region 91. Write '0' has no effect."] pub fn region91 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable protection for region 91. Write '0' has no effect."] pub fn set_region91 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Enable protection for region 92. Write '0' has no effect."] pub fn region92 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable protection for region 92. Write '0' has no effect."] pub fn set_region92 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable protection for region 93. Write '0' has no effect."] pub fn region93 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable protection for region 93. Write '0' has no effect."] pub fn set_region93 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable protection for region 94. Write '0' has no effect."] pub fn region94 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable protection for region 94. Write '0' has no effect."] pub fn set_region94 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable protection for region 95. Write '0' has no effect."] pub fn region95 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable protection for region 95. Write '0' has no effect."] pub fn set_region95 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Block protect configuration register 3"] pub struct CONFIG3 (u32) ; impl CONFIG3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable protection for region 96. Write '0' has no effect."] pub fn region96 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable protection for region 96. Write '0' has no effect."] pub fn set_region96 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable protection for region 97. Write '0' has no effect."] pub fn region97 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable protection for region 97. Write '0' has no effect."] pub fn set_region97 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable protection for region 98. Write '0' has no effect."] pub fn region98 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable protection for region 98. Write '0' has no effect."] pub fn set_region98 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable protection for region 99. Write '0' has no effect."] pub fn region99 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable protection for region 99. Write '0' has no effect."] pub fn set_region99 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable protection for region 100. Write '0' has no effect."] pub fn region100 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable protection for region 100. Write '0' has no effect."] pub fn set_region100 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable protection for region 101. Write '0' has no effect."] pub fn region101 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable protection for region 101. Write '0' has no effect."] pub fn set_region101 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable protection for region 102. Write '0' has no effect."] pub fn region102 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable protection for region 102. Write '0' has no effect."] pub fn set_region102 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable protection for region 103. Write '0' has no effect."] pub fn region103 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable protection for region 103. Write '0' has no effect."] pub fn set_region103 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable protection for region 104. Write '0' has no effect."] pub fn region104 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable protection for region 104. Write '0' has no effect."] pub fn set_region104 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable protection for region 105. Write '0' has no effect."] pub fn region105 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable protection for region 105. Write '0' has no effect."] pub fn set_region105 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable protection for region 106. Write '0' has no effect."] pub fn region106 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable protection for region 106. Write '0' has no effect."] pub fn set_region106 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable protection for region 107. Write '0' has no effect."] pub fn region107 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable protection for region 107. Write '0' has no effect."] pub fn set_region107 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable protection for region 108. Write '0' has no effect."] pub fn region108 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable protection for region 108. Write '0' has no effect."] pub fn set_region108 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable protection for region 109. Write '0' has no effect."] pub fn region109 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable protection for region 109. Write '0' has no effect."] pub fn set_region109 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable protection for region 110. Write '0' has no effect."] pub fn region110 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable protection for region 110. Write '0' has no effect."] pub fn set_region110 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable protection for region 111. Write '0' has no effect."] pub fn region111 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable protection for region 111. Write '0' has no effect."] pub fn set_region111 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable protection for region 112. Write '0' has no effect."] pub fn region112 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable protection for region 112. Write '0' has no effect."] pub fn set_region112 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable protection for region 113. Write '0' has no effect."] pub fn region113 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable protection for region 113. Write '0' has no effect."] pub fn set_region113 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable protection for region 114. Write '0' has no effect."] pub fn region114 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable protection for region 114. Write '0' has no effect."] pub fn set_region114 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable protection for region 115. Write '0' has no effect."] pub fn region115 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable protection for region 115. Write '0' has no effect."] pub fn set_region115 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable protection for region 116. Write '0' has no effect."] pub fn region116 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable protection for region 116. Write '0' has no effect."] pub fn set_region116 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable protection for region 117. Write '0' has no effect."] pub fn region117 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable protection for region 117. Write '0' has no effect."] pub fn set_region117 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Enable protection for region 118. Write '0' has no effect."] pub fn region118 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Enable protection for region 118. Write '0' has no effect."] pub fn set_region118 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Enable protection for region 119. Write '0' has no effect."] pub fn region119 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable protection for region 119. Write '0' has no effect."] pub fn set_region119 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable protection for region 120. Write '0' has no effect."] pub fn region120 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable protection for region 120. Write '0' has no effect."] pub fn set_region120 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable protection for region 121. Write '0' has no effect."] pub fn region121 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable protection for region 121. Write '0' has no effect."] pub fn set_region121 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable protection for region 122. Write '0' has no effect."] pub fn region122 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable protection for region 122. Write '0' has no effect."] pub fn set_region122 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable protection for region 123. Write '0' has no effect."] pub fn region123 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable protection for region 123. Write '0' has no effect."] pub fn set_region123 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Enable protection for region 124. Write '0' has no effect."] pub fn region124 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Enable protection for region 124. Write '0' has no effect."] pub fn set_region124 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Enable protection for region 125. Write '0' has no effect."] pub fn region125 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Enable protection for region 125. Write '0' has no effect."] pub fn set_region125 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Enable protection for region 126. Write '0' has no effect."] pub fn region126 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Enable protection for region 126. Write '0' has no effect."] pub fn set_region126 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Enable protection for region 127. Write '0' has no effect."] pub fn region127 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Enable protection for region 127. Write '0' has no effect."] pub fn set_region127 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod wdt { # [doc = "Watchdog Timer"] pub struct WDT ; impl WDT { pub const BASE_ADDR : u64 = 1073807360u64 ; } # [doc = "Start the watchdog"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Watchdog timeout"] pub struct EVENTS_TIMEOUT (u32) ; impl EVENTS_TIMEOUT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TIMEOUT event"] pub fn timeout (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TIMEOUT event"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TIMEOUT event"] pub fn timeout (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TIMEOUT event"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Run status"] pub struct RUNSTATUS (u32) ; impl RUNSTATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates whether or not the watchdog is running"] pub fn runstatus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Indicates whether or not the watchdog is running"] pub fn set_runstatus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Request status"] pub struct REQSTATUS (u32) ; impl REQSTATUS { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Request status for RR[0] register"] pub fn rr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Request status for RR[0] register"] pub fn set_rr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Request status for RR[1] register"] pub fn rr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Request status for RR[1] register"] pub fn set_rr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Request status for RR[2] register"] pub fn rr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Request status for RR[2] register"] pub fn set_rr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Request status for RR[3] register"] pub fn rr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Request status for RR[3] register"] pub fn set_rr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Request status for RR[4] register"] pub fn rr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Request status for RR[4] register"] pub fn set_rr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Request status for RR[5] register"] pub fn rr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Request status for RR[5] register"] pub fn set_rr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Request status for RR[6] register"] pub fn rr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Request status for RR[6] register"] pub fn set_rr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Request status for RR[7] register"] pub fn rr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Request status for RR[7] register"] pub fn set_rr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Counter reload value"] pub struct CRV (u32) ; impl CRV { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter reload value in number of cycles of the 32.768 kHz clock"] pub fn crv (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Counter reload value in number of cycles of the 32.768 kHz clock"] pub fn set_crv (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable register for reload request registers"] pub struct RREN (u32) ; impl RREN { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable RR[0] register"] pub fn rr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable RR[0] register"] pub fn set_rr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable RR[1] register"] pub fn rr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable RR[1] register"] pub fn set_rr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable RR[2] register"] pub fn rr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable RR[2] register"] pub fn set_rr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable RR[3] register"] pub fn rr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable RR[3] register"] pub fn set_rr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable RR[4] register"] pub fn rr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable RR[4] register"] pub fn set_rr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable RR[5] register"] pub fn rr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable RR[5] register"] pub fn set_rr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable RR[6] register"] pub fn rr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable RR[6] register"] pub fn set_rr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable RR[7] register"] pub fn rr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable RR[7] register"] pub fn set_rr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Configure the watchdog to either be paused, or kept running, while the CPU is sleeping"] pub fn sleep (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Configure the watchdog to either be paused, or kept running, while the CPU is sleeping"] pub fn set_sleep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger"] pub fn halt (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger"] pub fn set_halt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR0 (u32) ; impl RR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR1 (u32) ; impl RR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR2 (u32) ; impl RR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR3 (u32) ; impl RR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR4 (u32) ; impl RR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR5 (u32) ; impl RR5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR6 (u32) ; impl RR6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Reload request 0"] pub struct RR7 (u32) ; impl RR7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reload request register"] pub fn rr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reload request register"] pub fn set_rr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi1 { # [doc = "Software interrupt 1"] pub struct SWI1 ; impl SWI1 { pub const BASE_ADDR : u64 = 1073827840u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pwm1 { # [doc = "Pulse Width Modulation Unit 1"] pub struct PWM1 ; impl PWM1 { pub const BASE_ADDR : u64 = 1073876992u64 ; } # [doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART0 (u32) ; impl TASKS_SEQSTART0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Loads the first PWM value on all enabled channels from sequence 0, and starts playing that sequence at the rate defined in SEQ[0]REFRESH and/or DECODER.MODE. Causes PWM generation to start it was not running."] pub struct TASKS_SEQSTART1 (u32) ; impl TASKS_SEQSTART1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start it was not running."] pub struct TASKS_NEXTSTEP (u32) ; impl TASKS_NEXTSTEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Response to STOP task, emitted when PWM pulses are no longer generated"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED0 (u32) ; impl EVENTS_SEQSTARTED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  First PWM period started on sequence 0"] pub struct EVENTS_SEQSTARTED1 (u32) ; impl EVENTS_SEQSTARTED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND0 (u32) ; impl EVENTS_SEQEND0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Emitted at end of every sequence 0, when last value from RAM has been applied to wave counter"] pub struct EVENTS_SEQEND1 (u32) ; impl EVENTS_SEQEND1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Emitted at the end of each PWM period"] pub struct EVENTS_PWMPERIODEND (u32) ; impl EVENTS_PWMPERIODEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"] pub struct EVENTS_LOOPSDONE (u32) ; impl EVENTS_LOOPSDONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn seqend0_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between SEQEND[0] event and STOP task"] pub fn set_seqend0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn seqend1_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between SEQEND[1] event and STOP task"] pub fn set_seqend1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn loopsdone_seqstart0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[0] task"] pub fn set_loopsdone_seqstart0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn loopsdone_seqstart1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and SEQSTART[1] task"] pub fn set_loopsdone_seqstart1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn loopsdone_stop (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between LOOPSDONE event and STOP task"] pub fn set_loopsdone_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn seqstarted0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[0] event"] pub fn set_seqstarted0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn seqstarted1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQSTARTED[1] event"] pub fn set_seqstarted1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn seqend0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[0] event"] pub fn set_seqend0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn seqend1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SEQEND[1] event"] pub fn set_seqend1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn pwmperiodend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PWMPERIODEND event"] pub fn set_pwmperiodend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn loopsdone (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LOOPSDONE event"] pub fn set_loopsdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PWM module enable register"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable PWM module"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable PWM module"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Selects operating mode of the wave counter"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Selects up or up and down as wave counter mode"] pub fn updown (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Selects up or up and down as wave counter mode"] pub fn set_updown (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Value up to which the pulse generator counter counts"] pub struct COUNTERTOP (u32) ; impl COUNTERTOP { pub const RESET_VALUE : u32 = 1023u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn countertop (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used."] pub fn set_countertop (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration for PWM_CLK"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pre-scaler of PWM_CLK"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Pre-scaler of PWM_CLK"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of the decoder"] pub struct DECODER (u32) ; impl DECODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn load (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "How a sequence is read from RAM and spread to the compare register"] pub fn set_load (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Selects source for advancing the active sequence"] pub fn mode (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Selects source for advancing the active sequence"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Amount of playback of a loop"] pub struct LOOP (u32) ; impl LOOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of playback of pattern cycles"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Amount of playback of pattern cycles"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ0_PTR (u32) ; impl SEQ0_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ0_CNT (u32) ; impl SEQ0_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ0_REFRESH (u32) ; impl SEQ0_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ0_ENDDELAY (u32) ; impl SEQ0_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Beginning address in Data RAM of this sequence"] pub struct SEQ1_PTR (u32) ; impl SEQ1_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Beginning address in Data RAM of this sequence"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Beginning address in Data RAM of this sequence"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of values (duty cycles) in this sequence"] pub struct SEQ1_CNT (u32) ; impl SEQ1_CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Amount of values (duty cycles) in this sequence"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register"] pub struct SEQ1_REFRESH (u32) ; impl SEQ1_REFRESH { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Time added after the sequence"] pub struct SEQ1_ENDDELAY (u32) ; impl SEQ1_ENDDELAY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Time added after the sequence in PWM periods"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Time added after the sequence in PWM periods"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT0 (u32) ; impl PSEL_OUT0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT1 (u32) ; impl PSEL_OUT1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT2 (u32) ; impl PSEL_OUT2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Output pin select for PWM channel 0"] pub struct PSEL_OUT3 (u32) ; impl PSEL_OUT3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spis1 { # [doc = "SPI Slave 1"] pub struct SPIS1 ; impl SPIS1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Acquire SPI semaphore"] pub struct TASKS_ACQUIRE (u32) ; impl TASKS_ACQUIRE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Release SPI semaphore, enabling the SPI slave to acquire it"] pub struct TASKS_RELEASE (u32) ; impl TASKS_RELEASE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Granted transaction completed"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore acquired"] pub struct EVENTS_ACQUIRED (u32) ; impl EVENTS_ACQUIRED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn end_acquire (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn set_end_acquire (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore status register"] pub struct SEMSTAT (u32) ; impl SEMSTAT { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Semaphore status"] pub fn semstat (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Semaphore status"] pub fn set_semstat (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status from last transaction"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX buffer over-read detected, and prevented"] pub fn overread (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TX buffer over-read detected, and prevented"] pub fn set_overread (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RX buffer overflow detected, and prevented"] pub fn overflow (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "RX buffer overflow detected, and prevented"] pub fn set_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI slave"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI slave"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI slave"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for CSN signal"] pub struct PSEL_CSN (u32) ; impl PSEL_CSN { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes received in last granted transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes received in the last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes received in the last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transmitted in last granted transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub struct DEF (u32) ; impl DEF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn def (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn set_def (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character"] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu2 { # [doc = "Event Generator Unit 2"] pub struct EGU2 ; impl EGU2 { pub const BASE_ADDR : u64 = 1073831936u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spim0 { # [doc = "Serial Peripheral Interface Master with EasyDMA 0"] pub struct SPIM0 ; impl SPIM0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Start SPI transaction"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop SPI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend SPI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume SPI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI transaction has stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer and TXD buffer reached"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of TXD buffer reached"] pub struct EVENTS_ENDTX (u32) ; impl EVENTS_ENDTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transaction started"] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and START task"] pub fn end_start (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Shortcut between END event and START task"] pub fn set_end_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPIM"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPIM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPIM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency. Accuracy depends on the HFCLK source selected."] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct RXD_LIST (u32) ; impl RXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct TXD_LIST (u32) ; impl TXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spis0 { # [doc = "SPI Slave 0"] pub struct SPIS0 ; impl SPIS0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Acquire SPI semaphore"] pub struct TASKS_ACQUIRE (u32) ; impl TASKS_ACQUIRE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Release SPI semaphore, enabling the SPI slave to acquire it"] pub struct TASKS_RELEASE (u32) ; impl TASKS_RELEASE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Granted transaction completed"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore acquired"] pub struct EVENTS_ACQUIRED (u32) ; impl EVENTS_ACQUIRED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn end_acquire (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn set_end_acquire (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore status register"] pub struct SEMSTAT (u32) ; impl SEMSTAT { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Semaphore status"] pub fn semstat (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Semaphore status"] pub fn set_semstat (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status from last transaction"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX buffer over-read detected, and prevented"] pub fn overread (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TX buffer over-read detected, and prevented"] pub fn set_overread (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RX buffer overflow detected, and prevented"] pub fn overflow (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "RX buffer overflow detected, and prevented"] pub fn set_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI slave"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI slave"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI slave"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for CSN signal"] pub struct PSEL_CSN (u32) ; impl PSEL_CSN { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes received in last granted transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes received in the last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes received in the last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transmitted in last granted transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub struct DEF (u32) ; impl DEF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn def (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn set_def (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character"] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spis2 { # [doc = "SPI Slave 2"] pub struct SPIS2 ; impl SPIS2 { pub const BASE_ADDR : u64 = 1073885184u64 ; } # [doc = "Acquire SPI semaphore"] pub struct TASKS_ACQUIRE (u32) ; impl TASKS_ACQUIRE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Release SPI semaphore, enabling the SPI slave to acquire it"] pub struct TASKS_RELEASE (u32) ; impl TASKS_RELEASE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Granted transaction completed"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore acquired"] pub struct EVENTS_ACQUIRED (u32) ; impl EVENTS_ACQUIRED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn end_acquire (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between END event and ACQUIRE task"] pub fn set_end_acquire (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn acquired (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ACQUIRED event"] pub fn set_acquired (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Semaphore status register"] pub struct SEMSTAT (u32) ; impl SEMSTAT { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Semaphore status"] pub fn semstat (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Semaphore status"] pub fn set_semstat (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status from last transaction"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX buffer over-read detected, and prevented"] pub fn overread (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TX buffer over-read detected, and prevented"] pub fn set_overread (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RX buffer overflow detected, and prevented"] pub fn overflow (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "RX buffer overflow detected, and prevented"] pub fn set_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI slave"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI slave"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI slave"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for CSN signal"] pub struct PSEL_CSN (u32) ; impl PSEL_CSN { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes received in last granted transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes received in the last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes received in the last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TXD data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transmitted in last granted transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transmitted in last granted transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub struct DEF (u32) ; impl DEF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn def (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Default character. Character clocked out in case of an ignored transaction."] pub fn set_def (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character"] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod aar { # [doc = "Accelerated Address Resolver"] pub struct AAR ; impl AAR { pub const BASE_ADDR : u64 = 1073803264u64 ; } # [doc = "Start resolving addresses based on IRKs specified in the IRK data structure"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop resolving addresses"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address resolution procedure complete"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address resolved"] pub struct EVENTS_RESOLVED (u32) ; impl EVENTS_RESOLVED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address not resolved"] pub struct EVENTS_NOTRESOLVED (u32) ; impl EVENTS_NOTRESOLVED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for RESOLVED event"] pub fn resolved (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RESOLVED event"] pub fn set_resolved (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for NOTRESOLVED event"] pub fn notresolved (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for NOTRESOLVED event"] pub fn set_notresolved (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for RESOLVED event"] pub fn resolved (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RESOLVED event"] pub fn set_resolved (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for NOTRESOLVED event"] pub fn notresolved (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for NOTRESOLVED event"] pub fn set_notresolved (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resolution status"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The IRK that was used last time an address was resolved"] pub fn status (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "The IRK that was used last time an address was resolved"] pub fn set_status (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable AAR"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable AAR"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Enable or disable AAR"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of IRKs"] pub struct NIRK (u32) ; impl NIRK { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of Identity root keys available in the IRK data structure"] pub fn nirk (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Number of Identity root keys available in the IRK data structure"] pub fn set_nirk (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pointer to IRK data structure"] pub struct IRKPTR (u32) ; impl IRKPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to the IRK data structure"] pub fn irkptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to the IRK data structure"] pub fn set_irkptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pointer to the resolvable address"] pub struct ADDRPTR (u32) ; impl ADDRPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to the resolvable address (6-bytes)"] pub fn addrptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to the resolvable address (6-bytes)"] pub fn set_addrptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pointer to data area used for temporary storage"] pub struct SCRATCHPTR (u32) ; impl SCRATCHPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to a scratch data area used for temporary storage during resolution.A space of minimum 3 bytes must be reserved."] pub fn scratchptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to a scratch data area used for temporary storage during resolution.A space of minimum 3 bytes must be reserved."] pub fn set_scratchptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi3 { # [doc = "Software interrupt 3"] pub struct SWI3 ; impl SWI3 { pub const BASE_ADDR : u64 = 1073836032u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi5 { # [doc = "Software interrupt 5"] pub struct SWI5 ; impl SWI5 { pub const BASE_ADDR : u64 = 1073844224u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod power { # [doc = "Power control"] pub struct POWER ; impl POWER { pub const BASE_ADDR : u64 = 1073741824u64 ; } # [doc = "Enable constant latency mode"] pub struct TASKS_CONSTLAT (u32) ; impl TASKS_CONSTLAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable low power mode (variable latency)"] pub struct TASKS_LOWPWR (u32) ; impl TASKS_LOWPWR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Power failure warning"] pub struct EVENTS_POFWARN (u32) ; impl EVENTS_POFWARN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CPU entered WFI/WFE sleep"] pub struct EVENTS_SLEEPENTER (u32) ; impl EVENTS_SLEEPENTER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CPU exited WFI/WFE sleep"] pub struct EVENTS_SLEEPEXIT (u32) ; impl EVENTS_SLEEPEXIT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for POFWARN event"] pub fn pofwarn (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for POFWARN event"] pub fn set_pofwarn (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for SLEEPENTER event"] pub fn sleepenter (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SLEEPENTER event"] pub fn set_sleepenter (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for SLEEPEXIT event"] pub fn sleepexit (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SLEEPEXIT event"] pub fn set_sleepexit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for POFWARN event"] pub fn pofwarn (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for POFWARN event"] pub fn set_pofwarn (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for SLEEPENTER event"] pub fn sleepenter (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SLEEPENTER event"] pub fn set_sleepenter (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for SLEEPEXIT event"] pub fn sleepexit (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SLEEPEXIT event"] pub fn set_sleepexit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reset reason"] pub struct RESETREAS (u32) ; impl RESETREAS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reset from pin-reset detected"] pub fn resetpin (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Reset from pin-reset detected"] pub fn set_resetpin (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Reset from watchdog detected"] pub fn dog (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Reset from watchdog detected"] pub fn set_dog (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Reset from soft reset detected"] pub fn sreq (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Reset from soft reset detected"] pub fn set_sreq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Reset from CPU lock-up detected"] pub fn lockup (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Reset from CPU lock-up detected"] pub fn set_lockup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO"] pub fn off (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO"] pub fn set_off (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP"] pub fn lpcomp (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP"] pub fn set_lpcomp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode"] pub fn dif (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode"] pub fn set_dif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Reset due to wake up from System OFF mode by NFC field detect"] pub fn nfc (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Reset due to wake up from System OFF mode by NFC field detect"] pub fn set_nfc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  RAM status register"] pub struct RAMSTATUS (u32) ; impl RAMSTATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RAM block 0 is on or off/powering up"] pub fn ramblock0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "RAM block 0 is on or off/powering up"] pub fn set_ramblock0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "RAM block 1 is on or off/powering up"] pub fn ramblock1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "RAM block 1 is on or off/powering up"] pub fn set_ramblock1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "RAM block 2 is on or off/powering up"] pub fn ramblock2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "RAM block 2 is on or off/powering up"] pub fn set_ramblock2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "RAM block 3 is on or off/powering up"] pub fn ramblock3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "RAM block 3 is on or off/powering up"] pub fn set_ramblock3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "System OFF register"] pub struct SYSTEMOFF (u32) ; impl SYSTEMOFF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable System OFF mode"] pub fn systemoff (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable System OFF mode"] pub fn set_systemoff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Power failure comparator configuration"] pub struct POFCON (u32) ; impl POFCON { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable power failure comparator"] pub fn pof (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable power failure comparator"] pub fn set_pof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Power failure comparator threshold setting"] pub fn threshold (& self) -> u32 { (self . 0 >> 1u32) & 15u32 } # [doc = "Power failure comparator threshold setting"] pub fn set_threshold (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "General purpose retention register"] pub struct GPREGRET (u32) ; impl GPREGRET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "General purpose retention register"] pub fn gpregret (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "General purpose retention register"] pub fn set_gpregret (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "General purpose retention register"] pub struct GPREGRET2 (u32) ; impl GPREGRET2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "General purpose retention register"] pub fn gpregret (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "General purpose retention register"] pub fn set_gpregret (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  RAM on/off register (this register is retained)"] pub struct RAMON (u32) ; impl RAMON { pub const RESET_VALUE : u32 = 3u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM block 0 on or off in system ON Mode"] pub fn onram0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM block 0 on or off in system ON Mode"] pub fn set_onram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM block 1 on or off in system ON Mode"] pub fn onram1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM block 1 on or off in system ON Mode"] pub fn set_onram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM block 0 when RAM block is switched off"] pub fn offram0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM block 0 when RAM block is switched off"] pub fn set_offram0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM block 1 when RAM block is switched off"] pub fn offram1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM block 1 when RAM block is switched off"] pub fn set_offram1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  RAM on/off register (this register is retained)"] pub struct RAMONB (u32) ; impl RAMONB { pub const RESET_VALUE : u32 = 3u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM block 2 on or off in system ON Mode"] pub fn onram2 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM block 2 on or off in system ON Mode"] pub fn set_onram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM block 3 on or off in system ON Mode"] pub fn onram3 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM block 3 on or off in system ON Mode"] pub fn set_onram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM block 2 when RAM block is switched off"] pub fn offram2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM block 2 when RAM block is switched off"] pub fn set_offram2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM block 3 when RAM block is switched off"] pub fn offram3 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM block 3 when RAM block is switched off"] pub fn set_offram3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DC/DC enable register"] pub struct DCDCEN (u32) ; impl DCDCEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable DC/DC converter"] pub fn dcdcen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable DC/DC converter"] pub fn set_dcdcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM0_POWER (u32) ; impl RAM0_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM0_POWERSET (u32) ; impl RAM0_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM0_POWERCLR (u32) ; impl RAM0_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM1_POWER (u32) ; impl RAM1_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM1_POWERSET (u32) ; impl RAM1_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM1_POWERCLR (u32) ; impl RAM1_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM2_POWER (u32) ; impl RAM2_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM2_POWERSET (u32) ; impl RAM2_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM2_POWERCLR (u32) ; impl RAM2_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM3_POWER (u32) ; impl RAM3_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM3_POWERSET (u32) ; impl RAM3_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM3_POWERCLR (u32) ; impl RAM3_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM4_POWER (u32) ; impl RAM4_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM4_POWERSET (u32) ; impl RAM4_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM4_POWERCLR (u32) ; impl RAM4_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM5_POWER (u32) ; impl RAM5_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM5_POWERSET (u32) ; impl RAM5_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM5_POWERCLR (u32) ; impl RAM5_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM6_POWER (u32) ; impl RAM6_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM6_POWERSET (u32) ; impl RAM6_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM6_POWERCLR (u32) ; impl RAM6_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control register"] pub struct RAM7_POWER (u32) ; impl RAM7_POWER { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 ON or OFF in System ON mode."] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 ON or OFF in System ON mode."] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is in OFF"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is in OFF"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control set register"] pub struct RAM7_POWERSET (u32) ; impl RAM7_POWERSET { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  RAM0 power control clear register"] pub struct RAM7_POWERCLR (u32) ; impl RAM7_POWERCLR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn s0power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Keep RAM section S0 of RAM0 on or off in System ON mode"] pub fn set_s0power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn s1power (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Keep RAM section S1 of RAM0 on or off in System ON mode"] pub fn set_s1power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn s0retention (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Keep retention on RAM section S0 when RAM section is switched off"] pub fn set_s0retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn s1retention (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Keep retention on RAM section S1 when RAM section is switched off"] pub fn set_s1retention (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rng { # [doc = "Random Number Generator"] pub struct RNG ; impl RNG { pub const BASE_ADDR : u64 = 1073795072u64 ; } # [doc = "Task starting the random number generator"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Task stopping the random number generator"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event being generated for every new random number written to the VALUE register"] pub struct EVENTS_VALRDY (u32) ; impl EVENTS_VALRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between VALRDY event and STOP task"] pub fn valrdy_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between VALRDY event and STOP task"] pub fn set_valrdy_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for VALRDY event"] pub fn valrdy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for VALRDY event"] pub fn set_valrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for VALRDY event"] pub fn valrdy (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for VALRDY event"] pub fn set_valrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bias correction"] pub fn dercen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bias correction"] pub fn set_dercen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Output random number"] pub struct VALUE (u32) ; impl VALUE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Generated random number"] pub fn value (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Generated random number"] pub fn set_value (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu0 { # [doc = "Event Generator Unit 0"] pub struct EGU0 ; impl EGU0 { pub const BASE_ADDR : u64 = 1073823744u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu5 { # [doc = "Event Generator Unit 5"] pub struct EGU5 ; impl EGU5 { pub const BASE_ADDR : u64 = 1073844224u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod lpcomp { # [doc = "Low Power Comparator"] pub struct LPCOMP ; impl LPCOMP { pub const BASE_ADDR : u64 = 1073819648u64 ; } # [doc = "Start comparator"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop comparator"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sample comparator value"] pub struct TASKS_SAMPLE (u32) ; impl TASKS_SAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "LPCOMP is ready and output is valid"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Downward crossing"] pub struct EVENTS_DOWN (u32) ; impl EVENTS_DOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Upward crossing"] pub struct EVENTS_UP (u32) ; impl EVENTS_UP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Downward or upward crossing"] pub struct EVENTS_CROSS (u32) ; impl EVENTS_CROSS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between READY event and SAMPLE task"] pub fn ready_sample (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between READY event and SAMPLE task"] pub fn set_ready_sample (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between READY event and STOP task"] pub fn ready_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between READY event and STOP task"] pub fn set_ready_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between DOWN event and STOP task"] pub fn down_stop (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between DOWN event and STOP task"] pub fn set_down_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between UP event and STOP task"] pub fn up_stop (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between UP event and STOP task"] pub fn set_up_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between CROSS event and STOP task"] pub fn cross_stop (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between CROSS event and STOP task"] pub fn set_cross_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for DOWN event"] pub fn down (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DOWN event"] pub fn set_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for UP event"] pub fn up (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for UP event"] pub fn set_up (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for CROSS event"] pub fn cross (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CROSS event"] pub fn set_cross (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for DOWN event"] pub fn down (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DOWN event"] pub fn set_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for UP event"] pub fn up (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for UP event"] pub fn set_up (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for CROSS event"] pub fn cross (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CROSS event"] pub fn set_cross (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Compare result"] pub struct RESULT (u32) ; impl RESULT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Result of last compare. Decision point SAMPLE task."] pub fn result (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Result of last compare. Decision point SAMPLE task."] pub fn set_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable LPCOMP"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable LPCOMP"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Enable or disable LPCOMP"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Input pin select"] pub struct PSEL (u32) ; impl PSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog pin select"] pub fn psel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Analog pin select"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reference select"] pub struct REFSEL (u32) ; impl REFSEL { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reference select"] pub fn refsel (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Reference select"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "External reference select"] pub struct EXTREFSEL (u32) ; impl EXTREFSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "External analog reference select"] pub fn extrefsel (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "External analog reference select"] pub fn set_extrefsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Analog detect configuration"] pub struct ANADETECT (u32) ; impl ANADETECT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog detect configuration"] pub fn anadetect (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Analog detect configuration"] pub fn set_anadetect (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Comparator hysteresis enable"] pub struct HYST (u32) ; impl HYST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparator hysteresis enable"] pub fn hyst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Comparator hysteresis enable"] pub fn set_hyst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod fpu { # [doc = "FPU"] pub struct FPU ; impl FPU { pub const BASE_ADDR : u64 = 1073897472u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twim0 { # [doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"] pub struct TWIM0 ; impl TWIM0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Start TWI receive sequence"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start TWI transmit sequence"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."] pub struct EVENTS_SUSPENDED (u32) ; impl EVENTS_SUSPENDED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive sequence started"] pub struct EVENTS_RXSTARTED (u32) ; impl EVENTS_RXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit sequence started"] pub struct EVENTS_TXSTARTED (u32) ; impl EVENTS_TXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Byte boundary, starting to receive the last byte"] pub struct EVENTS_LASTRX (u32) ; impl EVENTS_LASTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Byte boundary, starting to transmit the last byte"] pub struct EVENTS_LASTTX (u32) ; impl EVENTS_LASTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between LASTTX event and STARTRX task"] pub fn lasttx_startrx (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Shortcut between LASTTX event and STARTRX task"] pub fn set_lasttx_startrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Shortcut between LASTTX event and SUSPEND task"] pub fn lasttx_suspend (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between LASTTX event and SUSPEND task"] pub fn set_lasttx_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between LASTTX event and STOP task"] pub fn lasttx_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between LASTTX event and STOP task"] pub fn set_lasttx_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between LASTRX event and STARTTX task"] pub fn lastrx_starttx (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between LASTRX event and STARTTX task"] pub fn set_lastrx_starttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between LASTRX event and STOP task"] pub fn lastrx_stop (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Shortcut between LASTRX event and STOP task"] pub fn set_lastrx_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Enable or disable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Enable or disable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable or disable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Write '1' to Enable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for LASTRX event"] pub fn lastrx (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LASTRX event"] pub fn set_lastrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Write '1' to Disable interrupt for LASTTX event"] pub fn lasttx (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LASTTX event"] pub fn set_lasttx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn anack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn set_anack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWIM"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWIM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWIM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL signal"] pub struct PSEL_SCL (u32) ; impl PSEL_SCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA signal"] pub struct PSEL_SDA (u32) ; impl PSEL_SDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI master clock frequency"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TWI master clock frequency"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct RXD_LIST (u32) ; impl RXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct TXD_LIST (u32) ; impl TXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address used in the TWI transfer"] pub struct ADDRESS (u32) ; impl ADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address used in the TWI transfer"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Address used in the TWI transfer"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rtc0 { # [doc = "Real time counter 0"] pub struct RTC0 ; impl RTC0 { pub const BASE_ADDR : u64 = 1073786880u64 ; } # [doc = "Start RTC COUNTER"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop RTC COUNTER"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RTC COUNTER"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set COUNTER to 0xFFFFF0"] pub struct TASKS_TRIGOVRFLW (u32) ; impl TASKS_TRIGOVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER increment"] pub struct EVENTS_TICK (u32) ; impl EVENTS_TICK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER overflow"] pub struct EVENTS_OVRFLW (u32) ; impl EVENTS_OVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable event routing"] pub struct EVTEN (u32) ; impl EVTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable event routing"] pub struct EVTENSET (u32) ; impl EVTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable event routing"] pub struct EVTENCLR (u32) ; impl EVTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current COUNTER value"] pub struct COUNTER (u32) ; impl COUNTER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter value"] pub fn counter (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Counter value"] pub fn set_counter (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod mwu { # [doc = "Memory Watch Unit"] pub struct MWU ; impl MWU { pub const BASE_ADDR : u64 = 1073872896u64 ; } # [doc = "Description cluster[0]:  Write access to region 0 detected"] pub struct EVENTS_REGION0_WA (u32) ; impl EVENTS_REGION0_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to region 0 detected"] pub struct EVENTS_REGION0_RA (u32) ; impl EVENTS_REGION0_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Write access to region 0 detected"] pub struct EVENTS_REGION1_WA (u32) ; impl EVENTS_REGION1_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to region 0 detected"] pub struct EVENTS_REGION1_RA (u32) ; impl EVENTS_REGION1_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Write access to region 0 detected"] pub struct EVENTS_REGION2_WA (u32) ; impl EVENTS_REGION2_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to region 0 detected"] pub struct EVENTS_REGION2_RA (u32) ; impl EVENTS_REGION2_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Write access to region 0 detected"] pub struct EVENTS_REGION3_WA (u32) ; impl EVENTS_REGION3_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to region 0 detected"] pub struct EVENTS_REGION3_RA (u32) ; impl EVENTS_REGION3_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Write access to peripheral region 0 detected"] pub struct EVENTS_PREGION0_WA (u32) ; impl EVENTS_PREGION0_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to peripheral region 0 detected"] pub struct EVENTS_PREGION0_RA (u32) ; impl EVENTS_PREGION0_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Write access to peripheral region 0 detected"] pub struct EVENTS_PREGION1_WA (u32) ; impl EVENTS_PREGION1_WA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Read access to peripheral region 0 detected"] pub struct EVENTS_PREGION1_RA (u32) ; impl EVENTS_PREGION1_RA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable or disable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable or disable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable or disable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable or disable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable or disable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable or disable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Write '1' to Enable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Enable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Write '1' to Enable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Write '1' to Disable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Disable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Write '1' to Disable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable non-maskable interrupt"] pub struct NMIEN (u32) ; impl NMIEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable non-maskable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable non-maskable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable non-maskable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable or disable non-maskable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable or disable non-maskable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable or disable non-maskable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable or disable non-maskable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable non-maskable interrupt"] pub struct NMIENSET (u32) ; impl NMIENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Write '1' to Enable non-maskable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable non-maskable interrupt"] pub struct NMIENCLR (u32) ; impl NMIENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[0].WA event"] pub fn region0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[0].WA event"] pub fn set_region0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[0].RA event"] pub fn region0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[0].RA event"] pub fn set_region0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[1].WA event"] pub fn region1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[1].WA event"] pub fn set_region1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[1].RA event"] pub fn region1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[1].RA event"] pub fn set_region1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[2].WA event"] pub fn region2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[2].WA event"] pub fn set_region2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[2].RA event"] pub fn region2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[2].RA event"] pub fn set_region2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[3].WA event"] pub fn region3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[3].WA event"] pub fn set_region3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[3].RA event"] pub fn region3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for REGION[3].RA event"] pub fn set_region3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[0].WA event"] pub fn pregion0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[0].WA event"] pub fn set_pregion0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[0].RA event"] pub fn pregion0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[0].RA event"] pub fn set_pregion0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[1].WA event"] pub fn pregion1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[1].WA event"] pub fn set_pregion1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[1].RA event"] pub fn pregion1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Write '1' to Disable non-maskable interrupt for PREGION[1].RA event"] pub fn set_pregion1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching"] pub struct PERREGION0_SUBSTATWA (u32) ; impl PERREGION0_SUBSTATWA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching"] pub struct PERREGION0_SUBSTATRA (u32) ; impl PERREGION0_SUBSTATRA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching"] pub struct PERREGION1_SUBSTATWA (u32) ; impl PERREGION1_SUBSTATWA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching"] pub struct PERREGION1_SUBSTATRA (u32) ; impl PERREGION1_SUBSTATRA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Subregion 0 in region 0 (write '1' to clear)"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Subregion 1 in region 0 (write '1' to clear)"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Subregion 2 in region 0 (write '1' to clear)"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Subregion 3 in region 0 (write '1' to clear)"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Subregion 4 in region 0 (write '1' to clear)"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Subregion 5 in region 0 (write '1' to clear)"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Subregion 6 in region 0 (write '1' to clear)"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Subregion 7 in region 0 (write '1' to clear)"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Subregion 8 in region 0 (write '1' to clear)"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Subregion 9 in region 0 (write '1' to clear)"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Subregion 10 in region 0 (write '1' to clear)"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Subregion 11 in region 0 (write '1' to clear)"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Subregion 12 in region 0 (write '1' to clear)"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Subregion 13 in region 0 (write '1' to clear)"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Subregion 14 in region 0 (write '1' to clear)"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Subregion 15 in region 0 (write '1' to clear)"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Subregion 16 in region 0 (write '1' to clear)"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Subregion 17 in region 0 (write '1' to clear)"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Subregion 18 in region 0 (write '1' to clear)"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Subregion 19 in region 0 (write '1' to clear)"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Subregion 20 in region 0 (write '1' to clear)"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Subregion 21 in region 0 (write '1' to clear)"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Subregion 22 in region 0 (write '1' to clear)"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Subregion 23 in region 0 (write '1' to clear)"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Subregion 24 in region 0 (write '1' to clear)"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Subregion 25 in region 0 (write '1' to clear)"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Subregion 26 in region 0 (write '1' to clear)"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Subregion 27 in region 0 (write '1' to clear)"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Subregion 28 in region 0 (write '1' to clear)"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Subregion 29 in region 0 (write '1' to clear)"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Subregion 30 in region 0 (write '1' to clear)"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Subregion 31 in region 0 (write '1' to clear)"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable/disable regions watch"] pub struct REGIONEN (u32) ; impl REGIONEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable/disable write access watch in region[0]"] pub fn rgn0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable/disable write access watch in region[0]"] pub fn set_rgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable/disable read access watch in region[0]"] pub fn rgn0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable/disable read access watch in region[0]"] pub fn set_rgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable/disable write access watch in region[1]"] pub fn rgn1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable/disable write access watch in region[1]"] pub fn set_rgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable/disable read access watch in region[1]"] pub fn rgn1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable/disable read access watch in region[1]"] pub fn set_rgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable/disable write access watch in region[2]"] pub fn rgn2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable/disable write access watch in region[2]"] pub fn set_rgn2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable/disable read access watch in region[2]"] pub fn rgn2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable/disable read access watch in region[2]"] pub fn set_rgn2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable/disable write access watch in region[3]"] pub fn rgn3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable/disable write access watch in region[3]"] pub fn set_rgn3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable/disable read access watch in region[3]"] pub fn rgn3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable/disable read access watch in region[3]"] pub fn set_rgn3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable/disable write access watch in PREGION[0]"] pub fn prgn0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable/disable write access watch in PREGION[0]"] pub fn set_prgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable/disable read access watch in PREGION[0]"] pub fn prgn0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable/disable read access watch in PREGION[0]"] pub fn set_prgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable/disable write access watch in PREGION[1]"] pub fn prgn1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable/disable write access watch in PREGION[1]"] pub fn set_prgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable/disable read access watch in PREGION[1]"] pub fn prgn1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable/disable read access watch in PREGION[1]"] pub fn set_prgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable regions watch"] pub struct REGIONENSET (u32) ; impl REGIONENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable write access watch in region[0]"] pub fn rgn0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable write access watch in region[0]"] pub fn set_rgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable read access watch in region[0]"] pub fn rgn0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable read access watch in region[0]"] pub fn set_rgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable write access watch in region[1]"] pub fn rgn1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable write access watch in region[1]"] pub fn set_rgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable read access watch in region[1]"] pub fn rgn1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable read access watch in region[1]"] pub fn set_rgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable write access watch in region[2]"] pub fn rgn2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable write access watch in region[2]"] pub fn set_rgn2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable read access watch in region[2]"] pub fn rgn2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable read access watch in region[2]"] pub fn set_rgn2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable write access watch in region[3]"] pub fn rgn3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable write access watch in region[3]"] pub fn set_rgn3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable read access watch in region[3]"] pub fn rgn3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable read access watch in region[3]"] pub fn set_rgn3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable write access watch in PREGION[0]"] pub fn prgn0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable write access watch in PREGION[0]"] pub fn set_prgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable read access watch in PREGION[0]"] pub fn prgn0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable read access watch in PREGION[0]"] pub fn set_prgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable write access watch in PREGION[1]"] pub fn prgn1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable write access watch in PREGION[1]"] pub fn set_prgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Enable read access watch in PREGION[1]"] pub fn prgn1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Enable read access watch in PREGION[1]"] pub fn set_prgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable regions watch"] pub struct REGIONENCLR (u32) ; impl REGIONENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Disable write access watch in region[0]"] pub fn rgn0wa (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Disable write access watch in region[0]"] pub fn set_rgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Disable read access watch in region[0]"] pub fn rgn0ra (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Disable read access watch in region[0]"] pub fn set_rgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Disable write access watch in region[1]"] pub fn rgn1wa (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Disable write access watch in region[1]"] pub fn set_rgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Disable read access watch in region[1]"] pub fn rgn1ra (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Disable read access watch in region[1]"] pub fn set_rgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Disable write access watch in region[2]"] pub fn rgn2wa (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Disable write access watch in region[2]"] pub fn set_rgn2wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Disable read access watch in region[2]"] pub fn rgn2ra (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Disable read access watch in region[2]"] pub fn set_rgn2ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Disable write access watch in region[3]"] pub fn rgn3wa (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Disable write access watch in region[3]"] pub fn set_rgn3wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Disable read access watch in region[3]"] pub fn rgn3ra (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Disable read access watch in region[3]"] pub fn set_rgn3ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Disable write access watch in PREGION[0]"] pub fn prgn0wa (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Disable write access watch in PREGION[0]"] pub fn set_prgn0wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Disable read access watch in PREGION[0]"] pub fn prgn0ra (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Disable read access watch in PREGION[0]"] pub fn set_prgn0ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Disable write access watch in PREGION[1]"] pub fn prgn1wa (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Disable write access watch in PREGION[1]"] pub fn set_prgn1wa (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Disable read access watch in PREGION[1]"] pub fn prgn1ra (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Disable read access watch in PREGION[1]"] pub fn set_prgn1ra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Start address for region 0"] pub struct REGION0_START (u32) ; impl REGION0_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start address for region"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Start address for region"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  End address of region 0"] pub struct REGION0_END (u32) ; impl REGION0_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End address of region."] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "End address of region."] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Start address for region 0"] pub struct REGION1_START (u32) ; impl REGION1_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start address for region"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Start address for region"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  End address of region 0"] pub struct REGION1_END (u32) ; impl REGION1_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End address of region."] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "End address of region."] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Start address for region 0"] pub struct REGION2_START (u32) ; impl REGION2_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start address for region"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Start address for region"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  End address of region 0"] pub struct REGION2_END (u32) ; impl REGION2_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End address of region."] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "End address of region."] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Start address for region 0"] pub struct REGION3_START (u32) ; impl REGION3_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start address for region"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Start address for region"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  End address of region 0"] pub struct REGION3_END (u32) ; impl REGION3_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End address of region."] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "End address of region."] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Reserved for future use"] pub struct PREGION0_START (u32) ; impl PREGION0_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for future use"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for future use"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Reserved for future use"] pub struct PREGION0_END (u32) ; impl PREGION0_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for future use"] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for future use"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Subregions of region 0"] pub struct PREGION0_SUBS (u32) ; impl PREGION0_SUBS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude subregion 0 in region"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude subregion 0 in region"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude subregion 1 in region"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude subregion 1 in region"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude subregion 2 in region"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude subregion 2 in region"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude subregion 3 in region"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude subregion 3 in region"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude subregion 4 in region"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude subregion 4 in region"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude subregion 5 in region"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude subregion 5 in region"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude subregion 6 in region"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude subregion 6 in region"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude subregion 7 in region"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude subregion 7 in region"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude subregion 8 in region"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude subregion 8 in region"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude subregion 9 in region"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude subregion 9 in region"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude subregion 10 in region"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude subregion 10 in region"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude subregion 11 in region"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude subregion 11 in region"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude subregion 12 in region"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude subregion 12 in region"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude subregion 13 in region"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude subregion 13 in region"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude subregion 14 in region"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude subregion 14 in region"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude subregion 15 in region"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude subregion 15 in region"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude subregion 16 in region"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude subregion 16 in region"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude subregion 17 in region"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude subregion 17 in region"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude subregion 18 in region"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude subregion 18 in region"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude subregion 19 in region"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude subregion 19 in region"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude subregion 20 in region"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude subregion 20 in region"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude subregion 21 in region"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude subregion 21 in region"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude subregion 22 in region"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude subregion 22 in region"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude subregion 23 in region"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude subregion 23 in region"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude subregion 24 in region"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude subregion 24 in region"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude subregion 25 in region"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude subregion 25 in region"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude subregion 26 in region"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude subregion 26 in region"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude subregion 27 in region"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude subregion 27 in region"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude subregion 28 in region"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude subregion 28 in region"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude subregion 29 in region"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude subregion 29 in region"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude subregion 30 in region"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude subregion 30 in region"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude subregion 31 in region"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude subregion 31 in region"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Reserved for future use"] pub struct PREGION1_START (u32) ; impl PREGION1_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for future use"] pub fn start (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for future use"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Reserved for future use"] pub struct PREGION1_END (u32) ; impl PREGION1_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for future use"] pub fn end (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Reserved for future use"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Subregions of region 0"] pub struct PREGION1_SUBS (u32) ; impl PREGION1_SUBS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Include or exclude subregion 0 in region"] pub fn sr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Include or exclude subregion 0 in region"] pub fn set_sr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude subregion 1 in region"] pub fn sr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Include or exclude subregion 1 in region"] pub fn set_sr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Include or exclude subregion 2 in region"] pub fn sr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Include or exclude subregion 2 in region"] pub fn set_sr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Include or exclude subregion 3 in region"] pub fn sr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Include or exclude subregion 3 in region"] pub fn set_sr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Include or exclude subregion 4 in region"] pub fn sr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Include or exclude subregion 4 in region"] pub fn set_sr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Include or exclude subregion 5 in region"] pub fn sr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Include or exclude subregion 5 in region"] pub fn set_sr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Include or exclude subregion 6 in region"] pub fn sr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Include or exclude subregion 6 in region"] pub fn set_sr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Include or exclude subregion 7 in region"] pub fn sr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Include or exclude subregion 7 in region"] pub fn set_sr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Include or exclude subregion 8 in region"] pub fn sr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude subregion 8 in region"] pub fn set_sr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Include or exclude subregion 9 in region"] pub fn sr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Include or exclude subregion 9 in region"] pub fn set_sr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Include or exclude subregion 10 in region"] pub fn sr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Include or exclude subregion 10 in region"] pub fn set_sr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Include or exclude subregion 11 in region"] pub fn sr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Include or exclude subregion 11 in region"] pub fn set_sr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Include or exclude subregion 12 in region"] pub fn sr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Include or exclude subregion 12 in region"] pub fn set_sr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Include or exclude subregion 13 in region"] pub fn sr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Include or exclude subregion 13 in region"] pub fn set_sr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Include or exclude subregion 14 in region"] pub fn sr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Include or exclude subregion 14 in region"] pub fn set_sr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Include or exclude subregion 15 in region"] pub fn sr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Include or exclude subregion 15 in region"] pub fn set_sr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Include or exclude subregion 16 in region"] pub fn sr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Include or exclude subregion 16 in region"] pub fn set_sr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude subregion 17 in region"] pub fn sr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Include or exclude subregion 17 in region"] pub fn set_sr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Include or exclude subregion 18 in region"] pub fn sr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Include or exclude subregion 18 in region"] pub fn set_sr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Include or exclude subregion 19 in region"] pub fn sr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Include or exclude subregion 19 in region"] pub fn set_sr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Include or exclude subregion 20 in region"] pub fn sr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude subregion 20 in region"] pub fn set_sr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Include or exclude subregion 21 in region"] pub fn sr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Include or exclude subregion 21 in region"] pub fn set_sr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Include or exclude subregion 22 in region"] pub fn sr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Include or exclude subregion 22 in region"] pub fn set_sr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Include or exclude subregion 23 in region"] pub fn sr23 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Include or exclude subregion 23 in region"] pub fn set_sr23 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Include or exclude subregion 24 in region"] pub fn sr24 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Include or exclude subregion 24 in region"] pub fn set_sr24 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Include or exclude subregion 25 in region"] pub fn sr25 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Include or exclude subregion 25 in region"] pub fn set_sr25 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Include or exclude subregion 26 in region"] pub fn sr26 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Include or exclude subregion 26 in region"] pub fn set_sr26 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Include or exclude subregion 27 in region"] pub fn sr27 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Include or exclude subregion 27 in region"] pub fn set_sr27 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Include or exclude subregion 28 in region"] pub fn sr28 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Include or exclude subregion 28 in region"] pub fn set_sr28 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Include or exclude subregion 29 in region"] pub fn sr29 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Include or exclude subregion 29 in region"] pub fn set_sr29 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Include or exclude subregion 30 in region"] pub fn sr30 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Include or exclude subregion 30 in region"] pub fn set_sr30 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Include or exclude subregion 31 in region"] pub fn sr31 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Include or exclude subregion 31 in region"] pub fn set_sr31 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi0 { # [doc = "Software interrupt 0"] pub struct SWI0 ; impl SWI0 { pub const BASE_ADDR : u64 = 1073823744u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi0 { # [doc = "Serial Peripheral Interface 0"] pub struct SPI0 ; impl SPI0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "TXD byte sent and RXD byte received"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI SCK signal"] pub fn pselsck (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI SCK signal"] pub fn set_pselsck (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn pselmosi (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn set_pselmosi (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MISO signal"] pub fn pselmiso (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MISO signal"] pub fn set_pselmiso (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX data received. Double buffered"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RX data received. Double buffered"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX data to send. Double buffered"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TX data to send. Double buffered"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spim1 { # [doc = "Serial Peripheral Interface Master with EasyDMA 1"] pub struct SPIM1 ; impl SPIM1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Start SPI transaction"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop SPI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend SPI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume SPI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI transaction has stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer reached"] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of RXD buffer and TXD buffer reached"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "End of TXD buffer reached"] pub struct EVENTS_ENDTX (u32) ; impl EVENTS_ENDTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transaction started"] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between END event and START task"] pub fn end_start (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Shortcut between END event and START task"] pub fn set_end_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPIM"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPIM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPIM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI signal"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO signal"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency. Accuracy depends on the HFCLK source selected."] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in receive buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in receive buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in receive buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct RXD_LIST (u32) ; impl RXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in transmit buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in transmit buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in transmit buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA list type"] pub struct TXD_LIST (u32) ; impl TXD_LIST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "List type"] pub fn list (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "List type"] pub fn set_list (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character clocked out in case and over-read of the TXD buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rtc2 { # [doc = "Real time counter 2"] pub struct RTC2 ; impl RTC2 { pub const BASE_ADDR : u64 = 1073889280u64 ; } # [doc = "Start RTC COUNTER"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop RTC COUNTER"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RTC COUNTER"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set COUNTER to 0xFFFFF0"] pub struct TASKS_TRIGOVRFLW (u32) ; impl TASKS_TRIGOVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER increment"] pub struct EVENTS_TICK (u32) ; impl EVENTS_TICK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER overflow"] pub struct EVENTS_OVRFLW (u32) ; impl EVENTS_OVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable event routing"] pub struct EVTEN (u32) ; impl EVTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable event routing"] pub struct EVTENSET (u32) ; impl EVTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable event routing"] pub struct EVTENCLR (u32) ; impl EVTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current COUNTER value"] pub struct COUNTER (u32) ; impl COUNTER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter value"] pub fn counter (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Counter value"] pub fn set_counter (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi2 { # [doc = "Serial Peripheral Interface 2"] pub struct SPI2 ; impl SPI2 { pub const BASE_ADDR : u64 = 1073885184u64 ; } # [doc = "TXD byte sent and RXD byte received"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable SPI"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable SPI"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable SPI"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCK"] pub struct PSEL_SCK (u32) ; impl PSEL_SCK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI SCK signal"] pub fn pselsck (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI SCK signal"] pub fn set_pselsck (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MOSI"] pub struct PSEL_MOSI (u32) ; impl PSEL_MOSI { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn pselmosi (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MOSI signal"] pub fn set_pselmosi (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for MISO"] pub struct PSEL_MISO (u32) ; impl PSEL_MISO { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for SPI MISO signal"] pub fn pselmiso (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for SPI MISO signal"] pub fn set_pselmiso (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX data received. Double buffered"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RX data received. Double buffered"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX data to send. Double buffered"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TX data to send. Double buffered"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SPI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "SPI master data rate"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "SPI master data rate"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit order"] pub fn order (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Bit order"] pub fn set_order (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Serial clock (SCK) phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Serial clock (SCK) phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Serial clock (SCK) polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Serial clock (SCK) polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpiote { # [doc = "GPIO Tasks and Events"] pub struct GPIOTE ; impl GPIOTE { pub const BASE_ADDR : u64 = 1073766400u64 ; } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT0 (u32) ; impl TASKS_OUT0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT1 (u32) ; impl TASKS_OUT1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT2 (u32) ; impl TASKS_OUT2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT3 (u32) ; impl TASKS_OUT3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT4 (u32) ; impl TASKS_OUT4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT5 (u32) ; impl TASKS_OUT5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT6 (u32) ; impl TASKS_OUT6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is configured in CONFIG[0].POLARITY."] pub struct TASKS_OUT7 (u32) ; impl TASKS_OUT7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET0 (u32) ; impl TASKS_SET0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET1 (u32) ; impl TASKS_SET1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET2 (u32) ; impl TASKS_SET2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET3 (u32) ; impl TASKS_SET3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET4 (u32) ; impl TASKS_SET4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET5 (u32) ; impl TASKS_SET5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET6 (u32) ; impl TASKS_SET6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it high."] pub struct TASKS_SET7 (u32) ; impl TASKS_SET7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR0 (u32) ; impl TASKS_CLR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR1 (u32) ; impl TASKS_CLR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR2 (u32) ; impl TASKS_CLR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR3 (u32) ; impl TASKS_CLR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR4 (u32) ; impl TASKS_CLR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR5 (u32) ; impl TASKS_CLR5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR6 (u32) ; impl TASKS_CLR6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Task for writing to pin specified in CONFIG[0].PSEL. Action on pin is to set it low."] pub struct TASKS_CLR7 (u32) ; impl TASKS_CLR7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN0 (u32) ; impl EVENTS_IN0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN1 (u32) ; impl EVENTS_IN1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN2 (u32) ; impl EVENTS_IN2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN3 (u32) ; impl EVENTS_IN3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN4 (u32) ; impl EVENTS_IN4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN5 (u32) ; impl EVENTS_IN5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN6 (u32) ; impl EVENTS_IN6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event generated from pin specified in CONFIG[0].PSEL"] pub struct EVENTS_IN7 (u32) ; impl EVENTS_IN7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event generated from multiple input GPIO pins with SENSE mechanism enabled"] pub struct EVENTS_PORT (u32) ; impl EVENTS_PORT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for IN[0] event"] pub fn in0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[0] event"] pub fn set_in0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for IN[1] event"] pub fn in1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[1] event"] pub fn set_in1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for IN[2] event"] pub fn in2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[2] event"] pub fn set_in2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for IN[3] event"] pub fn in3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[3] event"] pub fn set_in3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for IN[4] event"] pub fn in4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[4] event"] pub fn set_in4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for IN[5] event"] pub fn in5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[5] event"] pub fn set_in5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for IN[6] event"] pub fn in6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[6] event"] pub fn set_in6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for IN[7] event"] pub fn in7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for IN[7] event"] pub fn set_in7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for PORT event"] pub fn port (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PORT event"] pub fn set_port (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for IN[0] event"] pub fn in0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[0] event"] pub fn set_in0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for IN[1] event"] pub fn in1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[1] event"] pub fn set_in1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for IN[2] event"] pub fn in2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[2] event"] pub fn set_in2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for IN[3] event"] pub fn in3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[3] event"] pub fn set_in3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for IN[4] event"] pub fn in4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[4] event"] pub fn set_in4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for IN[5] event"] pub fn in5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[5] event"] pub fn set_in5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for IN[6] event"] pub fn in6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[6] event"] pub fn set_in6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for IN[7] event"] pub fn in7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for IN[7] event"] pub fn set_in7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for PORT event"] pub fn port (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PORT event"] pub fn set_port (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG0 (u32) ; impl CONFIG0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG1 (u32) ; impl CONFIG1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG2 (u32) ; impl CONFIG2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG3 (u32) ; impl CONFIG3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG4 (u32) ; impl CONFIG4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG5 (u32) ; impl CONFIG5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG6 (u32) ; impl CONFIG6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event"] pub struct CONFIG7 (u32) ; impl CONFIG7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn psel (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn polarity (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event."] pub fn set_polarity (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn outinit (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."] pub fn set_outinit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ficr { # [doc = "Factory Information Configuration Registers"] pub struct FICR ; impl FICR { pub const BASE_ADDR : u64 = 268435456u64 ; } # [doc = "Code memory page size"] pub struct CODEPAGESIZE (u32) ; impl CODEPAGESIZE { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Code memory page size"] pub fn codepagesize (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Code memory page size"] pub fn set_codepagesize (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Code memory size"] pub struct CODESIZE (u32) ; impl CODESIZE { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Code memory size in number of pages"] pub fn codesize (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Code memory size in number of pages"] pub fn set_codesize (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device identifier"] pub struct DEVICEID0 (u32) ; impl DEVICEID0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 bit unique device identifier"] pub fn deviceid (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "64 bit unique device identifier"] pub fn set_deviceid (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device identifier"] pub struct DEVICEID1 (u32) ; impl DEVICEID1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "64 bit unique device identifier"] pub fn deviceid (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "64 bit unique device identifier"] pub fn set_deviceid (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Encryption Root, word 0"] pub struct ER0 (u32) ; impl ER0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Encryption Root, word n"] pub fn er (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Encryption Root, word n"] pub fn set_er (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Encryption Root, word 0"] pub struct ER1 (u32) ; impl ER1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Encryption Root, word n"] pub fn er (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Encryption Root, word n"] pub fn set_er (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Encryption Root, word 0"] pub struct ER2 (u32) ; impl ER2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Encryption Root, word n"] pub fn er (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Encryption Root, word n"] pub fn set_er (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Encryption Root, word 0"] pub struct ER3 (u32) ; impl ER3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Encryption Root, word n"] pub fn er (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Encryption Root, word n"] pub fn set_er (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Identity Root, word 0"] pub struct IR0 (u32) ; impl IR0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Identity Root, word n"] pub fn ir (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Identity Root, word n"] pub fn set_ir (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Identity Root, word 0"] pub struct IR1 (u32) ; impl IR1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Identity Root, word n"] pub fn ir (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Identity Root, word n"] pub fn set_ir (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Identity Root, word 0"] pub struct IR2 (u32) ; impl IR2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Identity Root, word n"] pub fn ir (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Identity Root, word n"] pub fn set_ir (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Identity Root, word 0"] pub struct IR3 (u32) ; impl IR3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Identity Root, word n"] pub fn ir (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Identity Root, word n"] pub fn set_ir (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device address type"] pub struct DEVICEADDRTYPE (u32) ; impl DEVICEADDRTYPE { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address type"] pub fn deviceaddrtype (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Device address type"] pub fn set_deviceaddrtype (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address 0"] pub struct DEVICEADDR0 (u32) ; impl DEVICEADDR0 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "48 bit device address"] pub fn deviceaddr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "48 bit device address"] pub fn set_deviceaddr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address 0"] pub struct DEVICEADDR1 (u32) ; impl DEVICEADDR1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "48 bit device address"] pub fn deviceaddr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "48 bit device address"] pub fn set_deviceaddr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Part code"] pub struct INFO_PART (u32) ; impl INFO_PART { pub const RESET_VALUE : u32 = 337970u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Part code"] pub fn part (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Part code"] pub fn set_part (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Part Variant, Hardware version and Production configuration"] pub struct INFO_VARIANT (u32) ; impl INFO_VARIANT { pub const RESET_VALUE : u32 = 1094795586u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"] pub fn variant (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"] pub fn set_variant (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Package option"] pub struct INFO_PACKAGE (u32) ; impl INFO_PACKAGE { pub const RESET_VALUE : u32 = 8192u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Package option"] pub fn package (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Package option"] pub fn set_package (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RAM variant"] pub struct INFO_RAM (u32) ; impl INFO_RAM { pub const RESET_VALUE : u32 = 64u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RAM variant"] pub fn ram (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RAM variant"] pub fn set_ram (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flash variant"] pub struct INFO_FLASH (u32) ; impl INFO_FLASH { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Flash variant"] pub fn flash (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Flash variant"] pub fn set_flash (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]: Unspecified"] pub struct INFO_UNUSED00 (u32) ; impl INFO_UNUSED00 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]: Unspecified"] pub struct INFO_UNUSED01 (u32) ; impl INFO_UNUSED01 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]: Unspecified"] pub struct INFO_UNUSED02 (u32) ; impl INFO_UNUSED02 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A0."] pub struct TEMP_A0 (u32) ; impl TEMP_A0 { pub const RESET_VALUE : u32 = 800u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A1."] pub struct TEMP_A1 (u32) ; impl TEMP_A1 { pub const RESET_VALUE : u32 = 835u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A2."] pub struct TEMP_A2 (u32) ; impl TEMP_A2 { pub const RESET_VALUE : u32 = 861u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A3."] pub struct TEMP_A3 (u32) ; impl TEMP_A3 { pub const RESET_VALUE : u32 = 1024u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A4."] pub struct TEMP_A4 (u32) ; impl TEMP_A4 { pub const RESET_VALUE : u32 = 1106u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Slope definition A5."] pub struct TEMP_A5 (u32) ; impl TEMP_A5 { pub const RESET_VALUE : u32 = 891u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A (slope definition) register."] pub fn a (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "A (slope definition) register."] pub fn set_a (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B0."] pub struct TEMP_B0 (u32) ; impl TEMP_B0 { pub const RESET_VALUE : u32 = 16332u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B1."] pub struct TEMP_B1 (u32) ; impl TEMP_B1 { pub const RESET_VALUE : u32 = 16280u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B2."] pub struct TEMP_B2 (u32) ; impl TEMP_B2 { pub const RESET_VALUE : u32 = 16280u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B3."] pub struct TEMP_B3 (u32) ; impl TEMP_B3 { pub const RESET_VALUE : u32 = 18u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B4."] pub struct TEMP_B4 (u32) ; impl TEMP_B4 { pub const RESET_VALUE : u32 = 77u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "y-intercept B5."] pub struct TEMP_B5 (u32) ; impl TEMP_B5 { pub const RESET_VALUE : u32 = 15888u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "B (y-intercept)"] pub fn b (& self) -> u32 { (self . 0 >> 0u32) & 16383u32 } # [doc = "B (y-intercept)"] pub fn set_b (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Segment end T0."] pub struct TEMP_T0 (u32) ; impl TEMP_T0 { pub const RESET_VALUE : u32 = 226u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "T (segment end)register."] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "T (segment end)register."] pub fn set_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Segment end T1."] pub struct TEMP_T1 (u32) ; impl TEMP_T1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "T (segment end)register."] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "T (segment end)register."] pub fn set_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Segment end T2."] pub struct TEMP_T2 (u32) ; impl TEMP_T2 { pub const RESET_VALUE : u32 = 20u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "T (segment end)register."] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "T (segment end)register."] pub fn set_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Segment end T3."] pub struct TEMP_T3 (u32) ; impl TEMP_T3 { pub const RESET_VALUE : u32 = 25u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "T (segment end)register."] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "T (segment end)register."] pub fn set_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Segment end T4."] pub struct TEMP_T4 (u32) ; impl TEMP_T4 { pub const RESET_VALUE : u32 = 80u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "T (segment end)register."] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "T (segment end)register."] pub fn set_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."] pub struct NFC_TAGHEADER0 (u32) ; impl NFC_TAGHEADER0 { pub const RESET_VALUE : u32 = 4294967135u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"] pub fn mfgid (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"] pub fn set_mfgid (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Unique identifier byte 1"] pub fn ud1 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Unique identifier byte 1"] pub fn set_ud1 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Unique identifier byte 2"] pub fn ud2 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Unique identifier byte 2"] pub fn set_ud2 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Unique identifier byte 3"] pub fn ud3 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Unique identifier byte 3"] pub fn set_ud3 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."] pub struct NFC_TAGHEADER1 (u32) ; impl NFC_TAGHEADER1 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Unique identifier byte 4"] pub fn ud4 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Unique identifier byte 4"] pub fn set_ud4 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Unique identifier byte 5"] pub fn ud5 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Unique identifier byte 5"] pub fn set_ud5 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Unique identifier byte 6"] pub fn ud6 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Unique identifier byte 6"] pub fn set_ud6 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Unique identifier byte 7"] pub fn ud7 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Unique identifier byte 7"] pub fn set_ud7 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."] pub struct NFC_TAGHEADER2 (u32) ; impl NFC_TAGHEADER2 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Unique identifier byte 8"] pub fn ud8 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Unique identifier byte 8"] pub fn set_ud8 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Unique identifier byte 9"] pub fn ud9 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Unique identifier byte 9"] pub fn set_ud9 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Unique identifier byte 10"] pub fn ud10 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Unique identifier byte 10"] pub fn set_ud10 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Unique identifier byte 11"] pub fn ud11 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Unique identifier byte 11"] pub fn set_ud11 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."] pub struct NFC_TAGHEADER3 (u32) ; impl NFC_TAGHEADER3 { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Unique identifier byte 12"] pub fn ud12 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Unique identifier byte 12"] pub fn set_ud12 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Unique identifier byte 13"] pub fn ud13 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Unique identifier byte 13"] pub fn set_ud13 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Unique identifier byte 14"] pub fn ud14 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Unique identifier byte 14"] pub fn set_ud14 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Unique identifier byte 15"] pub fn ud15 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Unique identifier byte 15"] pub fn set_ud15 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer2 { # [doc = "Timer/Counter 2"] pub struct TIMER2 ; impl TIMER2 { pub const BASE_ADDR : u64 = 1073782784u64 ; } # [doc = "Start Timer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop Timer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Increment Timer (Counter mode only)"] pub struct TASKS_COUNT (u32) ; impl TASKS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear time"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Shut down timer"] pub struct TASKS_SHUTDOWN (u32) ; impl TASKS_SHUTDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE0 (u32) ; impl TASKS_CAPTURE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE1 (u32) ; impl TASKS_CAPTURE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE2 (u32) ; impl TASKS_CAPTURE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE3 (u32) ; impl TASKS_CAPTURE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn compare0_clear (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn set_compare0_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn compare1_clear (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn set_compare1_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn compare2_clear (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn set_compare2_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn compare3_clear (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn set_compare3_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn compare0_stop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn set_compare0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn compare1_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn set_compare1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn compare2_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn set_compare2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn compare3_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn set_compare3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer mode selection"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configure the number of bits used by the TIMER"] pub struct BITMODE (u32) ; impl BITMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer bit width"] pub fn bitmode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer bit width"] pub fn set_bitmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer prescaler register"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu1 { # [doc = "Event Generator Unit 1"] pub struct EGU1 ; impl EGU1 { pub const BASE_ADDR : u64 = 1073827840u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twis0 { # [doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"] pub struct TWIS0 ; impl TWIS0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Stop TWI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prepare the TWI slave to respond to a write command"] pub struct TASKS_PREPARERX (u32) ; impl TASKS_PREPARERX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prepare the TWI slave to respond to a read command"] pub struct TASKS_PREPARETX (u32) ; impl TASKS_PREPARETX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive sequence started"] pub struct EVENTS_RXSTARTED (u32) ; impl EVENTS_RXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit sequence started"] pub struct EVENTS_TXSTARTED (u32) ; impl EVENTS_TXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write command received"] pub struct EVENTS_WRITE (u32) ; impl EVENTS_WRITE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read command received"] pub struct EVENTS_READ (u32) ; impl EVENTS_READ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between WRITE event and SUSPEND task"] pub fn write_suspend (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Shortcut between WRITE event and SUSPEND task"] pub fn set_write_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Shortcut between READ event and SUSPEND task"] pub fn read_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Shortcut between READ event and SUSPEND task"] pub fn set_read_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable or disable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable or disable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Enable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Disable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX buffer overflow detected, and prevented"] pub fn overflow (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "RX buffer overflow detected, and prevented"] pub fn set_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK sent after receiving a data byte"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK sent after receiving a data byte"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TX buffer over-read detected, and prevented"] pub fn overread (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TX buffer over-read detected, and prevented"] pub fn set_overread (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register indicating which address had a match"] pub struct MATCH (u32) ; impl MATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Which of the addresses in {ADDRESS} matched the incoming address"] pub fn r#match (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Which of the addresses in {ADDRESS} matched the incoming address"] pub fn set_match (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWIS"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWIS"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWIS"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL signal"] pub struct PSEL_SCL (u32) ; impl PSEL_SCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA signal"] pub struct PSEL_SDA (u32) ; impl PSEL_SDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RXD Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in RXD buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in RXD buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in RXD buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last RXD transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last RXD transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last RXD transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TXD Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in TXD buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in TXD buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in TXD buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last TXD transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last TXD transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last TXD transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  TWI slave address 0"] pub struct ADDRESS0 (u32) ; impl ADDRESS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI slave address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "TWI slave address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  TWI slave address 0"] pub struct ADDRESS1 (u32) ; impl ADDRESS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI slave address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "TWI slave address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register for the address match mechanism"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable address matching on ADDRESS[0]"] pub fn address0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable address matching on ADDRESS[0]"] pub fn set_address0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable address matching on ADDRESS[1]"] pub fn address1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable address matching on ADDRESS[1]"] pub fn set_address1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ecb { # [doc = "AES ECB Mode Encryption"] pub struct ECB ; impl ECB { pub const BASE_ADDR : u64 = 1073799168u64 ; } # [doc = "Start ECB block encrypt"] pub struct TASKS_STARTECB (u32) ; impl TASKS_STARTECB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Abort a possible executing ECB operation"] pub struct TASKS_STOPECB (u32) ; impl TASKS_STOPECB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "ECB block encrypt complete"] pub struct EVENTS_ENDECB (u32) ; impl EVENTS_ENDECB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "ECB block encrypt aborted because of a STOPECB task or due to an error"] pub struct EVENTS_ERRORECB (u32) ; impl EVENTS_ERRORECB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for ENDECB event"] pub fn endecb (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDECB event"] pub fn set_endecb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for ERRORECB event"] pub fn errorecb (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERRORECB event"] pub fn set_errorecb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for ENDECB event"] pub fn endecb (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDECB event"] pub fn set_endecb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for ERRORECB event"] pub fn errorecb (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERRORECB event"] pub fn set_errorecb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "ECB block encrypt memory pointers"] pub struct ECBDATAPTR (u32) ; impl ECBDATAPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to the ECB data structure (see Table 1 ECB data structure overview)"] pub fn ecbdataptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to the ECB data structure (see Table 1 ECB data structure overview)"] pub fn set_ecbdataptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu3 { # [doc = "Event Generator Unit 3"] pub struct EGU3 ; impl EGU3 { pub const BASE_ADDR : u64 = 1073836032u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer4 { # [doc = "Timer/Counter 4"] pub struct TIMER4 ; impl TIMER4 { pub const BASE_ADDR : u64 = 1073852416u64 ; } # [doc = "Start Timer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop Timer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Increment Timer (Counter mode only)"] pub struct TASKS_COUNT (u32) ; impl TASKS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear time"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Shut down timer"] pub struct TASKS_SHUTDOWN (u32) ; impl TASKS_SHUTDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE0 (u32) ; impl TASKS_CAPTURE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE1 (u32) ; impl TASKS_CAPTURE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE2 (u32) ; impl TASKS_CAPTURE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE3 (u32) ; impl TASKS_CAPTURE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE4 (u32) ; impl TASKS_CAPTURE4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE5 (u32) ; impl TASKS_CAPTURE5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE4 (u32) ; impl EVENTS_COMPARE4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE5 (u32) ; impl EVENTS_COMPARE5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn compare0_clear (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn set_compare0_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn compare1_clear (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn set_compare1_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn compare2_clear (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn set_compare2_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn compare3_clear (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn set_compare3_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between COMPARE[4] event and CLEAR task"] pub fn compare4_clear (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between COMPARE[4] event and CLEAR task"] pub fn set_compare4_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Shortcut between COMPARE[5] event and CLEAR task"] pub fn compare5_clear (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Shortcut between COMPARE[5] event and CLEAR task"] pub fn set_compare5_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn compare0_stop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn set_compare0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn compare1_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn set_compare1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn compare2_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn set_compare2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn compare3_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn set_compare3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Shortcut between COMPARE[4] event and STOP task"] pub fn compare4_stop (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Shortcut between COMPARE[4] event and STOP task"] pub fn set_compare4_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Shortcut between COMPARE[5] event and STOP task"] pub fn compare5_stop (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Shortcut between COMPARE[5] event and STOP task"] pub fn set_compare5_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[4] event"] pub fn compare4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[4] event"] pub fn set_compare4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[5] event"] pub fn compare5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[5] event"] pub fn set_compare5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[4] event"] pub fn compare4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[4] event"] pub fn set_compare4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[5] event"] pub fn compare5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[5] event"] pub fn set_compare5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer mode selection"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configure the number of bits used by the TIMER"] pub struct BITMODE (u32) ; impl BITMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer bit width"] pub fn bitmode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer bit width"] pub fn set_bitmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer prescaler register"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC4 (u32) ; impl CC4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC5 (u32) ; impl CC5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twis1 { # [doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"] pub struct TWIS1 ; impl TWIS1 { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "Stop TWI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prepare the TWI slave to respond to a write command"] pub struct TASKS_PREPARERX (u32) ; impl TASKS_PREPARERX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prepare the TWI slave to respond to a read command"] pub struct TASKS_PREPARETX (u32) ; impl TASKS_PREPARETX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive sequence started"] pub struct EVENTS_RXSTARTED (u32) ; impl EVENTS_RXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit sequence started"] pub struct EVENTS_TXSTARTED (u32) ; impl EVENTS_TXSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Write command received"] pub struct EVENTS_WRITE (u32) ; impl EVENTS_WRITE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Read command received"] pub struct EVENTS_READ (u32) ; impl EVENTS_READ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between WRITE event and SUSPEND task"] pub fn write_suspend (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Shortcut between WRITE event and SUSPEND task"] pub fn set_write_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Shortcut between READ event and SUSPEND task"] pub fn read_suspend (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Shortcut between READ event and SUSPEND task"] pub fn set_read_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Enable or disable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Enable or disable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Enable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn rxstarted (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXSTARTED event"] pub fn set_rxstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn txstarted (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXSTARTED event"] pub fn set_txstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for WRITE event"] pub fn write (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for WRITE event"] pub fn set_write (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Write '1' to Disable interrupt for READ event"] pub fn read (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READ event"] pub fn set_read (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX buffer overflow detected, and prevented"] pub fn overflow (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "RX buffer overflow detected, and prevented"] pub fn set_overflow (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK sent after receiving a data byte"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK sent after receiving a data byte"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TX buffer over-read detected, and prevented"] pub fn overread (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TX buffer over-read detected, and prevented"] pub fn set_overread (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register indicating which address had a match"] pub struct MATCH (u32) ; impl MATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Which of the addresses in {ADDRESS} matched the incoming address"] pub fn r#match (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Which of the addresses in {ADDRESS} matched the incoming address"] pub fn set_match (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWIS"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWIS"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWIS"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL signal"] pub struct PSEL_SCL (u32) ; impl PSEL_SCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA signal"] pub struct PSEL_SDA (u32) ; impl PSEL_SDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD Data pointer"] pub struct RXD_PTR (u32) ; impl RXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "RXD Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in RXD buffer"] pub struct RXD_MAXCNT (u32) ; impl RXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in RXD buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in RXD buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last RXD transaction"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last RXD transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last RXD transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD Data pointer"] pub struct TXD_PTR (u32) ; impl TXD_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TXD Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of bytes in TXD buffer"] pub struct TXD_MAXCNT (u32) ; impl TXD_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of bytes in TXD buffer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum number of bytes in TXD buffer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of bytes transferred in the last TXD transaction"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bytes transferred in the last TXD transaction"] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Number of bytes transferred in the last TXD transaction"] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  TWI slave address 0"] pub struct ADDRESS0 (u32) ; impl ADDRESS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI slave address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "TWI slave address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  TWI slave address 0"] pub struct ADDRESS1 (u32) ; impl ADDRESS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI slave address"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "TWI slave address"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register for the address match mechanism"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable address matching on ADDRESS[0]"] pub fn address0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable address matching on ADDRESS[0]"] pub fn set_address0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable address matching on ADDRESS[1]"] pub fn address1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable address matching on ADDRESS[1]"] pub fn set_address1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub struct ORC (u32) ; impl ORC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub fn orc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."] pub fn set_orc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod egu4 { # [doc = "Event Generator Unit 4"] pub struct EGU4 ; impl EGU4 { pub const BASE_ADDR : u64 = 1073840128u64 ; } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER0 (u32) ; impl TASKS_TRIGGER0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER1 (u32) ; impl TASKS_TRIGGER1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER2 (u32) ; impl TASKS_TRIGGER2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER3 (u32) ; impl TASKS_TRIGGER3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER4 (u32) ; impl TASKS_TRIGGER4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER5 (u32) ; impl TASKS_TRIGGER5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER6 (u32) ; impl TASKS_TRIGGER6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER7 (u32) ; impl TASKS_TRIGGER7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER8 (u32) ; impl TASKS_TRIGGER8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER9 (u32) ; impl TASKS_TRIGGER9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER10 (u32) ; impl TASKS_TRIGGER10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER11 (u32) ; impl TASKS_TRIGGER11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER12 (u32) ; impl TASKS_TRIGGER12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER13 (u32) ; impl TASKS_TRIGGER13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER14 (u32) ; impl TASKS_TRIGGER14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Trigger 0 for triggering the corresponding TRIGGERED[0] event"] pub struct TASKS_TRIGGER15 (u32) ; impl TASKS_TRIGGER15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED0 (u32) ; impl EVENTS_TRIGGERED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED1 (u32) ; impl EVENTS_TRIGGERED1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED2 (u32) ; impl EVENTS_TRIGGERED2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED3 (u32) ; impl EVENTS_TRIGGERED3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED4 (u32) ; impl EVENTS_TRIGGERED4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED5 (u32) ; impl EVENTS_TRIGGERED5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED6 (u32) ; impl EVENTS_TRIGGERED6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED7 (u32) ; impl EVENTS_TRIGGERED7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED8 (u32) ; impl EVENTS_TRIGGERED8 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED9 (u32) ; impl EVENTS_TRIGGERED9 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED10 (u32) ; impl EVENTS_TRIGGERED10 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED11 (u32) ; impl EVENTS_TRIGGERED11 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED12 (u32) ; impl EVENTS_TRIGGERED12 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED13 (u32) ; impl EVENTS_TRIGGERED13 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED14 (u32) ; impl EVENTS_TRIGGERED14 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Event number 0 generated by triggering the corresponding TRIGGER[0] task"] pub struct EVENTS_TRIGGERED15 (u32) ; impl EVENTS_TRIGGERED15 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn triggered0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[0] event"] pub fn set_triggered0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn triggered1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[1] event"] pub fn set_triggered1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn triggered2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[2] event"] pub fn set_triggered2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn triggered3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[3] event"] pub fn set_triggered3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn triggered4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[4] event"] pub fn set_triggered4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn triggered5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[5] event"] pub fn set_triggered5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn triggered6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[6] event"] pub fn set_triggered6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn triggered7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[7] event"] pub fn set_triggered7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn triggered8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[8] event"] pub fn set_triggered8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn triggered9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[9] event"] pub fn set_triggered9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn triggered10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[10] event"] pub fn set_triggered10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn triggered11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[11] event"] pub fn set_triggered11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn triggered12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[12] event"] pub fn set_triggered12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn triggered13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[13] event"] pub fn set_triggered13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn triggered14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[14] event"] pub fn set_triggered14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn triggered15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TRIGGERED[15] event"] pub fn set_triggered15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod uart0 { # [doc = "Universal Asynchronous Receiver/Transmitter"] pub struct UART0 ; impl UART0 { pub const BASE_ADDR : u64 = 1073750016u64 ; } # [doc = "Start UART receiver"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop UART receiver"] pub struct TASKS_STOPRX (u32) ; impl TASKS_STOPRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start UART transmitter"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop UART transmitter"] pub struct TASKS_STOPTX (u32) ; impl TASKS_STOPTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend UART"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CTS is activated (set low). Clear To Send."] pub struct EVENTS_CTS (u32) ; impl EVENTS_CTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CTS is deactivated (set high). Not Clear To Send."] pub struct EVENTS_NCTS (u32) ; impl EVENTS_NCTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data received in RXD"] pub struct EVENTS_RXDRDY (u32) ; impl EVENTS_RXDRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data sent from TXD"] pub struct EVENTS_TXDRDY (u32) ; impl EVENTS_TXDRDY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error detected"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receiver timeout"] pub struct EVENTS_RXTO (u32) ; impl EVENTS_RXTO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between CTS event and STARTRX task"] pub fn cts_startrx (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between CTS event and STARTRX task"] pub fn set_cts_startrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between NCTS event and STOPRX task"] pub fn ncts_stoprx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between NCTS event and STOPRX task"] pub fn set_ncts_stoprx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for CTS event"] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CTS event"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for NCTS event"] pub fn ncts (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for NCTS event"] pub fn set_ncts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for RXDRDY event"] pub fn rxdrdy (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXDRDY event"] pub fn set_rxdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TXDRDY event"] pub fn txdrdy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXDRDY event"] pub fn set_txdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for RXTO event"] pub fn rxto (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXTO event"] pub fn set_rxto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for CTS event"] pub fn cts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CTS event"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for NCTS event"] pub fn ncts (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for NCTS event"] pub fn set_ncts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for RXDRDY event"] pub fn rxdrdy (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXDRDY event"] pub fn set_rxdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TXDRDY event"] pub fn txdrdy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXDRDY event"] pub fn set_txdrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for RXTO event"] pub fn rxto (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXTO event"] pub fn set_rxto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity error"] pub fn parity (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Parity error"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Framing error occurred"] pub fn framing (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Framing error occurred"] pub fn set_framing (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Break condition"] pub fn r#break (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Break condition"] pub fn set_break (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable UART"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable UART"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable UART"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for RTS"] pub struct PSELRTS (u32) ; impl PSELRTS { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for UART RTS signal"] pub fn pselrts (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for UART RTS signal"] pub fn set_pselrts (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for TXD"] pub struct PSELTXD (u32) ; impl PSELTXD { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for UART TXD signal"] pub fn pseltxd (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for UART TXD signal"] pub fn set_pseltxd (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for CTS"] pub struct PSELCTS (u32) ; impl PSELCTS { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for UART CTS signal"] pub fn pselcts (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for UART CTS signal"] pub fn set_pselcts (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for RXD"] pub struct PSELRXD (u32) ; impl PSELRXD { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for UART RXD signal"] pub fn pselrxd (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for UART RXD signal"] pub fn set_pselrxd (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RX data received in previous transfers, double buffered"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RX data received in previous transfers, double buffered"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TX data to be transferred"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TX data to be transferred"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate"] pub struct BAUDRATE (u32) ; impl BAUDRATE { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Baud rate"] pub fn baudrate (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Baud rate"] pub fn set_baudrate (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of parity and hardware flow control"] pub struct CONFIG (u32) ; impl CONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Hardware flow control"] pub fn hwfc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Hardware flow control"] pub fn set_hwfc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity"] pub fn parity (& self) -> u32 { (self . 0 >> 1u32) & 7u32 } # [doc = "Parity"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod swi4 { # [doc = "Software interrupt 4"] pub struct SWI4 ; impl SWI4 { pub const BASE_ADDR : u64 = 1073840128u64 ; } # [doc = "Unused."] pub struct UNUSED (u32) ; impl UNUSED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod nfct { # [doc = "NFC-A compatible radio"] pub struct NFCT ; impl NFCT { pub const BASE_ADDR : u64 = 1073762304u64 ; } # [doc = "Activate NFC peripheral for incoming and outgoing frames, change state to activated"] pub struct TASKS_ACTIVATE (u32) ; impl TASKS_ACTIVATE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable NFC peripheral"] pub struct TASKS_DISABLE (u32) ; impl TASKS_DISABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable NFC sense field mode, change state to sense mode"] pub struct TASKS_SENSE (u32) ; impl TASKS_SENSE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start transmission of a outgoing frame, change state to transmit"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Initializes the EasyDMA for receive."] pub struct TASKS_ENABLERXDATA (u32) ; impl TASKS_ENABLERXDATA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Force state machine to IDLE state"] pub struct TASKS_GOIDLE (u32) ; impl TASKS_GOIDLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Force state machine to SLEEP_A state"] pub struct TASKS_GOSLEEP (u32) ; impl TASKS_GOSLEEP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The NFC peripheral is ready to receive and send frames"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Remote NFC field detected"] pub struct EVENTS_FIELDDETECTED (u32) ; impl EVENTS_FIELDDETECTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Remote NFC field lost"] pub struct EVENTS_FIELDLOST (u32) ; impl EVENTS_FIELDLOST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Marks the start of the first symbol of a transmitted frame"] pub struct EVENTS_TXFRAMESTART (u32) ; impl EVENTS_TXFRAMESTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Marks the end of the last transmitted on-air symbol of a frame"] pub struct EVENTS_TXFRAMEEND (u32) ; impl EVENTS_TXFRAMEEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Marks the end of the first symbol of a received frame"] pub struct EVENTS_RXFRAMESTART (u32) ; impl EVENTS_RXFRAMESTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Received data have been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer"] pub struct EVENTS_RXFRAMEEND (u32) ; impl EVENTS_RXFRAMEEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC error reported. The ERRORSTATUS register contains details on the source of the error."] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error."] pub struct EVENTS_RXERROR (u32) ; impl EVENTS_RXERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full."] pub struct EVENTS_ENDRX (u32) ; impl EVENTS_ENDRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer"] pub struct EVENTS_ENDTX (u32) ; impl EVENTS_ENDTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Auto collision resolution process has started"] pub struct EVENTS_AUTOCOLRESSTARTED (u32) ; impl EVENTS_AUTOCOLRESSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC Auto collision resolution error reported."] pub struct EVENTS_COLLISION (u32) ; impl EVENTS_COLLISION { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC Auto collision resolution successfully completed"] pub struct EVENTS_SELECTED (u32) ; impl EVENTS_SELECTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "EasyDMA is ready to receive or send frames."] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between FIELDDETECTED event and ACTIVATE task"] pub fn fielddetected_activate (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between FIELDDETECTED event and ACTIVATE task"] pub fn set_fielddetected_activate (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between FIELDLOST event and SENSE task"] pub fn fieldlost_sense (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between FIELDLOST event and SENSE task"] pub fn set_fieldlost_sense (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for FIELDDETECTED event"] pub fn fielddetected (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for FIELDDETECTED event"] pub fn set_fielddetected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for FIELDLOST event"] pub fn fieldlost (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for FIELDLOST event"] pub fn set_fieldlost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for TXFRAMESTART event"] pub fn txframestart (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for TXFRAMESTART event"] pub fn set_txframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for TXFRAMEEND event"] pub fn txframeend (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for TXFRAMEEND event"] pub fn set_txframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for RXFRAMESTART event"] pub fn rxframestart (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for RXFRAMESTART event"] pub fn set_rxframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for RXFRAMEEND event"] pub fn rxframeend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for RXFRAMEEND event"] pub fn set_rxframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for RXERROR event"] pub fn rxerror (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for RXERROR event"] pub fn set_rxerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for AUTOCOLRESSTARTED event"] pub fn autocolresstarted (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for AUTOCOLRESSTARTED event"] pub fn set_autocolresstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for COLLISION event"] pub fn collision (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable interrupt for COLLISION event"] pub fn set_collision (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable interrupt for SELECTED event"] pub fn selected (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for SELECTED event"] pub fn set_selected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for FIELDDETECTED event"] pub fn fielddetected (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for FIELDDETECTED event"] pub fn set_fielddetected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for FIELDLOST event"] pub fn fieldlost (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for FIELDLOST event"] pub fn set_fieldlost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TXFRAMESTART event"] pub fn txframestart (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXFRAMESTART event"] pub fn set_txframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for TXFRAMEEND event"] pub fn txframeend (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXFRAMEEND event"] pub fn set_txframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for RXFRAMESTART event"] pub fn rxframestart (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXFRAMESTART event"] pub fn set_rxframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for RXFRAMEEND event"] pub fn rxframeend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXFRAMEEND event"] pub fn set_rxframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for RXERROR event"] pub fn rxerror (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXERROR event"] pub fn set_rxerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for AUTOCOLRESSTARTED event"] pub fn autocolresstarted (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for AUTOCOLRESSTARTED event"] pub fn set_autocolresstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for COLLISION event"] pub fn collision (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COLLISION event"] pub fn set_collision (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for SELECTED event"] pub fn selected (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SELECTED event"] pub fn set_selected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for FIELDDETECTED event"] pub fn fielddetected (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for FIELDDETECTED event"] pub fn set_fielddetected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for FIELDLOST event"] pub fn fieldlost (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for FIELDLOST event"] pub fn set_fieldlost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TXFRAMESTART event"] pub fn txframestart (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXFRAMESTART event"] pub fn set_txframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for TXFRAMEEND event"] pub fn txframeend (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXFRAMEEND event"] pub fn set_txframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for RXFRAMESTART event"] pub fn rxframestart (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXFRAMESTART event"] pub fn set_rxframestart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for RXFRAMEEND event"] pub fn rxframeend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXFRAMEEND event"] pub fn set_rxframeend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for RXERROR event"] pub fn rxerror (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXERROR event"] pub fn set_rxerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn endrx (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDRX event"] pub fn set_endrx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn endtx (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDTX event"] pub fn set_endtx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for AUTOCOLRESSTARTED event"] pub fn autocolresstarted (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for AUTOCOLRESSTARTED event"] pub fn set_autocolresstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for COLLISION event"] pub fn collision (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COLLISION event"] pub fn set_collision (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for SELECTED event"] pub fn selected (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SELECTED event"] pub fn set_selected (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC Error Status register"] pub struct ERRORSTATUS (u32) ; impl ERRORSTATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"] pub fn framedelaytimeout (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"] pub fn set_framedelaytimeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Field level is too high at max load resistance"] pub fn nfcfieldtoostrong (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Field level is too high at max load resistance"] pub fn set_nfcfieldtoostrong (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Field level is too low at min load resistance"] pub fn nfcfieldtooweak (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Field level is too low at min load resistance"] pub fn set_nfcfieldtooweak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Result of last incoming frames"] pub struct FRAMESTATUS_RX (u32) ; impl FRAMESTATUS_RX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "No valid End of Frame detected"] pub fn crcerror (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "No valid End of Frame detected"] pub fn set_crcerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Parity status of received frame"] pub fn paritystatus (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Parity status of received frame"] pub fn set_paritystatus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Overrun detected"] pub fn overrun (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Overrun detected"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current value driven to the NFC Load Control"] pub struct CURRENTLOADCTRL (u32) ; impl CURRENTLOADCTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Current value driven to the NFC Load Control"] pub fn currentloadctrl (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Current value driven to the NFC Load Control"] pub fn set_currentloadctrl (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Indicates the presence or not of a valid field"] pub struct FIELDPRESENT (u32) ; impl FIELDPRESENT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Indicates the presence or not of a valid field. Available only in the activated state."] pub fn fieldpresent (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Indicates the presence or not of a valid field. Available only in the activated state."] pub fn set_fieldpresent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Indicates if the low level has locked to the field"] pub fn lockdetect (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Indicates if the low level has locked to the field"] pub fn set_lockdetect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Minimum frame delay"] pub struct FRAMEDELAYMIN (u32) ; impl FRAMEDELAYMIN { pub const RESET_VALUE : u32 = 1152u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Minimum frame delay in number of 13.56 MHz clocks"] pub fn framedelaymin (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Minimum frame delay in number of 13.56 MHz clocks"] pub fn set_framedelaymin (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum frame delay"] pub struct FRAMEDELAYMAX (u32) ; impl FRAMEDELAYMAX { pub const RESET_VALUE : u32 = 4096u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum frame delay in number of 13.56 MHz clocks"] pub fn framedelaymax (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Maximum frame delay in number of 13.56 MHz clocks"] pub fn set_framedelaymax (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register for the Frame Delay Timer"] pub struct FRAMEDELAYMODE (u32) ; impl FRAMEDELAYMODE { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Configuration register for the Frame Delay Timer"] pub fn framedelaymode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Configuration register for the Frame Delay Timer"] pub fn set_framedelaymode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet pointer for TXD and RXD data storage in Data RAM"] pub struct PACKETPTR (u32) ; impl PACKETPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte aligned RAM address."] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte aligned RAM address."] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Size of allocated for TXD and RXD data storage buffer in Data RAM"] pub struct MAXLEN (u32) ; impl MAXLEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Size of allocated for TXD and RXD data storage buffer in Data RAM"] pub fn maxlen (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Size of allocated for TXD and RXD data storage buffer in Data RAM"] pub fn set_maxlen (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of outgoing frames"] pub struct TXD_FRAMECONFIG (u32) ; impl TXD_FRAMECONFIG { pub const RESET_VALUE : u32 = 23u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Adding parity or not in the frame"] pub fn parity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Adding parity or not in the frame"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Discarding unused bits in start or at end of a Frame"] pub fn discardmode (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Discarding unused bits in start or at end of a Frame"] pub fn set_discardmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Adding SoF or not in TX frames"] pub fn sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Adding SoF or not in TX frames"] pub fn set_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "CRC mode for outgoing frames"] pub fn crcmodetx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC mode for outgoing frames"] pub fn set_crcmodetx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Size of outgoing frame"] pub struct TXD_AMOUNT (u32) ; impl TXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."] pub fn txdatabits (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."] pub fn set_txdatabits (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing"] pub fn txdatabytes (& self) -> u32 { (self . 0 >> 3u32) & 511u32 } # [doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing"] pub fn set_txdatabytes (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration of incoming frames"] pub struct RXD_FRAMECONFIG (u32) ; impl RXD_FRAMECONFIG { pub const RESET_VALUE : u32 = 21u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Parity expected or not in RX frame"] pub fn parity (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Parity expected or not in RX frame"] pub fn set_parity (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SoF expected or not in RX frames"] pub fn sof (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SoF expected or not in RX frames"] pub fn set_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "CRC mode for incoming frames"] pub fn crcmoderx (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC mode for incoming frames"] pub fn set_crcmoderx (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Size of last incoming frame"] pub struct RXD_AMOUNT (u32) ; impl RXD_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."] pub fn rxdatabits (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."] pub fn set_rxdatabits (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"] pub fn rxdatabytes (& self) -> u32 { (self . 0 >> 3u32) & 511u32 } # [doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"] pub fn set_rxdatabytes (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"] pub struct NFCID1_LAST (u32) ; impl NFCID1_LAST { pub const RESET_VALUE : u32 = 25443u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "NFCID1 byte Z (very last byte sent)"] pub fn nfcid1_z (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "NFCID1 byte Z (very last byte sent)"] pub fn set_nfcid1_z (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NFCID1 byte Y"] pub fn nfcid1_y (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "NFCID1 byte Y"] pub fn set_nfcid1_y (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "NFCID1 byte X"] pub fn nfcid1_x (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "NFCID1 byte X"] pub fn set_nfcid1_x (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "NFCID1 byte W"] pub fn nfcid1_w (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "NFCID1 byte W"] pub fn set_nfcid1_w (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Second last NFCID1 part (7 or 10 bytes ID)"] pub struct NFCID1_2ND_LAST (u32) ; impl NFCID1_2ND_LAST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "NFCID1 byte V"] pub fn nfcid1_v (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "NFCID1 byte V"] pub fn set_nfcid1_v (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NFCID1 byte U"] pub fn nfcid1_u (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "NFCID1 byte U"] pub fn set_nfcid1_u (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "NFCID1 byte T"] pub fn nfcid1_t (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "NFCID1 byte T"] pub fn set_nfcid1_t (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Third last NFCID1 part (10 bytes ID)"] pub struct NFCID1_3RD_LAST (u32) ; impl NFCID1_3RD_LAST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "NFCID1 byte S"] pub fn nfcid1_s (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "NFCID1 byte S"] pub fn set_nfcid1_s (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NFCID1 byte R"] pub fn nfcid1_r (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "NFCID1 byte R"] pub fn set_nfcid1_r (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "NFCID1 byte Q"] pub fn nfcid1_q (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "NFCID1 byte Q"] pub fn set_nfcid1_q (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC-A SENS_RES auto-response settings"] pub struct SENSRES (u32) ; impl SENSRES { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn bitframesdd (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn set_bitframesdd (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Reserved for future use. Shall be 0."] pub fn rfu5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Reserved for future use. Shall be 0."] pub fn set_rfu5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "NFCID1 size. This value is used by the Auto collision resolution engine."] pub fn nfcidsize (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "NFCID1 size. This value is used by the Auto collision resolution engine."] pub fn set_nfcidsize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn platfconfig (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn set_platfconfig (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reserved for future use. Shall be 0."] pub fn rfu74 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Reserved for future use. Shall be 0."] pub fn set_rfu74 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "NFC-A SEL_RES auto-response settings"] pub struct SELRES (u32) ; impl SELRES { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reserved for future use. Shall be 0."] pub fn rfu10 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Reserved for future use. Shall be 0."] pub fn set_rfu10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Cascade bit (controlled by hardware, write has no effect)"] pub fn cascade (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Cascade bit (controlled by hardware, write has no effect)"] pub fn set_cascade (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Reserved for future use. Shall be 0."] pub fn rfu43 (& self) -> u32 { (self . 0 >> 3u32) & 3u32 } # [doc = "Reserved for future use. Shall be 0."] pub fn set_rfu43 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn protocol (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"] pub fn set_protocol (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Reserved for future use. Shall be 0."] pub fn rfu7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Reserved for future use. Shall be 0."] pub fn set_rfu7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod comp { # [doc = "Comparator"] pub struct COMP ; impl COMP { pub const BASE_ADDR : u64 = 1073819648u64 ; } # [doc = "Start comparator"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop comparator"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sample comparator value"] pub struct TASKS_SAMPLE (u32) ; impl TASKS_SAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "COMP is ready and output is valid"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Downward crossing"] pub struct EVENTS_DOWN (u32) ; impl EVENTS_DOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Upward crossing"] pub struct EVENTS_UP (u32) ; impl EVENTS_UP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Downward or upward crossing"] pub struct EVENTS_CROSS (u32) ; impl EVENTS_CROSS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between READY event and SAMPLE task"] pub fn ready_sample (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between READY event and SAMPLE task"] pub fn set_ready_sample (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between READY event and STOP task"] pub fn ready_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between READY event and STOP task"] pub fn set_ready_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between DOWN event and STOP task"] pub fn down_stop (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between DOWN event and STOP task"] pub fn set_down_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between UP event and STOP task"] pub fn up_stop (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between UP event and STOP task"] pub fn set_up_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between CROSS event and STOP task"] pub fn cross_stop (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between CROSS event and STOP task"] pub fn set_cross_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for DOWN event"] pub fn down (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for DOWN event"] pub fn set_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for UP event"] pub fn up (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for UP event"] pub fn set_up (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for CROSS event"] pub fn cross (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for CROSS event"] pub fn set_cross (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for DOWN event"] pub fn down (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DOWN event"] pub fn set_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for UP event"] pub fn up (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for UP event"] pub fn set_up (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for CROSS event"] pub fn cross (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CROSS event"] pub fn set_cross (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for DOWN event"] pub fn down (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DOWN event"] pub fn set_down (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for UP event"] pub fn up (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for UP event"] pub fn set_up (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for CROSS event"] pub fn cross (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CROSS event"] pub fn set_cross (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Compare result"] pub struct RESULT (u32) ; impl RESULT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Result of last compare. Decision point SAMPLE task."] pub fn result (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Result of last compare. Decision point SAMPLE task."] pub fn set_result (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "COMP enable"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable COMP"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Enable or disable COMP"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select"] pub struct PSEL (u32) ; impl PSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog pin select"] pub fn psel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Analog pin select"] pub fn set_psel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reference source select for single-ended mode"] pub struct REFSEL (u32) ; impl REFSEL { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Reference select"] pub fn refsel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Reference select"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "External reference select"] pub struct EXTREFSEL (u32) ; impl EXTREFSEL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "External analog reference select"] pub fn extrefsel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "External analog reference select"] pub fn set_extrefsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Threshold configuration for hysteresis unit"] pub struct TH (u32) ; impl TH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "VDOWN = (THDOWN+1)/64*VREF"] pub fn thdown (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "VDOWN = (THDOWN+1)/64*VREF"] pub fn set_thdown (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "VUP = (THUP+1)/64*VREF"] pub fn thup (& self) -> u32 { (self . 0 >> 8u32) & 63u32 } # [doc = "VUP = (THUP+1)/64*VREF"] pub fn set_thup (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Mode configuration"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Speed and power modes"] pub fn sp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Speed and power modes"] pub fn set_sp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Main operation modes"] pub fn main (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Main operation modes"] pub fn set_main (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Comparator hysteresis enable"] pub struct HYST (u32) ; impl HYST { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparator hysteresis"] pub fn hyst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Comparator hysteresis"] pub fn set_hyst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current source select on analog input"] pub struct ISOURCE (u32) ; impl ISOURCE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Comparator hysteresis"] pub fn isource (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Comparator hysteresis"] pub fn set_isource (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pdm { # [doc = "Pulse Density Modulation (Digital Microphone) Interface"] pub struct PDM ; impl PDM { pub const BASE_ADDR : u64 = 1073860608u64 ; } # [doc = "Starts continuous PDM transfer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stops PDM transfer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PDM transfer has started"] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PDM transfer has finished"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PDM module enable register"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable PDM module"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable PDM module"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PDM clock generator control"] pub struct PDMCLKCTRL (u32) ; impl PDMCLKCTRL { pub const RESET_VALUE : u32 = 138412032u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "PDM_CLK frequency"] pub fn freq (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "PDM_CLK frequency"] pub fn set_freq (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Defines the routing of the connected PDM microphones' signals"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mono or stereo operation"] pub fn operation (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Mono or stereo operation"] pub fn set_operation (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Defines on which PDM_CLK edge Left (or mono) is sampled"] pub fn edge (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Defines on which PDM_CLK edge Left (or mono) is sampled"] pub fn set_edge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Left output gain adjustment"] pub struct GAINL (u32) ; impl GAINL { pub const RESET_VALUE : u32 = 40u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust"] pub fn gainl (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust"] pub fn set_gainl (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Right output gain adjustment"] pub struct GAINR (u32) ; impl GAINR { pub const RESET_VALUE : u32 = 40u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"] pub fn gainr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"] pub fn set_gainr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin number configuration for PDM CLK signal"] pub struct PSEL_CLK (u32) ; impl PSEL_CLK { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin number configuration for PDM DIN signal"] pub struct PSEL_DIN (u32) ; impl PSEL_DIN { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number"] pub fn pin (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Pin number"] pub fn set_pin (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Connection"] pub fn connect (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Connection"] pub fn set_connect (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RAM address pointer to write samples to with EasyDMA"] pub struct SAMPLE_PTR (u32) ; impl SAMPLE_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address to write PDM samples to over DMA"] pub fn sampleptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Address to write PDM samples to over DMA"] pub fn set_sampleptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of samples to allocate memory for in EasyDMA mode"] pub struct SAMPLE_MAXCNT (u32) ; impl SAMPLE_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Length of DMA RAM allocation in number of samples"] pub fn buffsize (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Length of DMA RAM allocation in number of samples"] pub fn set_buffsize (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rtc1 { # [doc = "Real time counter 1"] pub struct RTC1 ; impl RTC1 { pub const BASE_ADDR : u64 = 1073811456u64 ; } # [doc = "Start RTC COUNTER"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop RTC COUNTER"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear RTC COUNTER"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Set COUNTER to 0xFFFFF0"] pub struct TASKS_TRIGOVRFLW (u32) ; impl TASKS_TRIGOVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER increment"] pub struct EVENTS_TICK (u32) ; impl EVENTS_TICK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event on COUNTER overflow"] pub struct EVENTS_OVRFLW (u32) ; impl EVENTS_OVRFLW { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable event routing"] pub struct EVTEN (u32) ; impl EVTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable event routing"] pub struct EVTENSET (u32) ; impl EVTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable event routing"] pub struct EVTENCLR (u32) ; impl EVTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn tick (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable event routing for TICK event"] pub fn set_tick (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn ovrflw (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable event routing for OVRFLW event"] pub fn set_ovrflw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable event routing for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current COUNTER value"] pub struct COUNTER (u32) ; impl COUNTER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter value"] pub fn counter (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Counter value"] pub fn set_counter (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compare value"] pub fn compare (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Compare value"] pub fn set_compare (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod twi0 { # [doc = "I2C compatible Two-Wire Interface 0"] pub struct TWI0 ; impl TWI0 { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Start TWI receive sequence"] pub struct TASKS_STARTRX (u32) ; impl TASKS_STARTRX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start TWI transmit sequence"] pub struct TASKS_STARTTX (u32) ; impl TASKS_STARTTX { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop TWI transaction"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Suspend TWI transaction"] pub struct TASKS_SUSPEND (u32) ; impl TASKS_SUSPEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resume TWI transaction"] pub struct TASKS_RESUME (u32) ; impl TASKS_RESUME { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI RXD byte received"] pub struct EVENTS_RXDREADY (u32) ; impl EVENTS_RXDREADY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI TXD byte sent"] pub struct EVENTS_TXDSENT (u32) ; impl EVENTS_TXDSENT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI error"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI byte boundary, generated before each byte that is sent or received"] pub struct EVENTS_BB (u32) ; impl EVENTS_BB { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI entered the suspended state"] pub struct EVENTS_SUSPENDED (u32) ; impl EVENTS_SUSPENDED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between BB event and SUSPEND task"] pub fn bb_suspend (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between BB event and SUSPEND task"] pub fn set_bb_suspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between BB event and STOP task"] pub fn bb_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between BB event and STOP task"] pub fn set_bb_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for RXDREADY event"] pub fn rxdready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RXDREADY event"] pub fn set_rxdready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for TXDSENT event"] pub fn txdsent (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for TXDSENT event"] pub fn set_txdsent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for BB event"] pub fn bb (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for BB event"] pub fn set_bb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for RXDREADY event"] pub fn rxdready (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RXDREADY event"] pub fn set_rxdready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for TXDSENT event"] pub fn txdsent (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for TXDSENT event"] pub fn set_txdsent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for BB event"] pub fn bb (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for BB event"] pub fn set_bb (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn suspended (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for SUSPENDED event"] pub fn set_suspended (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Error source"] pub struct ERRORSRC (u32) ; impl ERRORSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Overrun error"] pub fn overrun (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Overrun error"] pub fn set_overrun (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn anack (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "NACK received after sending the address (write '1' to clear)"] pub fn set_anack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn dnack (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "NACK received after sending a data byte (write '1' to clear)"] pub fn set_dnack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable TWI"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable TWI"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Enable or disable TWI"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SCL"] pub struct PSELSCL (u32) ; impl PSELSCL { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for TWI SCL signal"] pub fn pselscl (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for TWI SCL signal"] pub fn set_pselscl (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pin select for SDA"] pub struct PSELSDA (u32) ; impl PSELSDA { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pin number configuration for TWI SDA signal"] pub fn pselsda (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pin number configuration for TWI SDA signal"] pub fn set_pselsda (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RXD register"] pub struct RXD (u32) ; impl RXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RXD register"] pub fn rxd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RXD register"] pub fn set_rxd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TXD register"] pub struct TXD (u32) ; impl TXD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TXD register"] pub fn txd (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "TXD register"] pub fn set_txd (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TWI frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 67108864u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TWI master clock frequency"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "TWI master clock frequency"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address used in the TWI transfer"] pub struct ADDRESS (u32) ; impl ADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address used in the TWI transfer"] pub fn address (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Address used in the TWI transfer"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod clock { # [doc = "Clock control"] pub struct CLOCK ; impl CLOCK { pub const BASE_ADDR : u64 = 1073741824u64 ; } # [doc = "Start HFCLK crystal oscillator"] pub struct TASKS_HFCLKSTART (u32) ; impl TASKS_HFCLKSTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop HFCLK crystal oscillator"] pub struct TASKS_HFCLKSTOP (u32) ; impl TASKS_HFCLKSTOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start LFCLK source"] pub struct TASKS_LFCLKSTART (u32) ; impl TASKS_LFCLKSTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop LFCLK source"] pub struct TASKS_LFCLKSTOP (u32) ; impl TASKS_LFCLKSTOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start calibration of LFRC oscillator"] pub struct TASKS_CAL (u32) ; impl TASKS_CAL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start calibration timer"] pub struct TASKS_CTSTART (u32) ; impl TASKS_CTSTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop calibration timer"] pub struct TASKS_CTSTOP (u32) ; impl TASKS_CTSTOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "HFCLK oscillator started"] pub struct EVENTS_HFCLKSTARTED (u32) ; impl EVENTS_HFCLKSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "LFCLK started"] pub struct EVENTS_LFCLKSTARTED (u32) ; impl EVENTS_LFCLKSTARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Calibration of LFCLK RC oscillator complete event"] pub struct EVENTS_DONE (u32) ; impl EVENTS_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Calibration timer timeout"] pub struct EVENTS_CTTO (u32) ; impl EVENTS_CTTO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for HFCLKSTARTED event"] pub fn hfclkstarted (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for HFCLKSTARTED event"] pub fn set_hfclkstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for LFCLKSTARTED event"] pub fn lfclkstarted (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for LFCLKSTARTED event"] pub fn set_lfclkstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for DONE event"] pub fn done (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DONE event"] pub fn set_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for CTTO event"] pub fn ctto (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CTTO event"] pub fn set_ctto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for HFCLKSTARTED event"] pub fn hfclkstarted (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for HFCLKSTARTED event"] pub fn set_hfclkstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for LFCLKSTARTED event"] pub fn lfclkstarted (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for LFCLKSTARTED event"] pub fn set_lfclkstarted (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for DONE event"] pub fn done (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DONE event"] pub fn set_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for CTTO event"] pub fn ctto (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CTTO event"] pub fn set_ctto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status indicating that HFCLKSTART task has been triggered"] pub struct HFCLKRUN (u32) ; impl HFCLKRUN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "HFCLKSTART task triggered or not"] pub fn status (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "HFCLKSTART task triggered or not"] pub fn set_status (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "HFCLK status"] pub struct HFCLKSTAT (u32) ; impl HFCLKSTAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Source of HFCLK"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Source of HFCLK"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HFCLK state"] pub fn state (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "HFCLK state"] pub fn set_state (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status indicating that LFCLKSTART task has been triggered"] pub struct LFCLKRUN (u32) ; impl LFCLKRUN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "LFCLKSTART task triggered or not"] pub fn status (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "LFCLKSTART task triggered or not"] pub fn set_status (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "LFCLK status"] pub struct LFCLKSTAT (u32) ; impl LFCLKSTAT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Source of LFCLK"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Source of LFCLK"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "LFCLK state"] pub fn state (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "LFCLK state"] pub fn set_state (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Copy of LFCLKSRC register, set when LFCLKSTART task was triggered"] pub struct LFCLKSRCCOPY (u32) ; impl LFCLKSRCCOPY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock source"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Clock source"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock source for the LFCLK"] pub struct LFCLKSRC (u32) ; impl LFCLKSRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock source"] pub fn src (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Clock source"] pub fn set_src (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"] pub fn bypass (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"] pub fn set_bypass (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable external source for LFCLK"] pub fn external (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable external source for LFCLK"] pub fn set_external (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Calibration timer interval"] pub struct CTIV (u32) ; impl CTIV { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds."] pub fn ctiv (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds."] pub fn set_ctiv (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clocking options for the Trace Port debug interface"] pub struct TRACECONFIG (u32) ; impl TRACECONFIG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Speed of Trace Port clock. Note that the TRACECLK pin will output this clock divided by two."] pub fn traceportspeed (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Speed of Trace Port clock. Note that the TRACECLK pin will output this clock divided by two."] pub fn set_traceportspeed (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pin multiplexing of trace signals."] pub fn tracemux (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Pin multiplexing of trace signals."] pub fn set_tracemux (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod radio { # [doc = "2.4 GHz Radio"] pub struct RADIO ; impl RADIO { pub const BASE_ADDR : u64 = 1073745920u64 ; } # [doc = "Enable RADIO in TX mode"] pub struct TASKS_TXEN (u32) ; impl TASKS_TXEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable RADIO in RX mode"] pub struct TASKS_RXEN (u32) ; impl TASKS_RXEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start RADIO"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop RADIO"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable RADIO"] pub struct TASKS_DISABLE (u32) ; impl TASKS_DISABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start the RSSI and take one single sample of the receive signal strength."] pub struct TASKS_RSSISTART (u32) ; impl TASKS_RSSISTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop the RSSI measurement"] pub struct TASKS_RSSISTOP (u32) ; impl TASKS_RSSISTOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start the bit counter"] pub struct TASKS_BCSTART (u32) ; impl TASKS_BCSTART { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop the bit counter"] pub struct TASKS_BCSTOP (u32) ; impl TASKS_BCSTOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RADIO has ramped up and is ready to be started"] pub struct EVENTS_READY (u32) ; impl EVENTS_READY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Address sent or received"] pub struct EVENTS_ADDRESS (u32) ; impl EVENTS_ADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet payload sent or received"] pub struct EVENTS_PAYLOAD (u32) ; impl EVENTS_PAYLOAD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet sent or received"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RADIO has been disabled"] pub struct EVENTS_DISABLED (u32) ; impl EVENTS_DISABLED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "A device address match occurred on the last received packet"] pub struct EVENTS_DEVMATCH (u32) ; impl EVENTS_DEVMATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "No device address match occurred on the last received packet"] pub struct EVENTS_DEVMISS (u32) ; impl EVENTS_DEVMISS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Sampling of receive signal strength complete."] pub struct EVENTS_RSSIEND (u32) ; impl EVENTS_RSSIEND { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bit counter reached bit count value."] pub struct EVENTS_BCMATCH (u32) ; impl EVENTS_BCMATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet received with CRC ok"] pub struct EVENTS_CRCOK (u32) ; impl EVENTS_CRCOK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet received with CRC error"] pub struct EVENTS_CRCERROR (u32) ; impl EVENTS_CRCERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between READY event and START task"] pub fn ready_start (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between READY event and START task"] pub fn set_ready_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between END event and DISABLE task"] pub fn end_disable (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between END event and DISABLE task"] pub fn set_end_disable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between DISABLED event and TXEN task"] pub fn disabled_txen (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between DISABLED event and TXEN task"] pub fn set_disabled_txen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between DISABLED event and RXEN task"] pub fn disabled_rxen (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between DISABLED event and RXEN task"] pub fn set_disabled_rxen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between ADDRESS event and RSSISTART task"] pub fn address_rssistart (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between ADDRESS event and RSSISTART task"] pub fn set_address_rssistart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Shortcut between END event and START task"] pub fn end_start (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Shortcut between END event and START task"] pub fn set_end_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Shortcut between ADDRESS event and BCSTART task"] pub fn address_bcstart (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Shortcut between ADDRESS event and BCSTART task"] pub fn set_address_bcstart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Shortcut between DISABLED event and RSSISTOP task"] pub fn disabled_rssistop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between DISABLED event and RSSISTOP task"] pub fn set_disabled_rssistop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for ADDRESS event"] pub fn address (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ADDRESS event"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for PAYLOAD event"] pub fn payload (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for PAYLOAD event"] pub fn set_payload (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for DISABLED event"] pub fn disabled (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DISABLED event"] pub fn set_disabled (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for DEVMATCH event"] pub fn devmatch (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DEVMATCH event"] pub fn set_devmatch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for DEVMISS event"] pub fn devmiss (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DEVMISS event"] pub fn set_devmiss (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for RSSIEND event"] pub fn rssiend (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RSSIEND event"] pub fn set_rssiend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for BCMATCH event"] pub fn bcmatch (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for BCMATCH event"] pub fn set_bcmatch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for CRCOK event"] pub fn crcok (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CRCOK event"] pub fn set_crcok (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for CRCERROR event"] pub fn crcerror (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CRCERROR event"] pub fn set_crcerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn ready (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for READY event"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for ADDRESS event"] pub fn address (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ADDRESS event"] pub fn set_address (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for PAYLOAD event"] pub fn payload (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for PAYLOAD event"] pub fn set_payload (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for DISABLED event"] pub fn disabled (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DISABLED event"] pub fn set_disabled (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for DEVMATCH event"] pub fn devmatch (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DEVMATCH event"] pub fn set_devmatch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for DEVMISS event"] pub fn devmiss (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DEVMISS event"] pub fn set_devmiss (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for RSSIEND event"] pub fn rssiend (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RSSIEND event"] pub fn set_rssiend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for BCMATCH event"] pub fn bcmatch (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for BCMATCH event"] pub fn set_bcmatch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for CRCOK event"] pub fn crcok (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CRCOK event"] pub fn set_crcok (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for CRCERROR event"] pub fn crcerror (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CRCERROR event"] pub fn set_crcerror (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC status"] pub struct CRCSTATUS (u32) ; impl CRCSTATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC status of packet received"] pub fn crcstatus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "CRC status of packet received"] pub fn set_crcstatus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Received address"] pub struct RXMATCH (u32) ; impl RXMATCH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Received address"] pub fn rxmatch (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Received address"] pub fn set_rxmatch (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC field of previously received packet"] pub struct RXCRC (u32) ; impl RXCRC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC field of previously received packet"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "CRC field of previously received packet"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device address match index"] pub struct DAI (u32) ; impl DAI { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address match index"] pub fn dai (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Device address match index"] pub fn set_dai (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet pointer"] pub struct PACKETPTR (u32) ; impl PACKETPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Packet pointer"] pub fn packetptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Packet pointer"] pub fn set_packetptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Frequency"] pub struct FREQUENCY (u32) ; impl FREQUENCY { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Radio channel frequency"] pub fn frequency (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Radio channel frequency"] pub fn set_frequency (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel map selection."] pub fn map (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Channel map selection."] pub fn set_map (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Output power"] pub struct TXPOWER (u32) ; impl TXPOWER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RADIO output power."] pub fn txpower (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "RADIO output power."] pub fn set_txpower (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data rate and modulation"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Radio data rate and modulation setting. The radio supports Frequency-shift Keying (FSK) modulation."] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Radio data rate and modulation setting. The radio supports Frequency-shift Keying (FSK) modulation."] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet configuration register 0"] pub struct PCNF0 (u32) ; impl PCNF0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Length on air of LENGTH field in number of bits."] pub fn lflen (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Length on air of LENGTH field in number of bits."] pub fn set_lflen (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Length on air of S0 field in number of bytes."] pub fn s0len (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Length on air of S0 field in number of bytes."] pub fn set_s0len (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Length on air of S1 field in number of bits."] pub fn s1len (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Length on air of S1 field in number of bits."] pub fn set_s1len (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Include or exclude S1 field in RAM"] pub fn s1incl (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Include or exclude S1 field in RAM"] pub fn set_s1incl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Length of preamble on air. Decision point: TASKS_START task"] pub fn plen (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Length of preamble on air. Decision point: TASKS_START task"] pub fn set_plen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Packet configuration register 1"] pub struct PCNF1 (u32) ; impl PCNF1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."] pub fn maxlen (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."] pub fn set_maxlen (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Static length in number of bytes"] pub fn statlen (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Static length in number of bytes"] pub fn set_statlen (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Base address length in number of bytes"] pub fn balen (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Base address length in number of bytes"] pub fn set_balen (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields."] pub fn endian (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields."] pub fn set_endian (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Enable or disable packet whitening"] pub fn whiteen (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Enable or disable packet whitening"] pub fn set_whiteen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Base address 0"] pub struct BASE0 (u32) ; impl BASE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Base address 0"] pub fn base0 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Base address 0"] pub fn set_base0 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Base address 1"] pub struct BASE1 (u32) ; impl BASE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Base address 1"] pub fn base1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Base address 1"] pub fn set_base1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prefixes bytes for logical addresses 0-3"] pub struct PREFIX0 (u32) ; impl PREFIX0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address prefix 0."] pub fn ap0 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Address prefix 0."] pub fn set_ap0 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Address prefix 1."] pub fn ap1 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Address prefix 1."] pub fn set_ap1 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Address prefix 2."] pub fn ap2 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Address prefix 2."] pub fn set_ap2 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Address prefix 3."] pub fn ap3 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Address prefix 3."] pub fn set_ap3 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prefixes bytes for logical addresses 4-7"] pub struct PREFIX1 (u32) ; impl PREFIX1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address prefix 4."] pub fn ap4 (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Address prefix 4."] pub fn set_ap4 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Address prefix 5."] pub fn ap5 (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Address prefix 5."] pub fn set_ap5 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Address prefix 6."] pub fn ap6 (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Address prefix 6."] pub fn set_ap6 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Address prefix 7."] pub fn ap7 (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } # [doc = "Address prefix 7."] pub fn set_ap7 (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Transmit address select"] pub struct TXADDRESS (u32) ; impl TXADDRESS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transmit address select"] pub fn txaddress (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Transmit address select"] pub fn set_txaddress (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Receive address select"] pub struct RXADDRESSES (u32) ; impl RXADDRESSES { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable reception on logical address 0."] pub fn addr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable reception on logical address 0."] pub fn set_addr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable reception on logical address 1."] pub fn addr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable reception on logical address 1."] pub fn set_addr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable reception on logical address 2."] pub fn addr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable reception on logical address 2."] pub fn set_addr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable reception on logical address 3."] pub fn addr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable reception on logical address 3."] pub fn set_addr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable reception on logical address 4."] pub fn addr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable reception on logical address 4."] pub fn set_addr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable reception on logical address 5."] pub fn addr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable reception on logical address 5."] pub fn set_addr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable reception on logical address 6."] pub fn addr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable reception on logical address 6."] pub fn set_addr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable reception on logical address 7."] pub fn addr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable reception on logical address 7."] pub fn set_addr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC configuration"] pub struct CRCCNF (u32) ; impl CRCCNF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC length in number of bytes."] pub fn len (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CRC length in number of bytes."] pub fn set_len (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Include or exclude packet address field out of CRC calculation."] pub fn skipaddr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Include or exclude packet address field out of CRC calculation."] pub fn set_skipaddr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial"] pub struct CRCPOLY (u32) ; impl CRCPOLY { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "CRC polynomial"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC initial value"] pub struct CRCINIT (u32) ; impl CRCINIT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC initial value"] pub fn crcinit (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "CRC initial value"] pub fn set_crcinit (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Unspecified"] pub struct UNUSED0 (u32) ; impl UNUSED0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Inter Frame Spacing in us"] pub struct TIFS (u32) ; impl TIFS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Inter Frame Spacing in us"] pub fn tifs (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Inter Frame Spacing in us"] pub fn set_tifs (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RSSI sample"] pub struct RSSISAMPLE (u32) ; impl RSSISAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RSSI sample"] pub fn rssisample (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "RSSI sample"] pub fn set_rssisample (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Current radio state"] pub struct STATE (u32) ; impl STATE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Current radio state"] pub fn state (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Current radio state"] pub fn set_state (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data whitening initial value"] pub struct DATAWHITEIV (u32) ; impl DATAWHITEIV { pub const RESET_VALUE : u32 = 64u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'."] pub fn datawhiteiv (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'."] pub fn set_datawhiteiv (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Bit counter compare"] pub struct BCC (u32) ; impl BCC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Bit counter compare"] pub fn bcc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Bit counter compare"] pub fn set_bcc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB0 (u32) ; impl DAB0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB1 (u32) ; impl DAB1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB2 (u32) ; impl DAB2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB3 (u32) ; impl DAB3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB4 (u32) ; impl DAB4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB5 (u32) ; impl DAB5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB6 (u32) ; impl DAB6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address base segment 0"] pub struct DAB7 (u32) ; impl DAB7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address base segment 0"] pub fn dab (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Device address base segment 0"] pub fn set_dab (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP0 (u32) ; impl DAP0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP1 (u32) ; impl DAP1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP2 (u32) ; impl DAP2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP3 (u32) ; impl DAP3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP4 (u32) ; impl DAP4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP5 (u32) ; impl DAP5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP6 (u32) ; impl DAP6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Device address prefix 0"] pub struct DAP7 (u32) ; impl DAP7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device address prefix 0"] pub fn dap (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device address prefix 0"] pub fn set_dap (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Device address match configuration"] pub struct DACNF (u32) ; impl DACNF { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable device address matching using device address 0"] pub fn ena0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 0"] pub fn set_ena0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable device address matching using device address 1"] pub fn ena1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 1"] pub fn set_ena1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable device address matching using device address 2"] pub fn ena2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 2"] pub fn set_ena2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable device address matching using device address 3"] pub fn ena3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 3"] pub fn set_ena3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable device address matching using device address 4"] pub fn ena4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 4"] pub fn set_ena4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable device address matching using device address 5"] pub fn ena5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 5"] pub fn set_ena5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable device address matching using device address 6"] pub fn ena6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 6"] pub fn set_ena6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable device address matching using device address 7"] pub fn ena7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable device address matching using device address 7"] pub fn set_ena7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "TxAdd for device address 0"] pub fn txadd0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "TxAdd for device address 0"] pub fn set_txadd0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "TxAdd for device address 1"] pub fn txadd1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "TxAdd for device address 1"] pub fn set_txadd1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "TxAdd for device address 2"] pub fn txadd2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "TxAdd for device address 2"] pub fn set_txadd2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "TxAdd for device address 3"] pub fn txadd3 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "TxAdd for device address 3"] pub fn set_txadd3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "TxAdd for device address 4"] pub fn txadd4 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "TxAdd for device address 4"] pub fn set_txadd4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "TxAdd for device address 5"] pub fn txadd5 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "TxAdd for device address 5"] pub fn set_txadd5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "TxAdd for device address 6"] pub fn txadd6 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "TxAdd for device address 6"] pub fn set_txadd6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "TxAdd for device address 7"] pub fn txadd7 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "TxAdd for device address 7"] pub fn set_txadd7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Radio mode configuration register 0"] pub struct MODECNF0 (u32) ; impl MODECNF0 { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Radio ramp-up time"] pub fn ru (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Radio ramp-up time"] pub fn set_ru (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Default TX value"] pub fn dtx (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Default TX value"] pub fn set_dtx (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Peripheral power control"] pub struct POWER (u32) ; impl POWER { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again."] pub fn power (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again."] pub fn set_power (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer1 { # [doc = "Timer/Counter 1"] pub struct TIMER1 ; impl TIMER1 { pub const BASE_ADDR : u64 = 1073778688u64 ; } # [doc = "Start Timer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop Timer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Increment Timer (Counter mode only)"] pub struct TASKS_COUNT (u32) ; impl TASKS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear time"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Shut down timer"] pub struct TASKS_SHUTDOWN (u32) ; impl TASKS_SHUTDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE0 (u32) ; impl TASKS_CAPTURE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE1 (u32) ; impl TASKS_CAPTURE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE2 (u32) ; impl TASKS_CAPTURE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE3 (u32) ; impl TASKS_CAPTURE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn compare0_clear (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn set_compare0_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn compare1_clear (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn set_compare1_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn compare2_clear (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn set_compare2_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn compare3_clear (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn set_compare3_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn compare0_stop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn set_compare0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn compare1_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn set_compare1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn compare2_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn set_compare2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn compare3_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn set_compare3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer mode selection"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configure the number of bits used by the TIMER"] pub struct BITMODE (u32) ; impl BITMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer bit width"] pub fn bitmode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer bit width"] pub fn set_bitmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer prescaler register"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod saadc { # [doc = "Analog to Digital Converter"] pub struct SAADC ; impl SAADC { pub const BASE_ADDR : u64 = 1073770496u64 ; } # [doc = "Start the ADC and prepare the result buffer in RAM"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Take one ADC sample, if scan is enabled all channels are sampled"] pub struct TASKS_SAMPLE (u32) ; impl TASKS_SAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop the ADC and terminate any on-going conversion"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Starts offset auto-calibration"] pub struct TASKS_CALIBRATEOFFSET (u32) ; impl TASKS_CALIBRATEOFFSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The ADC has started"] pub struct EVENTS_STARTED (u32) ; impl EVENTS_STARTED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The ADC has filled up the Result buffer"] pub struct EVENTS_END (u32) ; impl EVENTS_END { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM."] pub struct EVENTS_DONE (u32) ; impl EVENTS_DONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "A result is ready to get transferred to RAM."] pub struct EVENTS_RESULTDONE (u32) ; impl EVENTS_RESULTDONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Calibration is complete"] pub struct EVENTS_CALIBRATEDONE (u32) ; impl EVENTS_CALIBRATEDONE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "The ADC has stopped"] pub struct EVENTS_STOPPED (u32) ; impl EVENTS_STOPPED { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH0_LIMITH (u32) ; impl EVENTS_CH0_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH0_LIMITL (u32) ; impl EVENTS_CH0_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH1_LIMITH (u32) ; impl EVENTS_CH1_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH1_LIMITL (u32) ; impl EVENTS_CH1_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH2_LIMITH (u32) ; impl EVENTS_CH2_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH2_LIMITL (u32) ; impl EVENTS_CH2_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH3_LIMITH (u32) ; impl EVENTS_CH3_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH3_LIMITL (u32) ; impl EVENTS_CH3_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH4_LIMITH (u32) ; impl EVENTS_CH4_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH4_LIMITL (u32) ; impl EVENTS_CH4_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH5_LIMITH (u32) ; impl EVENTS_CH5_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH5_LIMITL (u32) ; impl EVENTS_CH5_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH6_LIMITH (u32) ; impl EVENTS_CH6_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH6_LIMITL (u32) ; impl EVENTS_CH6_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or above CH[0].LIMIT.HIGH"] pub struct EVENTS_CH7_LIMITH (u32) ; impl EVENTS_CH7_LIMITH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Last results is equal or below CH[0].LIMIT.LOW"] pub struct EVENTS_CH7_LIMITL (u32) ; impl EVENTS_CH7_LIMITL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable interrupt"] pub struct INTEN (u32) ; impl INTEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enable or disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Enable or disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Enable or disable interrupt for DONE event"] pub fn done (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Enable or disable interrupt for DONE event"] pub fn set_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Enable or disable interrupt for RESULTDONE event"] pub fn resultdone (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable or disable interrupt for RESULTDONE event"] pub fn set_resultdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Enable or disable interrupt for CALIBRATEDONE event"] pub fn calibratedone (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Enable or disable interrupt for CALIBRATEDONE event"] pub fn set_calibratedone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Enable or disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Enable or disable interrupt for CH[0].LIMITH event"] pub fn ch0limith (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[0].LIMITH event"] pub fn set_ch0limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Enable or disable interrupt for CH[0].LIMITL event"] pub fn ch0limitl (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[0].LIMITL event"] pub fn set_ch0limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Enable or disable interrupt for CH[1].LIMITH event"] pub fn ch1limith (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[1].LIMITH event"] pub fn set_ch1limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable or disable interrupt for CH[1].LIMITL event"] pub fn ch1limitl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[1].LIMITL event"] pub fn set_ch1limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Enable or disable interrupt for CH[2].LIMITH event"] pub fn ch2limith (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[2].LIMITH event"] pub fn set_ch2limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Enable or disable interrupt for CH[2].LIMITL event"] pub fn ch2limitl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[2].LIMITL event"] pub fn set_ch2limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable or disable interrupt for CH[3].LIMITH event"] pub fn ch3limith (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[3].LIMITH event"] pub fn set_ch3limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enable or disable interrupt for CH[3].LIMITL event"] pub fn ch3limitl (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[3].LIMITL event"] pub fn set_ch3limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Enable or disable interrupt for CH[4].LIMITH event"] pub fn ch4limith (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[4].LIMITH event"] pub fn set_ch4limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Enable or disable interrupt for CH[4].LIMITL event"] pub fn ch4limitl (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[4].LIMITL event"] pub fn set_ch4limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Enable or disable interrupt for CH[5].LIMITH event"] pub fn ch5limith (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[5].LIMITH event"] pub fn set_ch5limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable or disable interrupt for CH[5].LIMITL event"] pub fn ch5limitl (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[5].LIMITL event"] pub fn set_ch5limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Enable or disable interrupt for CH[6].LIMITH event"] pub fn ch6limith (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[6].LIMITH event"] pub fn set_ch6limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable or disable interrupt for CH[6].LIMITL event"] pub fn ch6limitl (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[6].LIMITL event"] pub fn set_ch6limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Enable or disable interrupt for CH[7].LIMITH event"] pub fn ch7limith (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[7].LIMITH event"] pub fn set_ch7limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable or disable interrupt for CH[7].LIMITL event"] pub fn ch7limitl (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Enable or disable interrupt for CH[7].LIMITL event"] pub fn set_ch7limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for DONE event"] pub fn done (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for DONE event"] pub fn set_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Enable interrupt for RESULTDONE event"] pub fn resultdone (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for RESULTDONE event"] pub fn set_resultdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Enable interrupt for CALIBRATEDONE event"] pub fn calibratedone (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CALIBRATEDONE event"] pub fn set_calibratedone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Enable interrupt for CH[0].LIMITH event"] pub fn ch0limith (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[0].LIMITH event"] pub fn set_ch0limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Enable interrupt for CH[0].LIMITL event"] pub fn ch0limitl (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[0].LIMITL event"] pub fn set_ch0limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Enable interrupt for CH[1].LIMITH event"] pub fn ch1limith (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[1].LIMITH event"] pub fn set_ch1limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Enable interrupt for CH[1].LIMITL event"] pub fn ch1limitl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[1].LIMITL event"] pub fn set_ch1limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Enable interrupt for CH[2].LIMITH event"] pub fn ch2limith (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[2].LIMITH event"] pub fn set_ch2limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Enable interrupt for CH[2].LIMITL event"] pub fn ch2limitl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[2].LIMITL event"] pub fn set_ch2limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Enable interrupt for CH[3].LIMITH event"] pub fn ch3limith (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[3].LIMITH event"] pub fn set_ch3limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Enable interrupt for CH[3].LIMITL event"] pub fn ch3limitl (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[3].LIMITL event"] pub fn set_ch3limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Enable interrupt for CH[4].LIMITH event"] pub fn ch4limith (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[4].LIMITH event"] pub fn set_ch4limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Enable interrupt for CH[4].LIMITL event"] pub fn ch4limitl (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[4].LIMITL event"] pub fn set_ch4limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Write '1' to Enable interrupt for CH[5].LIMITH event"] pub fn ch5limith (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[5].LIMITH event"] pub fn set_ch5limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for CH[5].LIMITL event"] pub fn ch5limitl (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[5].LIMITL event"] pub fn set_ch5limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for CH[6].LIMITH event"] pub fn ch6limith (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[6].LIMITH event"] pub fn set_ch6limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for CH[6].LIMITL event"] pub fn ch6limitl (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[6].LIMITL event"] pub fn set_ch6limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for CH[7].LIMITH event"] pub fn ch7limith (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[7].LIMITH event"] pub fn set_ch7limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for CH[7].LIMITL event"] pub fn ch7limitl (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for CH[7].LIMITL event"] pub fn set_ch7limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn started (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STARTED event"] pub fn set_started (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for END event"] pub fn end (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for END event"] pub fn set_end (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for DONE event"] pub fn done (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for DONE event"] pub fn set_done (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Write '1' to Disable interrupt for RESULTDONE event"] pub fn resultdone (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for RESULTDONE event"] pub fn set_resultdone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Write '1' to Disable interrupt for CALIBRATEDONE event"] pub fn calibratedone (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CALIBRATEDONE event"] pub fn set_calibratedone (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn stopped (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for STOPPED event"] pub fn set_stopped (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Write '1' to Disable interrupt for CH[0].LIMITH event"] pub fn ch0limith (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[0].LIMITH event"] pub fn set_ch0limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Write '1' to Disable interrupt for CH[0].LIMITL event"] pub fn ch0limitl (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[0].LIMITL event"] pub fn set_ch0limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Write '1' to Disable interrupt for CH[1].LIMITH event"] pub fn ch1limith (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[1].LIMITH event"] pub fn set_ch1limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Write '1' to Disable interrupt for CH[1].LIMITL event"] pub fn ch1limitl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[1].LIMITL event"] pub fn set_ch1limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Write '1' to Disable interrupt for CH[2].LIMITH event"] pub fn ch2limith (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[2].LIMITH event"] pub fn set_ch2limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Write '1' to Disable interrupt for CH[2].LIMITL event"] pub fn ch2limitl (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[2].LIMITL event"] pub fn set_ch2limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Write '1' to Disable interrupt for CH[3].LIMITH event"] pub fn ch3limith (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[3].LIMITH event"] pub fn set_ch3limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Write '1' to Disable interrupt for CH[3].LIMITL event"] pub fn ch3limitl (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[3].LIMITL event"] pub fn set_ch3limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Write '1' to Disable interrupt for CH[4].LIMITH event"] pub fn ch4limith (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[4].LIMITH event"] pub fn set_ch4limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Write '1' to Disable interrupt for CH[4].LIMITL event"] pub fn ch4limitl (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[4].LIMITL event"] pub fn set_ch4limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Write '1' to Disable interrupt for CH[5].LIMITH event"] pub fn ch5limith (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[5].LIMITH event"] pub fn set_ch5limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for CH[5].LIMITL event"] pub fn ch5limitl (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[5].LIMITL event"] pub fn set_ch5limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for CH[6].LIMITH event"] pub fn ch6limith (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[6].LIMITH event"] pub fn set_ch6limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for CH[6].LIMITL event"] pub fn ch6limitl (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[6].LIMITL event"] pub fn set_ch6limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for CH[7].LIMITH event"] pub fn ch7limith (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[7].LIMITH event"] pub fn set_ch7limith (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for CH[7].LIMITL event"] pub fn ch7limitl (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for CH[7].LIMITL event"] pub fn set_ch7limitl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status"] pub struct STATUS (u32) ; impl STATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Status"] pub fn status (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Status"] pub fn set_status (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable or disable ADC"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable ADC"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Enable or disable ADC"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH0_PSELP (u32) ; impl CH0_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH0_PSELN (u32) ; impl CH0_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH0_CONFIG (u32) ; impl CH0_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH0_LIMIT (u32) ; impl CH0_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH1_PSELP (u32) ; impl CH1_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH1_PSELN (u32) ; impl CH1_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH1_CONFIG (u32) ; impl CH1_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH1_LIMIT (u32) ; impl CH1_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH2_PSELP (u32) ; impl CH2_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH2_PSELN (u32) ; impl CH2_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH2_CONFIG (u32) ; impl CH2_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH2_LIMIT (u32) ; impl CH2_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH3_PSELP (u32) ; impl CH3_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH3_PSELN (u32) ; impl CH3_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH3_CONFIG (u32) ; impl CH3_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH3_LIMIT (u32) ; impl CH3_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH4_PSELP (u32) ; impl CH4_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH4_PSELN (u32) ; impl CH4_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH4_CONFIG (u32) ; impl CH4_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH4_LIMIT (u32) ; impl CH4_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH5_PSELP (u32) ; impl CH5_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH5_PSELN (u32) ; impl CH5_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH5_CONFIG (u32) ; impl CH5_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH5_LIMIT (u32) ; impl CH5_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH6_PSELP (u32) ; impl CH6_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH6_PSELN (u32) ; impl CH6_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH6_CONFIG (u32) ; impl CH6_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH6_LIMIT (u32) ; impl CH6_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input positive pin selection for CH[0]"] pub struct CH7_PSELP (u32) ; impl CH7_PSELP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog positive input channel"] pub fn pselp (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog positive input channel"] pub fn set_pselp (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input negative pin selection for CH[0]"] pub struct CH7_PSELN (u32) ; impl CH7_PSELN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog negative input, enables differential channel"] pub fn pseln (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog negative input, enables differential channel"] pub fn set_pseln (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  Input configuration for CH[0]"] pub struct CH7_CONFIG (u32) ; impl CH7_CONFIG { pub const RESET_VALUE : u32 = 131072u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Positive channel resistor control"] pub fn resp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Positive channel resistor control"] pub fn set_resp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Negative channel resistor control"] pub fn resn (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Negative channel resistor control"] pub fn set_resn (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Gain control"] pub fn gain (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Gain control"] pub fn set_gain (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Reference control"] pub fn refsel (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Reference control"] pub fn set_refsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn tacq (& self) -> u32 { (self . 0 >> 16u32) & 7u32 } # [doc = "Acquisition time, the time the ADC uses to sample the input voltage"] pub fn set_tacq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable differential mode"] pub fn mode (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Enable differential mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Enable burst mode"] pub fn burst (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Enable burst mode"] pub fn set_burst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description cluster[0]:  High/low limits for event monitoring a channel"] pub struct CH7_LIMIT (u32) ; impl CH7_LIMIT { pub const RESET_VALUE : u32 = 2147450880u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low level limit"] pub fn low (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low level limit"] pub fn set_low (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High level limit"] pub fn high (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High level limit"] pub fn set_high (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Resolution configuration"] pub struct RESOLUTION (u32) ; impl RESOLUTION { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Set the resolution"] pub fn val (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Set the resolution"] pub fn set_val (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."] pub struct OVERSAMPLE (u32) ; impl OVERSAMPLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Oversample control"] pub fn oversample (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Oversample control"] pub fn set_oversample (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Controls normal or continuous sample rate"] pub struct SAMPLERATE (u32) ; impl SAMPLERATE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture and compare value. Sample rate is 16 MHz/CC"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Capture and compare value. Sample rate is 16 MHz/CC"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Select mode for sample rate control"] pub fn mode (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Select mode for sample rate control"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data pointer"] pub struct RESULT_PTR (u32) ; impl RESULT_PTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data pointer"] pub fn ptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data pointer"] pub fn set_ptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Maximum number of buffer words to transfer"] pub struct RESULT_MAXCNT (u32) ; impl RESULT_MAXCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum number of buffer words to transfer"] pub fn maxcnt (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Maximum number of buffer words to transfer"] pub fn set_maxcnt (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Number of buffer words transferred since last START"] pub struct RESULT_AMOUNT (u32) ; impl RESULT_AMOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of buffer words transferred since last START. This register can be read after an END or STOPPED event."] pub fn amount (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Number of buffer words transferred since last START. This register can be read after an END or STOPPED event."] pub fn set_amount (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod timer3 { # [doc = "Timer/Counter 3"] pub struct TIMER3 ; impl TIMER3 { pub const BASE_ADDR : u64 = 1073848320u64 ; } # [doc = "Start Timer"] pub struct TASKS_START (u32) ; impl TASKS_START { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop Timer"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Increment Timer (Counter mode only)"] pub struct TASKS_COUNT (u32) ; impl TASKS_COUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clear time"] pub struct TASKS_CLEAR (u32) ; impl TASKS_CLEAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Deprecated register -  Shut down timer"] pub struct TASKS_SHUTDOWN (u32) ; impl TASKS_SHUTDOWN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE0 (u32) ; impl TASKS_CAPTURE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE1 (u32) ; impl TASKS_CAPTURE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE2 (u32) ; impl TASKS_CAPTURE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE3 (u32) ; impl TASKS_CAPTURE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE4 (u32) ; impl TASKS_CAPTURE4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture Timer value to CC[0] register"] pub struct TASKS_CAPTURE5 (u32) ; impl TASKS_CAPTURE5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE0 (u32) ; impl EVENTS_COMPARE0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE1 (u32) ; impl EVENTS_COMPARE1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE2 (u32) ; impl EVENTS_COMPARE2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE3 (u32) ; impl EVENTS_COMPARE3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE4 (u32) ; impl EVENTS_COMPARE4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Compare event on CC[0] match"] pub struct EVENTS_COMPARE5 (u32) ; impl EVENTS_COMPARE5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn compare0_clear (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and CLEAR task"] pub fn set_compare0_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn compare1_clear (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and CLEAR task"] pub fn set_compare1_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn compare2_clear (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and CLEAR task"] pub fn set_compare2_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn compare3_clear (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and CLEAR task"] pub fn set_compare3_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Shortcut between COMPARE[4] event and CLEAR task"] pub fn compare4_clear (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Shortcut between COMPARE[4] event and CLEAR task"] pub fn set_compare4_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Shortcut between COMPARE[5] event and CLEAR task"] pub fn compare5_clear (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Shortcut between COMPARE[5] event and CLEAR task"] pub fn set_compare5_clear (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn compare0_stop (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Shortcut between COMPARE[0] event and STOP task"] pub fn set_compare0_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn compare1_stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Shortcut between COMPARE[1] event and STOP task"] pub fn set_compare1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn compare2_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Shortcut between COMPARE[2] event and STOP task"] pub fn set_compare2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn compare3_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Shortcut between COMPARE[3] event and STOP task"] pub fn set_compare3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Shortcut between COMPARE[4] event and STOP task"] pub fn compare4_stop (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Shortcut between COMPARE[4] event and STOP task"] pub fn set_compare4_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Shortcut between COMPARE[5] event and STOP task"] pub fn compare5_stop (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Shortcut between COMPARE[5] event and STOP task"] pub fn set_compare5_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[4] event"] pub fn compare4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[4] event"] pub fn set_compare4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Enable interrupt for COMPARE[5] event"] pub fn compare5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for COMPARE[5] event"] pub fn set_compare5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn compare0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[0] event"] pub fn set_compare0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn compare1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[1] event"] pub fn set_compare1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn compare2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[2] event"] pub fn set_compare2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn compare3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[3] event"] pub fn set_compare3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[4] event"] pub fn compare4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[4] event"] pub fn set_compare4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Write '1' to Disable interrupt for COMPARE[5] event"] pub fn compare5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for COMPARE[5] event"] pub fn set_compare5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer mode selection"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer mode"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer mode"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configure the number of bits used by the TIMER"] pub struct BITMODE (u32) ; impl BITMODE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer bit width"] pub fn bitmode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Timer bit width"] pub fn set_bitmode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Timer prescaler register"] pub struct PRESCALER (u32) ; impl PRESCALER { pub const RESET_VALUE : u32 = 4u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn prescaler (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Prescaler value"] pub fn set_prescaler (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC0 (u32) ; impl CC0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC1 (u32) ; impl CC1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC2 (u32) ; impl CC2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC3 (u32) ; impl CC3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC4 (u32) ; impl CC4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Description collection[0]:  Capture/Compare register 0"] pub struct CC5 (u32) ; impl CC5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn cc (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Capture/Compare value"] pub fn set_cc (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod ccm { # [doc = "AES CCM Mode Encryption"] pub struct CCM ; impl CCM { pub const BASE_ADDR : u64 = 1073803264u64 ; } # [doc = "Start generation of key-stream. This operation will stop by itself when completed."] pub struct TASKS_KSGEN (u32) ; impl TASKS_KSGEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Start encryption/decryption. This operation will stop by itself when completed."] pub struct TASKS_CRYPT (u32) ; impl TASKS_CRYPT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Stop encryption/decryption"] pub struct TASKS_STOP (u32) ; impl TASKS_STOP { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Key-stream generation complete"] pub struct EVENTS_ENDKSGEN (u32) ; impl EVENTS_ENDKSGEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Encrypt/decrypt complete"] pub struct EVENTS_ENDCRYPT (u32) ; impl EVENTS_ENDCRYPT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CCM error event"] pub struct EVENTS_ERROR (u32) ; impl EVENTS_ERROR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Shortcut register"] pub struct SHORTS (u32) ; impl SHORTS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Shortcut between ENDKSGEN event and CRYPT task"] pub fn endksgen_crypt (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Shortcut between ENDKSGEN event and CRYPT task"] pub fn set_endksgen_crypt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable interrupt"] pub struct INTENSET (u32) ; impl INTENSET { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Enable interrupt for ENDKSGEN event"] pub fn endksgen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDKSGEN event"] pub fn set_endksgen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Enable interrupt for ENDCRYPT event"] pub fn endcrypt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ENDCRYPT event"] pub fn set_endcrypt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Enable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Disable interrupt"] pub struct INTENCLR (u32) ; impl INTENCLR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write '1' to Disable interrupt for ENDKSGEN event"] pub fn endksgen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDKSGEN event"] pub fn set_endksgen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Write '1' to Disable interrupt for ENDCRYPT event"] pub fn endcrypt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ENDCRYPT event"] pub fn set_endcrypt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn error (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Write '1' to Disable interrupt for ERROR event"] pub fn set_error (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "MIC check result"] pub struct MICSTATUS (u32) ; impl MICSTATUS { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The result of the MIC check performed during the previous decryption operation"] pub fn micstatus (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "The result of the MIC check performed during the previous decryption operation"] pub fn set_micstatus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Enable"] pub struct ENABLE (u32) ; impl ENABLE { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Enable or disable CCM"] pub fn enable (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Enable or disable CCM"] pub fn set_enable (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Operation mode"] pub struct MODE (u32) ; impl MODE { pub const RESET_VALUE : u32 = 1u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "The mode of operation to be used"] pub fn mode (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "The mode of operation to be used"] pub fn set_mode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data rate that the CCM shall run in synch with"] pub fn datarate (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Data rate that the CCM shall run in synch with"] pub fn set_datarate (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Packet length configuration"] pub fn length (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Packet length configuration"] pub fn set_length (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pointer to data structure holding AES key and NONCE vector"] pub struct CNFPTR (u32) ; impl CNFPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview)"] pub fn cnfptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview)"] pub fn set_cnfptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Input pointer"] pub struct INPTR (u32) ; impl INPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Input pointer"] pub fn inptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Input pointer"] pub fn set_inptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Output pointer"] pub struct OUTPTR (u32) ; impl OUTPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Output pointer"] pub fn outptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Output pointer"] pub fn set_outptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pointer to data area used for temporary storage"] pub struct SCRATCHPTR (u32) ; impl SCRATCHPTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption."] pub fn scratchptr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption."] pub fn set_scratchptr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }
