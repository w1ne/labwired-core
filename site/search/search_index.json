{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LabWired Core Documentation","text":"<p>Welcome to the LabWired Core documentation. LabWired is a deterministic firmware simulation platform designed to replace physical hardware in CI pipelines.</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>If you are new to LabWired, start here:</p> <ul> <li>Running Your Firmware: Learn how to load ELF binaries and execute them in the simulator.</li> <li>Board Onboarding: Steps to add support for a new microcontroller or board.</li> </ul>"},{"location":"#core-concepts","title":"\ud83e\udde0 Core Concepts","text":"<p>Understand how LabWired achieves deterministic simulation:</p> <ul> <li>Architecture Overview: Explains the split between the CPU Core, System Bus, and Peripherals.</li> <li>Configuration Reference: Detailed schema for defining chips and systems (YAML).</li> </ul>"},{"location":"#developer-guides","title":"\ud83d\udee0 Developer Guides","text":"<p>For contributors extending the core engine or adding new peripherals:</p> <ul> <li>Peripheral Development: How to implement custom peripheral models in Rust.</li> <li>Declarative Registers: Defining register maps using simple YAML files.</li> <li>CI Integration: How to run LabWired in GitHub Actions or GitLab CI.</li> </ul>"},{"location":"#debugging","title":"\ud83d\udd0d Debugging","text":"<ul> <li>VS Code Debugging: Recipes for <code>launch.json</code>.</li> <li>Native DAP: Architecture of the built-in Debug Adapter.</li> <li>GDB Integration: Using standard GDB clients.</li> </ul>"},{"location":"#examples","title":"\ud83d\udcda Examples","text":"<p>Practical walkthroughs of specific features:</p> <ul> <li>I2C Sensor Simulation: Verify driver code against a mock I2C device.</li> <li>DMA &amp; Interrupts: Understanding the two-phase execution model.</li> </ul>"},{"location":"ARCHITECTURE/","title":"LabWired Architecture Guide","text":"<p>LabWired is a modular, high-fidelity embedded systems simulator written in Rust. It isolates hardware description (Asset Foundry) from execution logic (Core Engine), linked by a Strict Intermediate Representation (IR).</p> <pre><code>graph TD\n    %% Subsystems\n    subgraph \"Asset Foundry (Ingestion)\"\n        SVD[Vendor SVD] --&gt;|import-svd| IR[Strict IR (JSON)]\n        IR --&gt;|Codegen| RustModel[Rust Core Model]\n    end\n\n    subgraph \"Execution Engine (Core)\"\n        ELF[Firmware ELF] --&gt; Loader\n        Loader --&gt; Machine\n        RustModel --&gt; Machine\n\n        Machine --&gt; CPU[CPU (ARM/RISC-V)]\n        Machine --&gt; Bus[System Bus]\n        Bus --&gt; Memory\n        Bus --&gt; Peripherals\n    end\n\n    subgraph \"Interfaces\"\n        CLI[labwired-cli] --&gt; Machine\n        GDB[GDB Stub] -.-&gt; Machine\n        DAP[VS Code DAP] -.-&gt; Machine\n    end</code></pre>"},{"location":"ARCHITECTURE/#1-asset-foundry-cratesir","title":"1. Asset Foundry (<code>crates/ir</code>)","text":"<p>The Asset Foundry is the supply chain for simulation models. It solves the problem of \"dirty\" vendor data.</p> <ul> <li>Input: Vendor SVD files (often broken, inconsistent).</li> <li>Process: Use <code>labwired asset import-svd</code> to flatten, unroll, and sanitize.</li> <li>Output: Strict IR (<code>labwired-ir</code>). A JSON format where:<ul> <li>All arrays (<code>UART0</code>, <code>UART1</code>) are unrolled.</li> <li>All inheritance (<code>derivedFrom</code>) is resolved.</li> <li>All clusters are flattened.</li> </ul> </li> <li>Goal: Zero-ambiguity input for the simulation core.</li> </ul>"},{"location":"ARCHITECTURE/#2-the-core-engine-cratescore","title":"2. The Core Engine (<code>crates/core</code>)","text":"<p>The simulation runtime. It is <code>no_std</code> compatible and designed for deterministic execution.</p>"},{"location":"ARCHITECTURE/#components","title":"Components","text":"<ul> <li>Machine: The top-level container holding CPU, Bus, and Peripherals.</li> <li>Cpu Trait: Abstract interface allowing <code>Cortex-M</code> or <code>RISC-V</code> implementations to be swapped.</li> <li>SystemBus: dynamically routes memory accesses (<code>read</code>/<code>write</code>) to:<ul> <li>Linear Memory: RAM/Flash (byte arrays).</li> <li>Peripherals: Structs implementing the <code>Peripheral</code> trait.</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#two-phase-execution-state-side-effects","title":"Two-Phase Execution (State &amp; Side-Effects)","text":"<p>To satisfy Rust's borrow checker and ensure determinism: 1.  Tick Phase: Peripherals update internal state and return Request Objects (e.g., <code>DmaRequest</code>, <code>InterruptRequest</code>). 2.  Resolution Phase: The Bus processes these requests, modifying memory or triggering CPU exceptions.</p>"},{"location":"ARCHITECTURE/#3-peripheral-modeling","title":"3. Peripheral Modeling","text":"<p>We prioritize Tier 1 Devices for deep support (see <code>docs/SUPPORTED_DEVICES.md</code>): *   STM32F4 (Cortex-M4) *   RP2040 (Dual Cortex-M0+) *   nRF52 (Cortex-M4F)</p> <p>Peripherals are implemented as Rust structs that mimic hardware logic (registers, bitfields, state machines).</p>"},{"location":"ARCHITECTURE/#4-interfaces-cratescli-cratesdap","title":"4. Interfaces (<code>crates/cli</code>, <code>crates/dap</code>)","text":"<ul> <li>CLI: The main entry point. Runs simulations, imports assets, and manages configuration.</li> <li>DAP Server: Implements the Debug Adapter Protocol for seamless VS Code integration.<ul> <li>Typically listens on TCP <code>5000</code>.</li> <li>Provides specialized telemetry events (PC, Cycles, Power) to the IDE.</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#directory-structure","title":"Directory Structure","text":"<ul> <li><code>core/crates/ir</code>: Strict IR definitions and SVD transformation logic.</li> <li><code>core/crates/core</code>: CPU, Bus, and Device traits.</li> <li><code>core/crates/cli</code>: Command-line driver.</li> <li><code>core/crates/loader</code>: ELF parsing.</li> <li><code>core/crates/config</code>: Configuration file parsing (system manifest).</li> </ul>"},{"location":"advanced_peripherals/","title":"Advanced STM32 Peripherals Design","text":"<p>This document describes the architectural approach for supporting complex STM32 systems in LabWired, focusing on DMA, EXTI, and AFIO.</p>"},{"location":"advanced_peripherals/#direct-memory-access-dma","title":"Direct Memory Access (DMA)","text":"<p>LabWired implements DMA using a two-phase request/execute model to maintain architectural modularity and comply with Rust's ownership rules.</p>"},{"location":"advanced_peripherals/#design-principles","title":"Design Principles","text":"<ol> <li>Decoupling: The DMA controller is a standard <code>Peripheral</code>. It doesn't have direct access to the <code>SystemBus</code> to avoid circular dependencies.</li> <li>Request-Based Mastering: During its <code>tick()</code>, a peripheral (like DMA) returns a list of <code>DmaRequest</code> objects.</li> <li>Bus Execution: The <code>SystemBus</code> executes these requests after the peripheral tick phase, effectively acting as the \"arbiter\".</li> </ol>"},{"location":"advanced_peripherals/#execution-flow","title":"Execution Flow","text":"<ol> <li>Phase 1: Tick: <code>SystemBus</code> calls <code>tick()</code> on all peripherals.</li> <li>Phase 2: Collect: <code>SystemBus</code> aggregates all <code>DmaRequest</code>s returned by peripherals.</li> <li>Phase 3: Execute: <code>SystemBus</code> performs the memory operations (Read/Write) requested by the DMA.</li> </ol> <pre><code>sequenceDiagram\n    participant B as SystemBus\n    participant D as DMA Peripheral\n    participant R as RAM / Peripheral\n\n    B-&gt;&gt;D: tick()\n    D--&gt;&gt;B: Vec&lt;DmaRequest&gt;\n    loop Each Request\n        B-&gt;&gt;R: read_u8/write_u8\n    end</code></pre>"},{"location":"advanced_peripherals/#external-interrupts-exti-afio","title":"External Interrupts (EXTI) &amp; AFIO","text":"<p>EXTI and AFIO work together to map GPIO signals to processor interrupts.</p>"},{"location":"advanced_peripherals/#exti-mapping","title":"EXTI Mapping","text":"<p>EXTI handles 16 lines corresponding to GPIO pins 0-15. -   Line 0: GPIOA pin 0, GPIOB pin 0, etc. (selected via AFIO) -   Lines 16-19: Specific events (PVD, RTC, USB, etc.)</p>"},{"location":"advanced_peripherals/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Signal Propagation: Peripherals can now emit signals or trigger other peripherals via a <code>SignalBus</code> (future enhancement) or direct wiring in <code>SystemBus</code>.</li> <li>Configurable Mapping: AFIO registers define which GPIO port maps to which EXTI line.</li> </ol>"},{"location":"advanced_peripherals/#current-support-status","title":"Current Support Status","text":"Feature Status Notes DMA Mastering [x] Implemented Two-phase execution in <code>SystemBus</code>. EXTI Controller [ ] Planned Standard STM32F103 mapping. AFIO Remapping [ ] Planned Basic pin mapping support."},{"location":"architecture/","title":"Architecture Internals","text":"<p>LabWired is a modular execution engine designed to decouple the CPU core from the memory and peripheral bus. This design enables the simulation of multi-architecture systems within a unified peripheral environment.</p>"},{"location":"architecture/#1-core-execution-engine-labwired-core","title":"1. Core Execution Engine (<code>labwired-core</code>)","text":"<p>The <code>labwired-core</code> crate provides the central execution loop and state management.</p>"},{"location":"architecture/#pluggable-cpu-abstraction","title":"Pluggable CPU Abstraction","text":"<p>The execution engine is generic over a <code>Cpu</code> trait, allowing for different instruction set architectures (ISAs) to interface with the same system bus.</p> <pre><code>pub trait Cpu {\n    /// Resets the CPU state (PC, SP, etc.)\n    fn reset(&amp;mut self, bus: &amp;mut dyn Bus) -&gt; SimResult&lt;()&gt;;\n\n    /// Executes a single instruction cycle\n    fn step(&amp;mut self, bus: &amp;mut dyn Bus) -&gt; SimResult&lt;()&gt;;\n}\n</code></pre> <p>The system currently implements: - Cortex-M (ARMv7-M): Supports Thumb-2 instruction decoding. - RISC-V (RV32I): Supports base integer instruction set.</p>"},{"location":"architecture/#memory-model","title":"Memory Model","text":"<p>The memory system uses a linear addressing model mapped to host memory regions. - Flash: Read-only segments populated from the ELF binary. - RAM: Read-write segments initialized to zero. - MMIO: Addresses outside predefined memory regions are routed to the Peripheral Bus.</p>"},{"location":"architecture/#2-peripheral-interface","title":"2. Peripheral Interface","text":"<p>Peripherals communicate with the CPU via the <code>Peripheral</code> trait. This trait defines the contract for Memory-Mapped I/O (MMIO) and time-based state updates.</p> <pre><code>pub trait Peripheral {\n    fn read(&amp;self, offset: u64) -&gt; u8;\n    fn write(&amp;mut self, offset: u64, value: u8);\n    fn tick(&amp;mut self) -&gt; PeripheralTickResult;\n}\n</code></pre>"},{"location":"architecture/#two-phase-execution-model","title":"Two-Phase Execution Model","text":"<p>To ensure deterministic behavior for DMA and interrupts, LabWired employs a two-phase update cycle for each simulation tick:</p> <ol> <li>Instruction Step: The CPU fetches and executes one instruction.</li> <li>Peripheral Tick: Each peripheral's <code>tick()</code> method is invoked. Peripherals return a <code>PeripheralTickResult</code> containing requested state changes (IRQs, DMA requests).</li> <li>Bus Arbitration: The <code>SystemBus</code> processes pending DMA requests and updates the Interrupt Controller state.</li> </ol> <p>This model prevents race conditions where a peripheral modifies memory while the CPU is executing, ensuring strict sequential consistency.</p>"},{"location":"architecture/#3-thumb-2-decoder","title":"3. Thumb-2 Decoder","text":"<p>The Cortex-M implementation uses a custom stateless decoder for the ARMv7-M Thumb-2 instruction set.</p> <p>Supported Instruction Classes: - 32-bit Instructions: <code>BL</code>, <code>MOVW</code>, <code>MOVT</code> (handled via double half-word fetch). - Control Flow: <code>B</code>, <code>BL</code>, <code>BX</code>, <code>CBZ/CBNZ</code>, <code>IT</code> blocks. - Arithmetic/Logic: <code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>SDIV/UDIV</code>, <code>AND</code>, <code>ORR</code>, <code>EOR</code>. - Bit Manipulation: <code>BFI</code>, <code>UBFX</code>, <code>CLZ</code>, <code>RBIT</code>.</p>"},{"location":"architecture/#4-debug-integration","title":"4. Debug Integration","text":"<p>LabWired integrates with external debuggers via standard protocols.</p>"},{"location":"architecture/#gdb-remote-serial-protocol-rsp","title":"GDB Remote Serial Protocol (RSP)","text":"<p>The <code>labwired-gdbstub</code> crate implements the RSP server, allowing <code>gdb-multiarch</code> to attach to the simulation. It supports: - Breakpoints (Software/Hardware) - Single-stepping - Register and Memory inspection</p>"},{"location":"architecture/#debug-adapter-protocol-dap","title":"Debug Adapter Protocol (DAP)","text":"<p>The <code>labwired-dap</code> crate provides a direct interface for VS Code. It exposes: - State Inspection: Live view of registers and call stack. - Telemetry: A custom event stream for real-time performance metrics (Cycles, MIPS) without polling overhead.</p>"},{"location":"architecture_guide/","title":"LabWired Architecture Guide","text":"<p>LabWired is a modular, high-fidelity embedded systems simulator written in Rust. It isolates hardware description (Asset Foundry) from execution logic (Core Engine), linked by a Strict Intermediate Representation (IR).</p> <pre><code>graph TD\n    %% Subsystems\n    subgraph \"Asset Foundry (Ingestion)\"\n        SVD[Vendor SVD] --&gt;|import-svd| IR[Strict IR (JSON)]\n        IR --&gt;|Codegen| RustModel[Rust Core Model]\n    end\n\n    subgraph \"Execution Engine (Core)\"\n        ELF[Firmware ELF] --&gt; Loader\n        Loader --&gt; Machine\n        RustModel --&gt; Machine\n\n        Machine --&gt; CPU[CPU (ARM/RISC-V)]\n        Machine --&gt; Bus[System Bus]\n        Bus --&gt; Memory\n        Bus --&gt; Peripherals\n    end\n\n    subgraph \"Interfaces\"\n        CLI[labwired-cli] --&gt; Machine\n        GDB[GDB Stub] -.-&gt; Machine\n        DAP[VS Code DAP] -.-&gt; Machine\n    end</code></pre>"},{"location":"architecture_guide/#1-asset-foundry-cratesir","title":"1. Asset Foundry (<code>crates/ir</code>)","text":"<p>The Asset Foundry is the supply chain for simulation models. It solves the problem of \"dirty\" vendor data.</p> <ul> <li>Input: Vendor SVD files (often broken, inconsistent).</li> <li>Process: Use <code>labwired asset import-svd</code> to flatten, unroll, and sanitize.</li> <li>Output: Strict IR (<code>labwired-ir</code>). A JSON format where:<ul> <li>All arrays (<code>UART0</code>, <code>UART1</code>) are unrolled.</li> <li>All inheritance (<code>derivedFrom</code>) is resolved.</li> <li>All clusters are flattened.</li> </ul> </li> <li>Goal: Zero-ambiguity input for the simulation core.</li> </ul>"},{"location":"architecture_guide/#2-the-core-engine-cratescore","title":"2. The Core Engine (<code>crates/core</code>)","text":"<p>The simulation runtime. It is <code>no_std</code> compatible and designed for deterministic execution.</p>"},{"location":"architecture_guide/#components","title":"Components","text":"<ul> <li>Machine: The top-level container holding CPU, Bus, and Peripherals.</li> <li>Cpu Trait: Abstract interface allowing <code>Cortex-M</code> or <code>RISC-V</code> implementations to be swapped.</li> <li>SystemBus: dynamically routes memory accesses (<code>read</code>/<code>write</code>) to:<ul> <li>Linear Memory: RAM/Flash (byte arrays).</li> <li>Peripherals: Structs implementing the <code>Peripheral</code> trait.</li> </ul> </li> </ul>"},{"location":"architecture_guide/#two-phase-execution-state-side-effects","title":"Two-Phase Execution (State &amp; Side-Effects)","text":"<p>To satisfy Rust's borrow checker and ensure determinism: 1.  Tick Phase: Peripherals update internal state and return Request Objects (e.g., <code>DmaRequest</code>, <code>InterruptRequest</code>). 2.  Resolution Phase: The Bus processes these requests, modifying memory or triggering CPU exceptions.</p>"},{"location":"architecture_guide/#3-peripheral-modeling","title":"3. Peripheral Modeling","text":"<p>We prioritize Tier 1 Devices for deep support (see <code>docs/release_strategy.md</code>): *   STM32F4 (Cortex-M4) *   RP2040 (Dual Cortex-M0+) *   nRF52 (Cortex-M4F)</p> <p>Peripherals are implemented as Rust structs that mimic hardware logic (registers, bitfields, state machines).</p>"},{"location":"architecture_guide/#4-interfaces-cratescli-cratesdap","title":"4. Interfaces (<code>crates/cli</code>, <code>crates/dap</code>)","text":"<ul> <li>CLI: The main entry point. Runs simulations, imports assets, and manages configuration.</li> <li>DAP Server: Implements the Debug Adapter Protocol for seamless VS Code integration.<ul> <li>Typically listens on TCP <code>5000</code>.</li> <li>Provides specialized telemetry events (PC, Cycles, Power) to the IDE.</li> </ul> </li> </ul>"},{"location":"architecture_guide/#directory-structure","title":"Directory Structure","text":"<ul> <li><code>core/crates/ir</code>: Strict IR definitions and SVD transformation logic.</li> <li><code>core/crates/core</code>: CPU, Bus, and Device traits.</li> <li><code>core/crates/cli</code>: Command-line driver.</li> <li><code>core/crates/loader</code>: ELF parsing.</li> <li><code>core/crates/config</code>: Configuration file parsing (system manifest).</li> </ul>"},{"location":"board_onboarding_playbook/","title":"Board Onboarding Playbook (Agent Runbook)","text":"<p>This runbook documents how to add a new board target to the LabWired core engine in a way that is reliable for future agents.</p>"},{"location":"board_onboarding_playbook/#standard-procedure-typical-onboarding-task","title":"Standard Procedure (Typical Onboarding Task)","text":"<p>Use this as the default flow for every new board onboarding request.</p>"},{"location":"board_onboarding_playbook/#phase-0-source-grounding","title":"Phase 0: Source Grounding","text":"<p>Inputs: - board/MCU name from user</p> <p>Actions: 1. Gather primary sources (CMSIS device header + board BSP header). 2. Capture source URLs in working notes.</p> <p>Exit criteria: - base addresses, IRQs, and board COM/LED mapping are traceable to primary docs.</p>"},{"location":"board_onboarding_playbook/#phase-1-engine-fit-and-scope","title":"Phase 1: Engine Fit and Scope","text":"<p>Actions: 1. Compare target needs against currently supported peripheral <code>type</code> values. 2. Select minimal bring-up scope when full silicon coverage is not feasible.</p> <p>Exit criteria: - explicit list of modeled vs deferred peripherals.</p>"},{"location":"board_onboarding_playbook/#phase-2-configuration-and-firmware-implementation","title":"Phase 2: Configuration and Firmware Implementation","text":"<p>Actions: 1. Add chip descriptor (<code>core/configs/chips/&lt;chip&gt;.yaml</code>). 2. Add system manifest (<code>core/configs/systems/&lt;board&gt;.yaml</code>). 3. Add/adapt smoke firmware crate for deterministic UART output. 4. Add/adjust engine tests if runtime behavior changed.</p> <p>Exit criteria: - code builds and configuration loads.</p>"},{"location":"board_onboarding_playbook/#phase-3-example-folder-documentation-pack","title":"Phase 3: Example Folder Documentation Pack","text":"<p>Create <code>core/examples/&lt;board&gt;/</code> with:</p> <ol> <li><code>system.yaml</code></li> <li><code>README.md</code></li> <li><code>REQUIRED_DOCS.md</code></li> <li><code>EXTERNAL_COMPONENTS.md</code></li> <li><code>VALIDATION.md</code></li> </ol> <p>Exit criteria: - docs are complete and commands are executable as written.</p>"},{"location":"board_onboarding_playbook/#phase-4-validation","title":"Phase 4: Validation","text":"<p>Actions: 1. Run tests. 2. Build smoke firmware. 3. Run simulator with example-local <code>system.yaml</code>.</p> <p>Exit criteria: - PC/SP initialize correctly - UART smoke output observed - test suite changes pass</p>"},{"location":"board_onboarding_playbook/#phase-5-handoff-report","title":"Phase 5: Handoff Report","text":"<p>Include: 1. files changed 2. exact commands run 3. key runtime output evidence 4. source links used</p>"},{"location":"board_onboarding_playbook/#goal","title":"Goal","text":"<p>Given a real MCU board (example: NUCLEO-H563ZI), produce:</p> <ol> <li>A chip descriptor in <code>core/configs/chips/</code></li> <li>A board/system manifest in <code>core/configs/systems/</code></li> <li>A minimal firmware smoke test that proves reset + UART path works</li> <li>A deterministic validation command sequence</li> </ol>"},{"location":"board_onboarding_playbook/#engine-reality-check-do-this-first","title":"Engine Reality Check (Do This First)","text":"<p>Before modeling a board, confirm currently supported peripheral <code>type</code> values in <code>SystemBus::from_config</code>:</p> <ul> <li><code>uart</code></li> <li><code>systick</code></li> <li><code>gpio</code></li> <li><code>rcc</code></li> <li><code>timer</code></li> <li><code>i2c</code></li> <li><code>spi</code></li> <li><code>exti</code></li> <li><code>afio</code></li> <li><code>dma</code></li> <li><code>adc</code></li> <li><code>declarative</code> / <code>strict_ir</code></li> </ul> <p>If the board has many unsupported blocks, pick a minimal subset that can boot and demonstrate value (typically <code>rcc + gpio + uart + systick</code>).</p>"},{"location":"board_onboarding_playbook/#universal-peripheral-config-structure","title":"Universal Peripheral Config Structure","text":"<p>Use a single config key for built-in peripheral variants:</p> <ul> <li><code>config.profile</code>: profile selector for modeled register map/behavior</li> </ul> <p>Current built-in profile-enabled peripherals:</p> <ul> <li><code>gpio</code>: <code>stm32f1</code>, <code>stm32v2</code></li> <li><code>uart</code>: <code>stm32f1</code>, <code>stm32v2</code></li> <li><code>rcc</code>: <code>stm32f1</code>, <code>stm32v2</code></li> </ul> <p>Backward compatibility:</p> <ul> <li><code>config.register_layout</code> is still accepted as a legacy alias for <code>config.profile</code>.</li> </ul>"},{"location":"board_onboarding_playbook/#required-source-material","title":"Required Source Material","text":"<p>Use primary vendor sources:</p> <ol> <li>MCU CMSIS device header for memory map and IRQ numbers</li> <li>Board BSP header for LED/UART/button pin mapping</li> <li>Board/MCU product pages for traceability</li> </ol> <p>For STM32H563ZI demo:</p> <ul> <li>MCU header: <code>stm32h563xx.h</code> (<code>cmsis-device-h5</code>)</li> <li>Board BSP: <code>stm32h5xx_nucleo.h</code> (<code>stm32h5xx-nucleo-bsp</code>)</li> </ul>"},{"location":"board_onboarding_playbook/#implementation-steps","title":"Implementation Steps","text":""},{"location":"board_onboarding_playbook/#1-create-chip-descriptor","title":"1) Create chip descriptor","text":"<p>Add <code>core/configs/chips/&lt;chip&gt;.yaml</code> with:</p> <ul> <li><code>flash.base</code> and <code>flash.size</code></li> <li><code>ram.base</code> and <code>ram.size</code></li> <li>only supported peripherals with correct base addresses/IRQs</li> </ul> <p>H563 example file: <code>core/configs/chips/stm32h563.yaml</code></p>"},{"location":"board_onboarding_playbook/#2-create-boardsystem-manifest","title":"2) Create board/system manifest","text":"<p>Add <code>core/configs/systems/&lt;board&gt;.yaml</code> pointing at the chip descriptor.</p> <p>H563 example file: <code>core/configs/systems/nucleo-h563zi-demo.yaml</code></p>"},{"location":"board_onboarding_playbook/#3-ensure-reset-vector-fetch-works","title":"3) Ensure reset vector fetch works","text":"<p>Important: Cortex-M reset reads vectors from address <code>0x00000000</code>. If flash is at <code>0x08000000</code>, engine must support boot aliasing or firmware must be linked at <code>0x00000000</code>.</p> <p>For H563, boot alias support was implemented in:</p> <ul> <li><code>core/crates/core/src/bus/mod.rs</code></li> </ul> <p>This maps reads/writes from <code>0x00000000..flash_size</code> to <code>flash.base</code>.</p>"},{"location":"board_onboarding_playbook/#4-add-minimal-firmware-smoke-target","title":"4) Add minimal firmware smoke target","text":"<p>Create a tiny <code>no_std</code> firmware that:</p> <ol> <li>has a valid vector table</li> <li>writes <code>OK\\n</code> to the mapped UART TX register</li> <li>loops forever</li> </ol> <p>H563 example crate:</p> <ul> <li><code>core/crates/firmware-h563-demo/</code></li> </ul>"},{"location":"board_onboarding_playbook/#5-register-crate-in-workspace","title":"5) Register crate in workspace","text":"<p>Add the new demo crate path in <code>core/Cargo.toml</code> <code>[workspace].members</code>.</p>"},{"location":"board_onboarding_playbook/#validation-commands","title":"Validation Commands","text":"<p>Run from <code>core/</code>:</p> <pre><code>cargo test -p labwired-core test_flash_boot_alias_read_and_write -- --nocapture\ncargo build -p firmware-h563-demo --release --target thumbv7m-none-eabi\ncargo run -q -p labwired-cli -- \\\n  --firmware target/thumbv7m-none-eabi/release/firmware-h563-demo \\\n  --system configs/systems/nucleo-h563zi-demo.yaml \\\n  --max-steps 32\n</code></pre> <p>Expected outcome:</p> <ul> <li>simulator starts successfully</li> <li>PC initializes to flash region (<code>0x08000000</code> range)</li> <li>UART output contains <code>OK</code></li> </ul>"},{"location":"board_onboarding_playbook/#common-failure-modes","title":"Common Failure Modes","text":"<ol> <li> <p>PC stays at <code>0x00000000</code> or faults immediately. Cause: reset vectors are not reachable at <code>0x00000000</code>. Fix: add boot alias handling or link vector table at <code>0x00000000</code>.</p> </li> <li> <p>Simulator loads but no UART output appears. Cause: wrong UART base address/instance for board COM port. Fix: verify BSP mapping (<code>COM1_UART</code>, TX/RX pin macros) and chip base address.</p> </li> <li> <p>Memory violations right after reset. Cause: incorrect <code>flash.base</code>, <code>ram.base</code>, or RAM size. Fix: re-check CMSIS header base/size constants.</p> </li> <li> <p>Build succeeds but firmware never reaches user code. Cause: invalid minimal linker script/vector table. Fix: verify initial SP is in RAM range and reset handler uses Thumb bit (<code>Reset + 1</code>).</p> </li> </ol>"},{"location":"board_onboarding_playbook/#agent-decision-rules","title":"Agent Decision Rules","text":"<p>When onboarding a new board, follow these rules:</p> <ol> <li>Prefer correctness over coverage: model fewer peripherals accurately.</li> <li>Use vendor headers as source of truth for addresses and IRQs.</li> <li>Always include a deterministic smoke firmware and command log.</li> <li>Add at least one unit test for any engine behavior change.</li> <li>Document assumptions and known gaps directly in the chip YAML comments.</li> </ol>"},{"location":"board_onboarding_playbook/#handoff-checklist","title":"Handoff Checklist","text":"<p>Before finishing, ensure these are all done:</p> <ol> <li><code>core/configs/chips/&lt;chip&gt;.yaml</code> added and commented with source references.</li> <li><code>core/configs/systems/&lt;board&gt;.yaml</code> added.</li> <li>Demo firmware crate added (or existing fixture adapted).</li> <li>Engine tests updated if runtime behavior changed.</li> <li><code>core/examples/&lt;board&gt;/</code> documentation pack exists and is complete.</li> <li>Commands and observed output included in final response.</li> </ol>"},{"location":"board_onboarding_playbook/#known-gaps-for-h563-demo","title":"Known Gaps for H563 Demo","text":"<ul> <li>Peripheral behavior is still generic (not H5 register-accurate yet).</li> <li>Board-level LED/button electrical behavior is not modeled.</li> <li>This is a bring-up profile for demo/agent workflow, not final silicon-fidelity.</li> </ul>"},{"location":"case_study_stm32/","title":"Case Study: Debugging STM32 Without Hardware","text":""},{"location":"case_study_stm32/#the-problem","title":"The Problem","text":"<p>Embedded development typically requires physical hardware, even for basic testing. This leads to several challenges: - Bottlenecks: Teams waiting for prototype hardware to arrive. - Complexity: Debugging I2C/SPI timing issues requires logic analyzers or oscilloscopes. - CI/CD Gaps: Hard to run automated tests for firmware on real hardware in every PR.</p>"},{"location":"case_study_stm32/#the-labwired-solution","title":"The LabWired Solution","text":"<p>LabWired allows developers to simulate an entire STM32-based system, including external peripherals like sensors, directly in their local environment and VS Code.</p>"},{"location":"case_study_stm32/#scenario-i2c-temperature-sensor-integration","title":"Scenario: I2C Temperature Sensor Integration","text":"<p>In this demo, we integrated a TMP102 temperature sensor with an STM32F103 microcontroller.</p>"},{"location":"case_study_stm32/#1-hardware-free-simulation","title":"1. Hardware-Free Simulation","text":"<p>Instead of wiring physical pins, we defined the sensor and its connection in a declarative YAML file:</p> <pre><code># system.yaml\nexternal_devices:\n  - id: \"temp_sensor\"\n    type: \"tmp102\"\n    connection: \"i2c1\"\n    config:\n      i2c_address: 0x48\n</code></pre>"},{"location":"case_study_stm32/#2-realistic-firmware","title":"2. Realistic Firmware","text":"<p>The firmware uses standard STM32 peripheral registers (RCC, GPIO, I2C) to communicate with the virtual sensor. The emulator handles these register accesses and routes them to the virtual device model.</p>"},{"location":"case_study_stm32/#3-one-click-debugging","title":"3. One-Click Debugging","text":"<p>Using the LabWired VS Code extension, the developer can: - Set Breakpoints: Pause execution exactly where the sensor is being read. - Inspect Registers: View the status of the I2C control registers and the data register. - Step Through Logic: Verify that the temperature conversion logic handles negative values or overflow correctly.</p>"},{"location":"case_study_stm32/#impact","title":"Impact","text":"<ul> <li>Zero Setup Costs: No hardware, cables, or probes required.</li> <li>Instant Reproducibility: High-fidelity simulation ensures a bug in simulation is a bug in hardware.</li> <li>Modern Workflow: Bring the power of modern software development (CI/CD, fast iteration) to the embedded world.</li> </ul>"},{"location":"case_study_stm32/#technical-highlights","title":"Technical Highlights","text":"<ul> <li>Cortex-M3 Core: High-fidelity instruction execution.</li> <li>Declarative Peripherals: Easily add new sensors by writing YAML descriptors.</li> <li>DAP Integration: Seamless connection to VS Code.</li> </ul> <p>Back to LabWired Core</p>"},{"location":"ci_integration/","title":"CI Integration","text":"<p>This guide details the integration of LabWired firmware simulations into continuous integration (CI) pipelines. By replacing physical hardware with deterministic simulation, teams can achieve scalable, parallelized regression testing.</p>"},{"location":"ci_integration/#1-quick-start","title":"1. Quick Start","text":""},{"location":"ci_integration/#github-actions","title":"GitHub Actions","text":"<p>To enable automated testing on every push, create a workflow file at <code>.github/workflows/firmware-test.yml</code>:</p> <pre><code>name: Firmware Simulation\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build Firmware\n        run: cargo build --release --target thumbv7m-none-eabi\n\n      - name: Run Simulation\n        uses: w1ne/labwired/.github/actions/labwired-test@main\n        with:\n          script: tests/basic_boot.yaml\n          artifact_name: test-results\n</code></pre>"},{"location":"ci_integration/#gitlab-ci","title":"GitLab CI","text":"<p>For GitLab, add the following to <code>.gitlab-ci.yml</code>:</p> <pre><code>test_simulation:\n  image: rust:latest\n  script:\n    - cargo build --release --target thumbv7m-none-eabi\n    - curl -L https://github.com/w1ne/labwired/releases/latest/download/labwired-cli -o labwired\n    - chmod +x labwired\n    - ./labwired test --script tests/basic_boot.yaml\n</code></pre>"},{"location":"ci_integration/#2-test-script-schema","title":"2. Test Script Schema","text":"<p>LabWired uses a YAML-based test definition format to specify inputs, constraints, and assertions.</p> <pre><code>schema_version: \"1.0\"\n\ninputs:\n  firmware: \"target/thumbv7m-none-eabi/release/firmware.elf\"\n  system: \"configs/system.yaml\"\n\nlimits:\n  max_steps: 100000        # Instruction limit\n  wall_time_ms: 5000       # Real-time timeout\n  max_cycles: 50000000     # Simulation cycle limit\n\nassertions:\n  - uart_contains: \"Boot Successful\"\n  - expected_stop_reason: \"halt\"\n</code></pre>"},{"location":"ci_integration/#3-integration-patterns","title":"3. Integration Patterns","text":""},{"location":"ci_integration/#matrix-testing","title":"Matrix Testing","text":"<p>Validate firmware across multiple compile targets or configurations in parallel.</p> <p>GitHub Actions Example: <pre><code>strategy:\n  matrix:\n    target: [thumbv6m-none-eabi, thumbv7m-none-eabi]\nsteps:\n  - run: cargo build --target ${{ matrix.target }}\n  - uses: w1ne/labwired/.github/actions/labwired-test@main\n    with:\n      script: tests/${{ matrix.target }}.yaml\n</code></pre></p>"},{"location":"ci_integration/#fault-injection","title":"Fault Injection","text":"<p>Simulate hardware failures (e.g., sensor disconnects) in CI to verify error handling paths that are difficult to trigger on physical devices.</p> <pre><code># tests/sensor_fail.yaml\nsteps:\n  - run: 100ms\n  - write_peripheral:\n      id: \"i2c1\"\n      reg: \"CR1\"\n      value: 0x0000 # Disable I2C controller mid-operation\n  - assert_log: \"I2C Error Detected\"\n</code></pre>"},{"location":"ci_integration/#4-artifacts-and-reporting","title":"4. Artifacts and Reporting","text":"<p>The test runner produces machine-readable outputs for integration with CI reporting tools.</p> <ul> <li><code>result.json</code>: Detailed execution statistics (cycles, instructions, assertion results).</li> <li><code>junit.xml</code>: Standard JUnit format for test result visualization in GitHub/GitLab UI.</li> <li><code>uart.log</code>: Captured serial output for debugging failures.</li> </ul> <p>Ensure your CI pipeline is configured to archive these artifacts upon failure.</p>"},{"location":"ci_test_runner/","title":"CI Test Runner (<code>labwired test</code>)","text":"<p>LabWired provides a CI-friendly runner mode driven by a YAML test script:</p> <pre><code>labwired test --script test.yaml\n</code></pre> <p>You can override script inputs with CLI flags:</p> <pre><code>labwired test --firmware path/to/fw.elf --system system.yaml --script test.yaml\n</code></pre>"},{"location":"ci_test_runner/#exit-codes","title":"Exit Codes","text":"Code Meaning Notes <code>0</code> Pass All assertions passed, and any non-success stop reason was explicitly asserted (if applicable). <code>1</code> Assertion failure Includes failed assertions, and hitting <code>wall_time_ms</code> / <code>max_uart_bytes</code> / <code>no_progress_steps</code> without asserting the matching <code>expected_stop_reason</code>. <code>2</code> Config/script error Invalid YAML, unknown fields, unsupported schema_version, missing/invalid inputs/limits, or a safety guard (e.g. max-steps cap). <code>3</code> Simulation/runtime error Runtime failure (e.g. <code>memory_violation</code>, <code>decode_error</code>) unless an <code>expected_stop_reason</code> assertion matches the stop reason. <p>Exit-code precedence: 1) Any failed assertion \u21d2 <code>1</code> (even if a runtime error also occurred) 2) <code>wall_time</code> / <code>max_uart_bytes</code> / <code>no_progress</code> stop without matching <code>expected_stop_reason</code> \u21d2 <code>1</code> 3) Runtime error stop without matching <code>expected_stop_reason</code> \u21d2 <code>3</code> 4) Otherwise \u21d2 <code>0</code></p>"},{"location":"ci_test_runner/#script-schema-v10","title":"Script Schema (v1.0)","text":"<pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"relative/or/absolute/path/to/fw.elf\"\n  system: \"optional/path/to/system.yaml\"\nlimits:\n  max_steps: 100000\n  max_cycles: 123456     # optional\n  max_uart_bytes: 4096   # optional\n  no_progress_steps: 500 # optional (PC unchanged for N steps)\n  wall_time_ms: 5000   # optional\nassertions:\n  - uart_contains: \"Hello\"\n  - uart_regex: \"^Hello.*$\"\n  - expected_stop_reason: max_steps\n</code></pre> <p>Notes: - Unknown fields are rejected (script parse/validation returns exit code <code>2</code>). - Relative <code>inputs.firmware</code> / <code>inputs.system</code> paths are resolved relative to the directory containing the script file (not the current working directory). - CLI flags override script inputs:   - <code>--firmware</code> overrides <code>inputs.firmware</code>   - <code>--system</code> overrides <code>inputs.system</code> - CLI flags override script limits:   - <code>--max-steps</code> overrides <code>limits.max_steps</code>   - <code>--max-cycles</code> overrides <code>limits.max_cycles</code>   - <code>--max-uart-bytes</code> overrides <code>limits.max_uart_bytes</code>   - <code>--detect-stuck</code> (alias: <code>--no-progress</code>) overrides <code>limits.no_progress_steps</code> - <code>--breakpoint &lt;addr&gt;</code> (repeatable) stops the run when PC matches and sets <code>stop_reason: halt</code>.</p>"},{"location":"ci_test_runner/#deprecated-legacy-schema-v1","title":"Deprecated Legacy Schema (v1)","text":"<p>For backward compatibility, <code>schema_version: 1</code> is still accepted, but is deprecated and will be removed in a future release.</p> <p>Legacy shape:</p> <pre><code>schema_version: 1\nfirmware: \"optional/path/to/fw.elf\"   # optional (can be provided by --firmware)\nsystem: \"optional/path/to/system.yaml\"\nmax_steps: 100000\nwall_time_ms: 5000   # optional\nassertions: []\n</code></pre>"},{"location":"ci_test_runner/#stop-reasons","title":"Stop Reasons","text":"<p><code>expected_stop_reason</code> supports: - <code>max_steps</code> - <code>max_cycles</code> - <code>max_uart_bytes</code> - <code>no_progress</code> - <code>wall_time</code> - <code>memory_violation</code> - <code>decode_error</code> - <code>halt</code> - <code>config_error</code> (runner failed before simulation started; e.g. script parse/validation error)</p> <p>Semantics: - If the simulator hits <code>wall_time_ms</code>, the run is treated as an assertion failure (exit code <code>1</code>) unless an <code>expected_stop_reason</code> assertion matches <code>wall_time</code>. - If the simulator hits <code>max_uart_bytes</code> or <code>no_progress_steps</code>, the run is treated as an assertion failure (exit code <code>1</code>) unless an <code>expected_stop_reason</code> assertion matches (<code>max_uart_bytes</code> / <code>no_progress</code>). - If the simulator hits <code>max_steps</code> or <code>max_cycles</code>, the run is considered a normal stop (exit code <code>0</code>) as long as assertions pass. - If the simulator hits a runtime error stop reason (e.g. <code>memory_violation</code>), the run is treated as a runtime error (exit code <code>3</code>) unless an <code>expected_stop_reason</code> assertion matches the stop reason.</p> <p><code>result.json</code> uses: - <code>result_schema_version</code>: version of the <code>result.json</code> contract (currently <code>\"1.0\"</code>) - <code>stop_reason</code>: the terminal reason the simulator stopped - <code>stop_reason_details</code>: which stop condition triggered (+ the limit/observed value when applicable) - <code>limits</code>: the resolved limits used for the run (after applying any CLI overrides) - <code>status</code>: one of <code>pass</code>, <code>fail</code>, <code>error</code></p>"},{"location":"ci_test_runner/#artifacts","title":"Artifacts","text":"<p>Use <code>--output-dir</code> to write artifacts:</p> <pre><code>labwired test --script test.yaml --output-dir out/artifacts\n</code></pre> <p>Artifacts: - <code>out/artifacts/result.json</code>: machine-readable summary - <code>out/artifacts/snapshot.json</code>: machine-readable snapshot of CPU state (or config error details) - <code>out/artifacts/uart.log</code>: captured UART TX bytes - <code>out/artifacts/junit.xml</code>: JUnit XML report (one testcase for <code>run</code> + one per assertion)</p> <p>Alternatively, you can write JUnit XML to a specific path:</p> <pre><code>labwired test --script test.yaml --junit out/junit.xml\n</code></pre>"},{"location":"ci_test_runner/#path-resolution-rules","title":"Path Resolution Rules","text":"<ul> <li><code>--script</code>: if relative, resolved relative to the current working directory.</li> <li>Script-relative paths:</li> <li><code>inputs.firmware</code>, <code>inputs.system</code> (v1.0)</li> <li><code>firmware</code>, <code>system</code> (legacy v1)   are resolved relative to the directory containing the script file.</li> <li>System manifest-relative paths: <code>system.yaml</code> may reference <code>chip: ...</code>; this <code>chip</code> path is resolved relative to the directory containing the system manifest file.</li> <li><code>--output-dir</code> / <code>--junit</code>: if relative, resolved relative to the current working directory.</li> </ul>"},{"location":"ci_test_runner/#resultjson-contract-v10","title":"<code>result.json</code> Contract (v1.0)","text":"<p>The runner writes <code>result.json</code> only when <code>--output-dir</code> is provided (including config/script errors that exit with code <code>2</code>).</p>"},{"location":"ci_test_runner/#json-schema","title":"JSON Schema","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"LabWired CI runner result.json (v1.0)\",\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"result_schema_version\",\n    \"status\",\n    \"steps_executed\",\n    \"cycles\",\n    \"instructions\",\n    \"stop_reason\",\n    \"stop_reason_details\",\n    \"limits\",\n    \"assertions\",\n    \"firmware_hash\",\n    \"config\"\n  ],\n  \"properties\": {\n    \"result_schema_version\": {\n      \"type\": \"string\",\n      \"enum\": [\"1.0\"]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\"pass\", \"fail\", \"error\"]\n    },\n    \"steps_executed\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"cycles\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"instructions\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"stop_reason\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"config_error\",\n        \"max_steps\",\n        \"max_cycles\",\n        \"max_uart_bytes\",\n        \"no_progress\",\n        \"wall_time\",\n        \"memory_violation\",\n        \"decode_error\",\n        \"halt\"\n      ]\n    },\n    \"message\": { \"type\": [\"string\", \"null\"] },\n    \"stop_reason_details\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\"triggered_stop_condition\", \"triggered_limit\", \"observed\"],\n      \"properties\": {\n        \"triggered_stop_condition\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"config_error\",\n            \"max_steps\",\n            \"max_cycles\",\n            \"max_uart_bytes\",\n            \"no_progress\",\n            \"wall_time\",\n            \"memory_violation\",\n            \"decode_error\",\n            \"halt\"\n          ]\n        },\n        \"triggered_limit\": {\n          \"type\": [\"object\", \"null\"],\n          \"additionalProperties\": false,\n          \"required\": [\"name\", \"value\"],\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"value\": { \"type\": \"integer\", \"minimum\": 0 }\n          }\n        },\n        \"observed\": {\n          \"type\": [\"object\", \"null\"],\n          \"additionalProperties\": false,\n          \"required\": [\"name\", \"value\"],\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"value\": { \"type\": \"integer\", \"minimum\": 0 }\n          }\n        }\n      }\n    },\n    \"limits\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\n        \"max_steps\",\n        \"max_cycles\",\n        \"max_uart_bytes\",\n        \"no_progress_steps\",\n        \"wall_time_ms\"\n      ],\n      \"properties\": {\n        \"max_steps\": { \"type\": \"integer\", \"minimum\": 0 },\n        \"max_cycles\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"max_uart_bytes\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"no_progress_steps\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"wall_time_ms\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 }\n      }\n    },\n    \"message\": {\n      \"type\": \"string\",\n      \"description\": \"Present only for config errors / invalid inputs.\"\n    },\n    \"assertions\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"assertion\", \"passed\"],\n        \"properties\": {\n          \"passed\": { \"type\": \"boolean\" },\n          \"assertion\": {\n            \"oneOf\": [\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"uart_contains\"],\n                \"properties\": { \"uart_contains\": { \"type\": \"string\" } }\n              },\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"uart_regex\"],\n                \"properties\": { \"uart_regex\": { \"type\": \"string\" } }\n              },\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"expected_stop_reason\"],\n                \"properties\": {\n                  \"expected_stop_reason\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"max_steps\",\n                      \"max_cycles\",\n                      \"max_uart_bytes\",\n                      \"no_progress\",\n                      \"wall_time\",\n                      \"memory_violation\",\n                      \"decode_error\",\n                      \"halt\"\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    },\n    \"firmware_hash\": {\n      \"type\": \"string\",\n      \"description\": \"SHA-256 of the firmware ELF bytes (lowercase hex).\",\n      \"pattern\": \"^[0-9a-f]{64}$\"\n    },\n    \"config\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\"firmware\", \"system\", \"script\"],\n      \"properties\": {\n        \"firmware\": { \"type\": \"string\" },\n        \"system\": { \"type\": [\"string\", \"null\"] },\n        \"script\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"ci_test_runner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>- name: Run LabWired tests\n  run: |\n    cargo build --release -p labwired-cli\n    ./target/release/labwired test \\\n      --script examples/ci/dummy-max-steps.yaml \\\n      --output-dir out/artifacts \\\n      --no-uart-stdout\n- name: Upload artifacts (pass/fail)\n  if: always()\n  uses: actions/upload-artifact@v4\n  with:\n    name: labwired-artifacts\n    path: out/artifacts\n    if-no-files-found: warn\n</code></pre>"},{"location":"ci_test_runner/#copy-paste-workflow-composite-action","title":"Copy-Paste Workflow (Composite Action)","text":"<p>This repo includes a minimal composite action wrapper at <code>.github/actions/labwired-test</code> that: - builds <code>labwired</code> (<code>crates/cli</code>) - runs <code>labwired test</code> - emits artifact paths as outputs - writes a small summary into the GitHub Actions step summary</p> <p>Copy-paste this workflow into <code>.github/workflows/labwired-test.yml</code>:</p> <pre><code>name: LabWired CI Test\n\non:\n  pull_request:\n  push:\n    branches: [ \"main\", \"develop\" ]\n\njobs:\n  labwired-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run labwired test\n        id: labwired\n        uses: ./.github/actions/labwired-test\n        with:\n          script: examples/ci/dummy-max-steps.yaml\n          output_dir: out/artifacts\n          no_uart_stdout: true\n          profile: release\n\n      - name: Upload artifacts (pass/fail)\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: labwired-artifacts\n          path: ${{ steps.labwired.outputs.artifacts_dir }}\n          if-no-files-found: warn\n\n      - name: Fail job if test failed\n        if: ${{ steps.labwired.outputs.exit_code != '0' }}\n        run: |\n          echo \"labwired test failed with exit_code=${{ steps.labwired.outputs.exit_code }}\"\n          exit ${{ steps.labwired.outputs.exit_code }}\n</code></pre>"},{"location":"ci_test_runner/#local-vs-ci-parity","title":"Local vs CI Parity","text":"<p>CI runs the same <code>labwired test</code> command you can run locally; the only CI-specific behavior is how artifacts are uploaded and how the summary is displayed.</p> <p>Local (native):</p> <pre><code>cargo build --release -p labwired-cli\n./target/release/labwired test --script examples/ci/dummy-max-steps.yaml --output-dir out/artifacts --no-uart-stdout\n</code></pre> <p>Local (Docker, closest to \u201cclean CI machine\u201d):</p> <pre><code>docker build -t labwired-ci .\ndocker run --rm -v \"$PWD:/work\" -w /work labwired-ci \\\n  labwired test --script examples/ci/dummy-max-steps.yaml --output-dir out/artifacts --no-uart-stdout\n</code></pre>"},{"location":"cli_reference/","title":"CLI Reference","text":"<p>The <code>labwired</code> command-line interface is the primary entry point for running simulations, testing, and managing assets.</p>"},{"location":"cli_reference/#global-options","title":"Global Options","text":"<p>These options apply to the interactive runner and most subcommands.</p> Option Description <code>--trace</code> Enable instruction-level execution tracing (prints every executed instruction). <code>--json</code> Output errors and diagnostics as structured JSON for agent consumption. <code>--vcd &lt;PATH&gt;</code> Output a Value Change Dump (VCD) trace file to the specified path. <code>--version</code> Print version information. <code>--help</code> Print help message."},{"location":"cli_reference/#modes-commands","title":"Modes &amp; Commands","text":""},{"location":"cli_reference/#interactive-run-mode-default","title":"Interactive / Run Mode (Default)","text":"<p>Executes a firmware simulation interactively. If no subcommand is provided, this mode is used.</p> <pre><code>labwired [OPTIONS] --firmware &lt;ELF&gt; --system &lt;YAML&gt;\n</code></pre> <p>Options: - <code>--firmware &lt;PATH&gt;</code>: Path to the ELF binary to load (Required). - <code>--system &lt;PATH&gt;</code>: Path to the System Manifest YAML (Required). - <code>--max-steps &lt;N&gt;</code>: Stop simulation after N instructions (default: 20000). - <code>--gdb &lt;PORT&gt;</code>: Start a GDB RSP server on the specified port (e.g., 3333). - <code>--breakpoint &lt;ADDR&gt;</code>: Breakpoint PC address (decimal or 0xHex). Repeatable. - <code>--snapshot &lt;PATH&gt;</code>: Write a state snapshot (JSON) upon exit.</p>"},{"location":"cli_reference/#test","title":"<code>test</code>","text":"<p>Runs a CI-friendly test script with assertions.</p> <pre><code>labwired test --script &lt;YAML&gt; [OVERRIDES]\n</code></pre> <p>Options: - <code>-c, --script &lt;PATH&gt;</code>: Path to the test script (see Test Runner). - <code>-f, --firmware &lt;PATH&gt;</code>: Override the firmware path defined in the script. - <code>-s, --system &lt;PATH&gt;</code>: Override the system manifest defined in the script. - <code>--output-dir &lt;PATH&gt;</code>: Directory to write artifacts (<code>result.json</code>, <code>uart.log</code>). - <code>--junit &lt;PATH&gt;</code>: Path to write JUnit XML report. - <code>--max-steps &lt;N&gt;</code>: Override default step limit. - <code>--max-cycles &lt;N&gt;</code>: Override cycle limit. - <code>--max-uart-bytes &lt;N&gt;</code>: Override UART output limit. - <code>--no-progress &lt;N&gt;</code>: Fail if PC doesn't change for N steps (detects hangs). - <code>--no-uart-stdout</code>: Disable echoing UART output to the console. - <code>--max-vcd-bytes &lt;N&gt;</code>: Limit the size of the generated VCD file.</p>"},{"location":"cli_reference/#asset","title":"<code>asset</code>","text":"<p>Utilities for managing LabWired assets (SVD import, Code Generation, etc.).</p> <pre><code>labwired asset &lt;SUBCOMMAND&gt;\n</code></pre> <p>Subcommands: - <code>import-svd</code>: Import an SVD file and convert it to Strict IR (JSON).   - <code>-i, --input &lt;SVD&gt;</code>: Input SVD file.   - <code>-o, --output &lt;JSON&gt;</code>: Output JSON file. - <code>codegen</code>: Generate Rust code from Strict IR.   - <code>-i, --input &lt;JSON&gt;</code>: Input IR file.   - <code>-o, --output &lt;RS&gt;</code>: Output Rust source file. - <code>init</code>: Initialize a new project skeleton.   - <code>-o, --output &lt;DIR&gt;</code>: Output directory.   - <code>-c, --chip &lt;NAME&gt;</code>: Chip name to base the project on. - <code>add-peripheral</code>: Add a peripheral to an existing chip descriptor.   - <code>-c, --chip &lt;YAML&gt;</code>: Target chip descriptor.   - <code>--id &lt;NAME&gt;</code>: New peripheral ID.   - <code>--base &lt;ADDR&gt;</code>: Base address.   - <code>--ir-path &lt;PATH&gt;</code>: Path to IR descriptor. - <code>validate</code>: Validate a System Manifest and its referenced Chip. - <code>list-chips</code>: List available chip descriptors.</p>"},{"location":"cli_reference/#machine","title":"<code>machine</code>","text":"<p>Machine state control operations.</p> <p>Subcommands: - <code>load</code>: Load a machine state from a snapshot and resume simulation.   - <code>-s, --snapshot &lt;JSON&gt;</code>: Path to snapshot file.   - <code>--max-steps &lt;N&gt;</code>: Override step limit.   - <code>--trace</code>: Enable tracing.</p>"},{"location":"cli_reference/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>RUST_LOG</code>: Controls logging level (e.g., <code>info</code>, <code>debug</code>).</li> <li>Native logging uses <code>tracing</code>.</li> <li>Example: <code>RUST_LOG=labwired_core=debug</code></li> </ul>"},{"location":"configuration_reference/","title":"Configuration Reference","text":"<p>LabWired uses a YAML-based configuration system to define the simulated hardware environment. This separation allows the same firmware binary to be tested against different hardware configurations (e.g., changing memory sizes or remapping peripherals) without recompilation.</p>"},{"location":"configuration_reference/#1-file-hierarchy","title":"1. File Hierarchy","text":"<p>A complete simulation requires two descriptor files:</p> <ol> <li>Chip Descriptor (<code>chips/&lt;name&gt;.yaml</code>): Defines the internal architecture of the SoC (Flash/RAM size, internal peripheral addresses).</li> <li>System Manifest (<code>systems/&lt;name&gt;.yaml</code>): Instantiates a chip and defines board-level wiring (external sensors, UART loopbacks).</li> </ol>"},{"location":"configuration_reference/#2-chip-descriptor-schema","title":"2. Chip Descriptor Schema","text":"<p>Defines the invariant properties of the silicon.</p> <pre><code>name: \"STM32F103\"\nflash:\n  base: 0x08000000\n  size: \"64KB\"  # Supports KB/MB suffixes\nram:\n  base: 0x20000000\n  size: \"20KB\"\n\nperipherals:\n  # Internal Peripheral Definition\n  - id: \"usart1\"\n    type: \"uart\"\n    base_address: 0x40013800\n    irq: 37\n    config:\n      profile: \"stm32f1\"  # Loads architecture-specific register map\n\n  - id: \"gpioa\"\n    type: \"gpio\"\n    base_address: 0x40010800\n    config:\n      profile: \"stm32f1\"\n\n  # Declarative Peripheral (Custom)\n  - id: \"my_custom_timer\"\n    type: \"declarative\"\n    base_address: 0x40004000\n    config:\n      path: \"../peripherals/custom_timer.yaml\"\n</code></pre>"},{"location":"configuration_reference/#supported-peripheral-types","title":"Supported Peripheral Types","text":"<ul> <li><code>uart</code>, <code>usart</code>: Universal Asynchronous Receiver Transmitter</li> <li><code>gpio</code>: General Purpose I/O</li> <li><code>rcc</code>: Reset and Clock Control</li> <li><code>timer</code>: Basic Timer</li> <li><code>i2c</code>: Inter-Integrated Circuit</li> <li><code>spi</code>: Serial Peripheral Interface</li> <li><code>exti</code>: External Interrupt Controller</li> <li><code>afio</code>: Alternate Function I/O</li> <li><code>dma</code>: Direct Memory Access Controller</li> <li><code>systick</code>: System Tick Timer</li> <li><code>declarative</code>: Loads a generic peripheral from a YAML register description.</li> </ul>"},{"location":"configuration_reference/#3-system-manifest-schema","title":"3. System Manifest Schema","text":"<p>Defines the board-level environment.</p> <pre><code>name: \"BluePill Board\"\nchip: \"../chips/stm32f103.yaml\"  # Path relative to this file\n\n# External Device Connections (Planned)\nconnectors:\n  - type: \"uart\"\n    peripheral: \"usart1\"\n    endpoint: \"host_console\"  # Pipes UART output to simulator stdout\n</code></pre>"},{"location":"configuration_reference/#4-cli-usage","title":"4. CLI Usage","text":"<p>To run a simulation, provide both the firmware and the system manifest:</p> <pre><code>labwired --firmware firmware.elf --system configs/systems/bluepill.yaml\n</code></pre> <p>The simulator loads the system manifest, resolves the chip descriptor, initializes the memory map, and begins execution at the Reset Vector.</p>"},{"location":"debugging/","title":"Debugging (DAP)","text":"<p>LabWired implements a native Debug Adapter Protocol (DAP) server, enabling direct integration with IDEs like VS Code without intermediate GDB processes.</p>"},{"location":"debugging/#1-architecture","title":"1. Architecture","text":"<p>The DAP server operates as a sidecar process or an internal thread within the simulation runner.</p> <ul> <li>Protocol: JSON-RPC over Standard Input/Output (stdio) or TCP.</li> <li>Capabilities:<ul> <li><code>launch</code>: Starts a new simulation instance.</li> <li><code>attach</code>: Connects to a running simulation.</li> <li><code>setBreakpoints</code>: Supports source-level and instruction-level breakpoints.</li> <li><code>threads</code>: Exposes the CPU core as a single thread.</li> <li><code>stackTrace</code>: Unwinds the stack frame based on the current PC and SP.</li> <li><code>scopes</code> / <code>variables</code>: Inspects registers and local variables.</li> </ul> </li> </ul>"},{"location":"debugging/#2-vs-code-integration","title":"2. VS Code Integration","text":"<p>The <code>labwired-vscode</code> extension bundles the DAP client.</p>"},{"location":"debugging/#launch-configuration-launchjson","title":"Launch Configuration (<code>launch.json</code>)","text":"<p>To debug a firmware image, define a generic DAP launch configuration:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"labwired\",\n            \"request\": \"launch\",\n            \"name\": \"Debug Firmware\",\n            \"program\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"args\": [\"--system\", \"config/system.yaml\"],\n            \"stopOnEntry\": true,\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre>"},{"location":"debugging/#configuration-options","title":"Configuration Options","text":"<ul> <li>program: Path to the ELF binary with debug symbols (DWARF).</li> <li>args: Command-line arguments passed to the LabWired CLI.</li> <li>stopOnEntry: If <code>true</code>, the simulator halts at the Reset Vector.</li> <li>cwd: Current working directory for the simulation process.</li> </ul>"},{"location":"debugging/#3-telemetry-extensions","title":"3. Telemetry Extensions","text":"<p>The LabWired DAP implementation extends the protocol to support real-time telemetry.</p>"},{"location":"debugging/#custom-events","title":"Custom Events","text":"<p>The server emits a <code>telemetry</code> event every 100ms containing performance metrics.</p> <p>Payload Schema: <pre><code>{\n  \"type\": \"event\",\n  \"event\": \"telemetry\",\n  \"body\": {\n    \"cycles\": 120500,\n    \"mips\": 12.5,\n    \"pc\": \"0x080001a4\"\n  }\n}\n</code></pre></p> <p>This allows the VS Code extension to render a live \"Dashboard\" view without polling the debug interface, minimizing protocol overhead.</p>"},{"location":"debugging/#4-troubleshooting","title":"4. Troubleshooting","text":""},{"location":"debugging/#unknown-request-errors","title":"\"Unknown Request\" Errors","text":"<p>If the debug console shows protocol errors: 1.  Verify the <code>labwired-cli</code> version matches the extension version. 2.  Enable verbose logging in <code>launch.json</code>: <code>\"trace\": true</code>.</p>"},{"location":"debugging/#source-mapping-issues","title":"Source Mapping Issues","text":"<p>If breakpoints cannot be set: 1.  Ensure the ELF was compiled with <code>debug = true</code>. 2.  Verify the <code>program</code> path matches the binary being displayed in the editor.</p>"},{"location":"declarative_registers/","title":"Declarative Register Definitions","text":"<p>LabWired uses declarative YAML specifications to define the register interface of peripherals. This system decouples the hardware description from the implementation logic, ensuring consistent behavior across all simulated devices.</p>"},{"location":"declarative_registers/#1-specification-schema","title":"1. Specification Schema","text":"<p>The schema defines the register map, access permissions, and side-effects.</p> <pre><code>peripheral: \"SPI\"\nversion: \"1.0\"\nregisters:\n  - id: \"CR1\"\n    address_offset: 0x00\n    size: 16\n    access: \"R/W\"\n    reset_value: 0x0000\n    fields:\n      - name: \"SPE\"\n        bit_range: [6, 6]\n        description: \"SPI Enable\"\n        access: \"R/W\"\n\n  - id: \"DR\"\n    address_offset: 0x0C\n    size: 16\n    access: \"R/W\"\n    side_effects:\n      on_read: \"clear_rxne\"\n      on_write: \"start_tx\"\n</code></pre>"},{"location":"declarative_registers/#key-components","title":"Key Components","text":"<ul> <li>id: Unique identifier for the register.</li> <li>address_offset: Byte offset from the peripheral base address.</li> <li>access: Access permissions (<code>R</code>, <code>W</code>, <code>R/W</code>). Violations trigger a BusFault.</li> <li>side_effects: Hooks that invoke custom Rust logic when the register is accessed.</li> </ul>"},{"location":"declarative_registers/#2-implementation-architecture","title":"2. Implementation Architecture","text":"<p>The declarative system consists of three phases:</p> <ol> <li>Parsing: The <code>labwired-config</code> crate deserializes the YAML into a <code>PeripheralDescriptor</code> intermediate representation (IR).</li> <li>Runtime: The <code>GenericPeripheral</code> implementation in <code>labwired-core</code> uses this descriptor to serve <code>read()</code> and <code>write()</code> requests. It handles bounds checking, access permissions, and bit masking automatically.</li> <li>Hooks: The <code>GenericPeripheral</code> delegates to a <code>HookHandler</code> trait when a side-effect (e.g., <code>on_write: \"start_tx\"</code>) is triggered.</li> </ol>"},{"location":"declarative_registers/#3-workflow","title":"3. Workflow","text":"<p>See the Peripheral Development Guide for a step-by-step workflow to build your first declarative peripheral.</p>"},{"location":"gdb_integration/","title":"GDB Integration Guide","text":"<p>LabWired features a built-in GDB Remote Serial Protocol (RSP) server that allows you to connect professional debugging tools (GDB, Ozone, Cortex-Debug) directly to the simulation.</p>"},{"location":"gdb_integration/#connecting-to-gdb-server","title":"\ud83d\udd17 Connecting to GDB Server","text":"<p>By default, the GDB server starts automatically when you launch a simulation session via the DAP server (e.g., in VS Code).</p> <ul> <li>Default Address: <code>localhost:3333</code></li> <li>Protocol: GDB Remote Serial Protocol (RSP)</li> </ul>"},{"location":"gdb_integration/#using-command-line-gdb","title":"\ud83d\udc1a Using Command Line GDB","text":"<ol> <li>Start your simulation (e.g., via VS Code extension).</li> <li>In a terminal, run your cross-compiler GDB:     <pre><code>arm-none-eabi-gdb target/firmware\n</code></pre></li> <li>Connect to the LabWired target:     <pre><code>(gdb) target remote localhost:3333\n</code></pre></li> <li>You can now use standard GDB commands:<ul> <li><code>i r</code>: Info registers</li> <li><code>x/16wx 0x0</code>: Examine memory</li> <li><code>b main</code>: Set breakpoint</li> <li><code>c</code>: Continue</li> <li><code>s</code>: Step</li> </ul> </li> </ol>"},{"location":"gdb_integration/#visual-studio-code-cortex-debug","title":"\ud83d\udcbb Visual Studio Code (Cortex-Debug)","text":"<p>For a superior debugging experience with peripheral views and disassembly, we recommend using the Cortex-Debug extension.</p>"},{"location":"gdb_integration/#configuration-launchjson","title":"Configuration (<code>launch.json</code>)","text":"<p>Add the following to your <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"cortex-debug\",\n            \"request\": \"launch\",\n            \"name\": \"LabWired (Cortex-Debug)\",\n            \"servertype\": \"external\",\n            \"gdbTarget\": \"localhost:3333\",\n            \"executable\": \"${workspaceRoot}/examples/arm-c-hello/target/firmware\",\n            \"cwd\": \"${workspaceRoot}\",\n            \"runToEntryPoint\": \"main\",\n            \"armToolchainPath\": \"/usr/bin\"\n        }\n    ]\n}\n</code></pre>"},{"location":"gdb_integration/#automated-testing","title":"\ud83e\uddea Automated Testing","text":"<p>We provide a verification script to test the GDB interface stability:</p> <pre><code>python3 scripts/test_gdb_rsp.py\n</code></pre> <p>This script is also part of our CI Pipeline, ensuring that the GDB interface remains robust across all releases.</p>"},{"location":"gdb_integration/#supported-packets","title":"\ud83d\udee0\ufe0f Supported Packets","text":"<p>LabWired supports the core set of RSP packets required for professional debugging: - <code>g</code>/<code>G</code>: Read/Write all registers - <code>P</code>: Write single register - <code>m</code>/<code>M</code>: Read/Write memory (hex) - <code>Z0</code>/<code>z0</code>: Insert/Remove software breakpoints - <code>vCont</code>: Resumption and stepping - <code>qSupported</code>: Capability negotiation - <code>Ctrl-C</code>: Break/Interrupt simulation</p>"},{"location":"getting_started_firmware/","title":"Running Firmware Images","text":"<p>LabWired executes standard ELF binaries compiled for ARM Cortex-M targets. The simulation environment requires two components: a valid firmware image and a declarative system configuration.</p>"},{"location":"getting_started_firmware/#1-compatible-firmware","title":"1. Compatible Firmware","text":"<p>LabWired loads ELF files generated by standard toolchains (Rust <code>rustc</code>, GCC <code>arm-none-eabi-gcc</code>).</p>"},{"location":"getting_started_firmware/#requirements","title":"Requirements","text":"<ul> <li>Format: ELF (Executable and Linkable Format).</li> <li>Architecture: ARMv7-M (Cortex-M3) or compatible.</li> <li>Memory Layout: Sections must be linked to valid addresses defined in the Chip Descriptor.</li> <li>Entry Point: The Vector Table must be placed at the Flash base address (typically <code>0x0800_0000</code>).</li> </ul>"},{"location":"getting_started_firmware/#compilation-example-rust","title":"Compilation Example (Rust)","text":"<p>Ensure the target is installed and build in release mode for performance:</p> <pre><code>rustup target add thumbv7m-none-eabi\ncargo build --release --target thumbv7m-none-eabi\n</code></pre>"},{"location":"getting_started_firmware/#2-system-definition","title":"2. System Definition","text":"<p>The simulation hardware is defined via two YAML configuration files: 1.  Chip Descriptor: Defines the internal memory map and peripheral base addresses. 2.  System Manifest: Defines the board-level configuration and instantiates the chip.</p>"},{"location":"getting_started_firmware/#chip-descriptor-chipyaml","title":"Chip Descriptor (<code>chip.yaml</code>)","text":"<p>Defines the MCU's physical memory layout.</p> <pre><code>name: \"STM32F103\"\nflash:\n  base: 0x08000000\n  size: \"64KB\"\nram:\n  base: 0x20000000\n  size: \"20KB\"\nperipherals:\n  - id: \"rcc\"\n    type: \"rcc\"\n    base_address: 0x40021000\n</code></pre>"},{"location":"getting_started_firmware/#system-manifest-systemyaml","title":"System Manifest (<code>system.yaml</code>)","text":"<p>Instantiates the chip and configures external connections.</p> <pre><code>name: \"bluepill-board\"\nchip: \"../chips/stm32f103.yaml\"\n</code></pre>"},{"location":"getting_started_firmware/#3-simulation-execution","title":"3. Simulation Execution","text":"<p>Invoke the <code>labwired-cli</code> with the firmware path and system configuration:</p> <pre><code>labwired --firmware firmware.elf --system system.yaml\n</code></pre>"},{"location":"getting_started_firmware/#loading-process","title":"Loading Process","text":"<ol> <li>Segment Loading: The loader creates a virtual memory space based on the Chip Descriptor. <code>PT_LOAD</code> segments from the ELF are copied to their respective addresses (Flash/RAM).</li> <li>Vector Table Initialization: The initial Stack Pointer (SP) is loaded from <code>FlashBase + 0x00</code>. The Reset Vector (PC) is loaded from <code>FlashBase + 0x04</code>.</li> <li>Execution Loop: The CPU begins fetching and executing instructions from the Reset Vector.</li> </ol>"},{"location":"getting_started_firmware/#4-common-runtime-issues","title":"4. Common Runtime Issues","text":""},{"location":"getting_started_firmware/#invalid-memory-access-busfault","title":"Invalid Memory Access (BusFault)","text":"<p>Symptom: Simulation terminates with <code>MemoryAccessViolation</code>. Cause: The firmware attempted to read/write an address not mapped in <code>chip.yaml</code>. Resolution: Verify linker script memory regions match the Chip Descriptor.</p>"},{"location":"getting_started_firmware/#vector-table-mismatch","title":"Vector Table Mismatch","text":"<p>Symptom: HardFault immediately upon start. Cause: The Vector Table is not located at the Flash Base Address. Resolution: inspected the ELF headers (<code>objdump -h</code>) to confirm <code>.vector_table</code> placement.</p>"},{"location":"getting_started_firmware/#peripheral-stalls","title":"Peripheral Stalls","text":"<p>Symptom: Firmware hangs in a polling loop (e.g., waiting for <code>RCC_CR_HSIRDY</code>). Cause: The peripheral model does not fully implement the status flag logic required by the HAL. Resolution: Run with <code>--trace</code> to identify the spinning loop. Use a <code>StubPeripheral</code> to mock the expected status bit if a full model is unavailable.</p>"},{"location":"peripheral_development/","title":"Peripheral Development Guide","text":"<p>This document outlines the architectural patterns and best practices for implementing custom peripherals in LabWired.</p>"},{"location":"peripheral_development/#1-peripheral-interface-contract","title":"1. Peripheral Interface Contract","text":"<p>All peripherals must implement the <code>Peripheral</code> trait from <code>labwired-core</code>. This interface abstracts the hardware behavior into three primary operations.</p> <pre><code>pub trait Peripheral: std::fmt::Debug + Send {\n    /// Handler for CPU read operations.\n    /// Offset: Memory address relative to the peripheral base.\n    /// Returns: 8-bit value or SimResult::Err on BusFault.\n    fn read(&amp;self, offset: u64) -&gt; SimResult&lt;u8&gt;;\n\n    /// Handler for CPU write operations.\n    /// Offset: Memory address relative to the peripheral base.\n    /// Value: 8-bit data to write.\n    fn write(&amp;mut self, offset: u64, value: u8) -&gt; SimResult&lt;()&gt;;\n\n    /// State update function called once per simulation step.\n    /// Used for time-based logic (timers, UART baud rate) and interrupt generation.\n    fn tick(&amp;mut self) -&gt; PeripheralTickResult;\n}\n</code></pre>"},{"location":"peripheral_development/#2-register-access-patterns","title":"2. Register Access Patterns","text":""},{"location":"peripheral_development/#byte-level-granularity","title":"Byte-Level Granularity","text":"<p>The <code>SystemBus</code> performs all transactions at byte granularity. 32-bit CPU instructions (like <code>STR</code>) are decomposed into four consecutive 8-bit writes. Peripherals must handle this reconstruction if they model 32-bit registers.</p> <p>Implementation Pattern: <pre><code>fn read(&amp;self, offset: u64) -&gt; SimResult&lt;u8&gt; {\n    // 1. Align offset to 4-byte boundary to identify the register\n    let reg_val = match offset &amp; !3 {\n        0x00 =&gt; self.control_reg,\n        0x04 =&gt; self.status_reg,\n        _ =&gt; return Ok(0), // Define unmapped behavior (RAZ/WI)\n    };\n\n    // 2. Extract the specific byte requested\n    let shift = (offset % 4) * 8;\n    Ok((reg_val &gt;&gt; shift) as u8)\n}\n</code></pre></p>"},{"location":"peripheral_development/#side-effects","title":"Side Effects","text":"<p>Operations that clear flags or trigger hardware actions (e.g., \"Write 1 to Clear\") should be implemented in the <code>write</code> handler.</p> <pre><code>fn write(&amp;mut self, offset: u64, value: u8) -&gt; SimResult&lt;()&gt; {\n    if offset == 0x00 { // status_reg\n        // Clear flags if bit is set in value (W1C behavior)\n        self.status_reg &amp;= !(value as u32);\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"peripheral_development/#3-time-based-logic-tick","title":"3. Time-Based Logic (<code>tick</code>)","text":"<p>The <code>tick()</code> method provides the simulation time base. It is invoked synchronously at the end of every CPU instruction cycle.</p>"},{"location":"peripheral_development/#implementation-guidelines","title":"Implementation Guidelines","text":"<ul> <li>Deterministic Execution: Avoid <code>std::thread::sleep</code> or system time. Behavior must rely solely on the tick count to ensuring deterministic replayability.</li> <li>Performance: This method is on the hot path. Minimal logic should execute on every tick. Use state counters to decimate high-frequency logic.</li> </ul> <p>Example: 1MHz Timer at 100MHz CPU Clock <pre><code>fn tick(&amp;mut self) -&gt; PeripheralTickResult {\n    self.cycles += 1;\n    if self.cycles &gt;= 100 { // 100 CPU cycles per timer tick\n        self.cycles = 0;\n        self.counter += 1;\n        // Trigger IRQ logic...\n    }\n    PeripheralTickResult::default()\n}\n</code></pre></p>"},{"location":"peripheral_development/#4-svd-ingestion-tool","title":"4. SVD Ingestion Tool","text":"<p>For standard peripherals, manual implementation of the register map is redundant. LabWired provides an SVD parsing tool to generate the boilerplate <code>PeripheralDescriptor</code> YAML.</p> <p>Usage: <pre><code>cargo run -p svd-ingestor -- --input STM32F4.svd --filter UART1 --output-dir crates/config/peripherals\n</code></pre></p> <p>This generates a YAML file compatible with the <code>GenericPeripheral</code> implementation, requiring only the hook logic to be written in Rust.</p>"},{"location":"release_strategy/","title":"LabWired Release &amp; Merging Strategy","text":"<p>This document defines release policy and branch governance. Release execution authority is <code>core/RELEASE_PROCESS.md</code>.</p>"},{"location":"release_strategy/#1-branching-model-gitflow","title":"1. Branching Model: Gitflow","text":"<p>We follow the Gitflow branching strategy to manage releases and features efficiently. For more detailed rules and workflows, see the Git Flow Guide. - <code>main</code>: The production-ready state. Only merge from <code>release/*</code> or <code>hotfix/*</code>. Tags are created here. - <code>develop</code>: The integration branch for the next release. Features merge here. - <code>feature/*</code>: Individual work items. Created from <code>develop</code>, merged back to <code>develop</code>.     - Naming convention: <code>feature/short-description</code> or <code>feature/issue-id-description</code>. - <code>release/*</code>: Preparation for a new production release. Created from <code>develop</code>, merged to <code>main</code> AND <code>develop</code>. - <code>hotfix/*</code>: Critical bug fixes for production. Created from <code>main</code>, merged to <code>main</code> AND <code>develop</code>.</p>"},{"location":"release_strategy/#merging-rules","title":"Merging Rules","text":"<ul> <li>Pull Requests (PRs) are mandatory for all merges.</li> <li>Approvals: At least 1 review approval is required.</li> <li>CI Checks: All checks (Build, Test, Lint, Audit) must pass.</li> <li>History: Use \"Squash and Merge\" for feature branches to keep history clean. Use \"Merge Commit\" for releases to preserve the valid history.</li> </ul>"},{"location":"release_strategy/#2-quality-gates","title":"2. Quality Gates","text":"<p>Every PR and commit to <code>develop</code>/<code>main</code> must pass automated gates. Developers should run matching checks locally before opening a PR.</p>"},{"location":"release_strategy/#automated-checks-ci","title":"Automated Checks (CI)","text":"Check Command Failure Condition Formatting <code>cargo fmt -- --check</code> Any formatting violation. Linting <code>cargo clippy -- -D warnings</code> Any warnings or errors. Tests <code>cargo test</code> Any test failure. Security <code>cargo audit</code> Known vulnerabilities in dependencies. Build <code>cargo build</code> Compilation error."},{"location":"release_strategy/#test-coverage","title":"Test Coverage","text":"<ul> <li>Goal: &gt;80% Code Coverage.</li> <li>Tool: <code>cargo-tarpaulin</code>.</li> <li>Enforcement: CI will generate a coverage report. Significant drops in coverage should block the PR.</li> </ul>"},{"location":"release_strategy/#3-release-policy","title":"3. Release Policy","text":""},{"location":"release_strategy/#31-release-notes-format","title":"3.1. Release Notes Format","text":"<p>Release notes must use the shared template at:</p> <ul> <li><code>.github/RELEASE_TEMPLATE.md</code></li> </ul> <p>Do not publish a release with missing template sections (scope, validation evidence, CI links, known issues, breaking changes).</p>"},{"location":"release_strategy/#32-steps-to-release","title":"3.2. Steps to Release","text":"<p>Use <code>core/RELEASE_PROCESS.md</code> as the execution runbook for monorepo release gates.</p> <p>Minimum mandatory gates include:</p> <ol> <li>Full workspace validation (<code>cargo test --workspace</code>, <code>cargo build --workspace</code>).</li> <li>Unsupported instruction audit with fail-on-unsupported.</li> <li>Cross-component compatibility baseline checks, even for scoped releases.</li> <li>Runtime smoke tests for CI fixtures and impacted board examples.</li> <li>Green required CI workflows before tagging.</li> <li>GitHub release draft created from <code>.github/RELEASE_TEMPLATE.md</code>.</li> </ol>"},{"location":"release_strategy/#4-coding-standards-documentation","title":"4. Coding Standards documentation","text":"<ul> <li>Style: Follow standard Rust style (<code>rustfmt</code>).</li> <li>Docs: Public APIs must be documented (<code>/// doc comments</code>).</li> <li>Errors: Use <code>thiserror</code> for library errors and <code>anyhow</code> for application/CLI errors.</li> <li>Commits: Follow Conventional Commits (e.g., <code>feat: allow loading hex files</code>, <code>fix: resolve crash on empty input</code>).</li> </ul>"},{"location":"schema_compatibility/","title":"YAML Schema Compatibility Policy","text":""},{"location":"schema_compatibility/#version-10-current","title":"Version 1.0 (Current)","text":"<p>The following schemas are frozen as v1.0: - <code>chip.yaml</code> (ChipDescriptor) - <code>system.yaml</code> (SystemManifest) - <code>peripheral.yaml</code> (PeripheralDescriptor)</p>"},{"location":"schema_compatibility/#stability-guarantees","title":"Stability Guarantees","text":"<ol> <li>Backwards Compatibility: All v1.0 schemas will be supported indefinitely</li> <li>Additive Changes Only: New optional fields may be added to v1.0 schemas</li> <li>No Breaking Changes: Required fields and their semantics will not change</li> <li>Deprecation Policy: Deprecated fields will be supported for at least 2 major versions</li> </ol>"},{"location":"schema_compatibility/#schema-evolution","title":"Schema Evolution","text":"<p>When breaking changes are required: 1. Increment schema version (e.g., <code>schema_version: \"2.0\"</code>) 2. Support both versions for at least 6 months 3. Provide migration tooling (<code>labwired asset migrate</code>) 4. Document migration path in release notes</p>"},{"location":"schema_compatibility/#schema-version-field","title":"Schema Version Field","text":"<p>All YAML configuration files support an optional <code>schema_version</code> field:</p> <pre><code>schema_version: \"1.0\"\nname: \"my-chip\"\n# ... rest of config\n</code></pre> <p>If omitted, the schema version defaults to <code>\"1.0\"</code> for backwards compatibility.</p>"},{"location":"schema_compatibility/#version-history","title":"Version History","text":""},{"location":"schema_compatibility/#v10-2026-02-14","title":"v1.0 (2026-02-14)","text":"<ul> <li>Initial frozen schema version</li> <li>Includes: ChipDescriptor, SystemManifest, PeripheralDescriptor</li> <li>Default version for all existing configs without explicit <code>schema_version</code> field</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide addresses common issues encountered when using LabWired Core.</p>"},{"location":"troubleshooting/#simulation-issues","title":"Simulation Issues","text":""},{"location":"troubleshooting/#memory-violation-at-0x","title":"\"Memory Violation at 0x...\"","text":"<p>Symptom: The simulator halts with <code>StopReason::MemoryViolation(address)</code>. Cause: The firmware attempted to access an address that is not mapped to Flash, RAM, or any registered peripheral. Solution: 1. Check your <code>chips/&lt;chip&gt;.yaml</code> definition. Does the address fall within the declared Flash or RAM regions? 2. Check your <code>system.yaml</code>. Is there a peripheral missing that should be at that address? 3. Verify the firmware linker script (<code>memory.x</code>). It might be placing data in valid hardware regions that the simulator doesn't know about yet.</p>"},{"location":"troubleshooting/#instruction-decode-error","title":"\"Instruction Decode Error\"","text":"<p>Symptom: <code>StopReason::DecodeError(address)</code>. Cause: The CPU attempted to execute an instruction that is invalid or undefined for the current architecture (e.g., executing data as code). Solution: 1. Check the Vector Table. Is the Reset Vector pointing to the correct entry point (usually <code>_start</code> or <code>Reset_Handler</code> + 1 for Thumb mode)? 2. Verify <code>load_firmware</code> succeeded. Run with <code>--trace</code> to see the first few instructions. If it crashes immediately, the entry point might be wrong. 3. Cortex-M requires the PC LSB to be 1 (Thumb mode). If your vector table has an even address (e.g., <code>0x08000100</code>), the CPU will switch to ARM mode and fault.</p>"},{"location":"troubleshooting/#dap-server-unreachable","title":"\"DAP Server Unreachable\"","text":"<p>Symptom: VS Code displays \"Connection refused\" or \"Timeout\" when starting a debug session. Cause: The LabWired instance isn't running, or the port is blocked. Solution: 1. Ensure LabWired is started with <code>--gdb</code> or is in interactive mode. 2. Check the port (default <code>3333</code>). Is it in use by another OpenOCD/J-Link instance? 3. In <code>launch.json</code>, verify <code>miDebuggerServerAddress</code> matches <code>localhost:&lt;port&gt;</code>.</p>"},{"location":"troubleshooting/#uart-output-is-garbage","title":"\"UART Output is Garbage\"","text":"<p>Symptom: <code>uart.log</code> contains random characters. Cause: Baud rate mismatch between firmware and simulator config. Solution: 1. LabWired's UART model is currently \"byte-perfect\" (it doesn't simulate physical baud timing errors), but ensure your firmware is actually writing valid ASCII. 2. Check if <code>echo_stdout</code> is enabled or if you are looking at raw binary data.</p>"},{"location":"troubleshooting/#cicd-issues","title":"CI/CD Issues","text":""},{"location":"troubleshooting/#max-steps-reached","title":"\"Max Steps Reached\"","text":"<p>Symptom: CI fails with <code>StopReason::MaxSteps</code>. Cause: The proprietary <code>max_steps</code> limit in your test script is too low for the initialization code to complete. Solution: 1. Increase <code>max_steps</code> in your <code>.yaml</code> test script. 2. Optimize your firmware boot sequence (e.g., reduce PLL validation timeouts).</p>"},{"location":"troubleshooting/#no-progress-stuck","title":"\"No Progress / Stuck\"","text":"<p>Symptom: <code>StopReason::NoProgress</code>. Cause: The PC has stayed in the same range (or exactly the same address) for <code>no_progress_steps</code>. This usually means an infinite loop (e.g., <code>while(1) {}</code> or a HardFault handler). Solution: 1. Use <code>--trace</code> to identify the loop. 2. If it's a valid strict polling loop, insert a <code>asm!(\"nop\")</code> or similar to vary the PC, or increase <code>no_progress_steps</code>.</p>"},{"location":"vscode_debugging/","title":"VS Code Debugging Configurations","text":"<p>LabWired supports two primary debugging methods in VS Code: Native DAP (Recommended) and GDB via Cortex-Debug.</p>"},{"location":"vscode_debugging/#1-native-dap-recommended","title":"1. Native DAP (Recommended)","text":"<p>Uses the LabWired VS Code extension directly. Best for simplicity and live telemetry performance.</p> <p><code>.vscode/launch.json</code>: <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"labwired\",\n            \"request\": \"launch\",\n            \"name\": \"LabWired: Native DAP\",\n            \"program\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"args\": [\"--system\", \"config/system.yaml\"],\n            \"stopOnEntry\": true,\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre></p> <p>See Debugging Guide for architectural details.</p>"},{"location":"vscode_debugging/#2-gdb-cortex-debug","title":"2. GDB / Cortex-Debug","text":"<p>Uses the standard <code>cortex-debug</code> extension connected to LabWired's GDB server. Best if you need SVD peripheral views or other Cortex-Debug specific features.</p> <p><code>.vscode/launch.json</code>: <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"cortex-debug\",\n            \"request\": \"launch\",\n            \"name\": \"LabWired: GDB Remote\",\n            \"servertype\": \"external\",\n            \"gdbTarget\": \"localhost:3333\",\n            \"executable\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"runToEntryPoint\": \"main\",\n            \"svdFile\": \"${workspaceFolder}/STM32F103.svd\",\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre></p> <p>Note: You must start the LabWired GDB server manually before launching this configuration: <pre><code>labwired --gdb --port 3333 --firmware ...\n</code></pre></p>"},{"location":"archive/design/modular_components/","title":"Modular Components Design Document","text":"<p>This document describes the architectural vision for making LabWired components (Cores, Peripherals, and Interconnects) truly modular and swappable.</p>"},{"location":"archive/design/modular_components/#architectural-boundaries","title":"Architectural Boundaries","text":"<p>LabWired follows a \"Wiring\" model where components are connected via explicit signals rather than being tightly coupled in code.</p>"},{"location":"archive/design/modular_components/#1-core-cpu","title":"1. Core (CPU)","text":"<p>The Core is responsible for instruction execution. It interacts with the rest of the system through: - Bus Interface: A standard interface for memory transactions (Read/Write). - Interrupt Interface: A set of input lines (IRQs) that can trigger exception handling. - Clock/Reset Interface: Inputs to control execution state and timing.</p>"},{"location":"archive/design/modular_components/#2-bus-interconnect","title":"2. Bus / Interconnect","text":"<p>The Bus serves as the system's central nervous system, routing transactions between the Core and Peripherals. - Static Mapping: Memory-mapped regions (Flash, RAM, Peripherals). - Arbitration: Handling multiple masters (DMA, Cores) accessing shared resources.</p>"},{"location":"archive/design/modular_components/#3-peripheral-model","title":"3. Peripheral Model","text":"<p>Peripherals are standalone components that: - Map to one or more address ranges. - Expose Signals (GPIO pins, IRQ lines). - Can be \"ticked\" to simulate internal state transitions over time.</p>"},{"location":"archive/design/modular_components/#multi-architecture-vision","title":"Multi-Architecture Vision","text":"<p>To \"emulate them all,\" LabWired must support a variety of popular architectures beyond ARM Cortex-M.</p>"},{"location":"archive/design/modular_components/#supported-architectures-targets","title":"Supported Architectures (Targets)","text":"<ul> <li>ARM Cortex-M (e.g., STM32, RP2040): Current focus. Strong emphasis on NVIC and Thumb ISA.</li> <li>RISC-V (e.g., ESP32-C3, CH32V): Rapidly growing open-source ISA. Simplified interrupt models (CLINT/CLIC).</li> <li>Xtensa (e.g., ESP32, ESP32-S3): Popular for high-performance IoT. Features complex multi-level interrupt controllers and windowed registers.</li> <li>AVR (e.g., ATmega328P): Legacy but still widespread in industrial/hobbyist sectors. 8-bit architecture with direct vector table mapping.</li> </ul>"},{"location":"archive/design/modular_components/#multi-core-support","title":"Multi-Core Support","text":"<p>Many modern MCUs (ESP32, RP2040) are multi-core. Our architecture must transition from a single <code>cpu</code> ownership model to a flexible execution model.</p>"},{"location":"archive/design/modular_components/#1-multicoremachine","title":"1. MultiCoreMachine","text":"<p>The <code>Machine</code> struct will be evolved to support multiple cores sharing a common <code>SystemBus</code>. - Inter-Processor Communication (IPC): Support for hardware semaphores and mailboxes. - Shared Peripherals: Proper handling of concurrent access to atomic peripherals.</p>"},{"location":"archive/design/modular_components/#2-heterogeneous-cores","title":"2. Heterogeneous Cores","text":"<p>Some systems combine different architectures (e.g., a Cortex-M4 and a Cortex-M0+, or a RISC-V co-processor). Modular boundaries allow these cores to \"plug into\" the same bus regardless of their internal ISA.</p>"},{"location":"archive/design/modular_components/#revised-interrupt-model-for-portability","title":"Revised Interrupt Model for Portability","text":"<p>To support diverse architectures, the \"Interrupt Controller\" must move from being an ARM-specific NVIC to a generic component that translates <code>InterruptLine</code> signals into ISA-specific exceptions.</p> <ul> <li>AVR: Signals map directly to vector table offsets.</li> <li>Xtensa: Signals map to specific interrupt levels and priority groups.</li> <li>RISC-V: Signals map to Local or Global (PLIC) interrupt inputs.</li> </ul>"},{"location":"archive/design/modular_components/#migration-path-emulate-them-all","title":"Migration Path: \"Emulate Them All\"","text":"<ol> <li>Generic Cpu Trait refinement: Ensure <code>Cpu</code> does not expose ARM-specific registers or concepts in its core interface.</li> <li>Pluggable Interrupt Controllers: Move NVIC logic into a standalone peripheral that implements a generic <code>InterruptController</code> trait.</li> <li>Multi-core Scheduler: Introduce a simulation tick that propagates cycles across all active cores in a <code>Machine</code>.</li> </ol>"},{"location":"archive/design/multi_arch_refactor/","title":"Multi-Architecture Support Refactoring","text":""},{"location":"archive/design/multi_arch_refactor/#context","title":"Context","text":"<p>LabWired core is currently tightly coupled to ARM Cortex-M architecture, specifically regarding system peripherals like NVIC and SCB, and the Vector Table Offset Register (VTOR). To support other architectures (RISC-V, AVR, etc.), we need to decouple the generic <code>Machine</code> and <code>Cpu</code> trait from these specifics.</p>"},{"location":"archive/design/multi_arch_refactor/#goals","title":"Goals","text":"<ul> <li>Remove hardcoded dependencies on ARM Cortex-M architecture (NVIC, SCB, VTOR) from the generic <code>Cpu</code> trait.</li> <li>Make <code>Machine</code> struct a pure execution container, agnostic of specific system peripherals.</li> <li>Introduce specific system configuration helpers for Cortex-M.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#implementation-plan","title":"Implementation Plan","text":""},{"location":"archive/design/multi_arch_refactor/#1-refactor-cpu-trait","title":"1. Refactor <code>Cpu</code> Trait","text":"<p>File: <code>crates/core/src/cpu/mod.rs</code></p> <ul> <li>Remove <code>get_vtor</code>, <code>set_vtor</code>, <code>set_shared_vtor</code> from <code>Cpu</code> trait.</li> <li>Keep <code>set_exception_pending</code> as it is a generic concept.</li> <li><code>CortexM</code> implementation will retain <code>vtor</code> logic but it will not be exposed via the generic trait.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#2-decouple-machine-from-system-peripherals","title":"2. Decouple <code>Machine</code> from System Peripherals","text":"<p>File: <code>crates/core/src/lib.rs</code></p> <ul> <li>Remove <code>Machine::with_bus()</code> logic that automatically instantiates and attaches <code>Nvic</code> and <code>Scb</code> peripherals.</li> <li><code>Machine</code> should only accept an already configured <code>Bus</code> and <code>Cpu</code>.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#3-introduce-system-helper","title":"3. Introduce System Helper","text":"<p>File: <code>crates/core/src/lib.rs</code> (or a sidebar module)</p> <ul> <li>Create a helper function/struct <code>configure_cortex_m(bus: &amp;mut SystemBus) -&gt; (CortexM, Arc&lt;NvicState&gt;)</code> or similar.</li> <li>This helper will:<ul> <li>Create shared <code>AtomicU32</code> for VTOR.</li> <li>Create <code>CortexM</code> CPU instance with this VTOR.</li> <li>Create <code>Nvic</code> and <code>Scb</code> peripherals, sharing the VTOR and NVIC state.</li> <li>Attach peripherals to the bus.</li> </ul> </li> </ul>"},{"location":"archive/design/multi_arch_refactor/#4-update-consumers-cli-tests","title":"4. Update Consumers (CLI &amp; Tests)","text":"<p>File: <code>crates/cli/src/main.rs</code>, <code>crates/core/tests.rs</code></p> <ul> <li>Update <code>run_interactive</code> and <code>run_test</code> to explicitly call the Cortex-M configuration logic before creating the <code>Machine</code>.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#status-completed","title":"Status: Completed","text":"<p>The multi-architecture refactor has been successfully implemented: -   Core Interface: Generic <code>Cpu</code> trait is decoupled from ARM-specific registers. -   Machine Initialization: <code>Machine</code> is now architecture-agnostic, with system setup helpers for Cortex-M and RISC-V. -   Snapshots: <code>CpuSnapshot</code> refactored into an enum, supporting standardized state capture for both ARM and RISC-V. -   Test Runner: The <code>labwired test</code> command automatically detects the architecture from ELF files and runs the appropriate simulation loop. -   Regression Testing: CI pipeline validated with real ELF binaries for ARM (M0, M3) and RISC-V.</p>"},{"location":"archive/design/system_descriptors/","title":"Design: LabWired System Descriptors","text":""},{"location":"archive/design/system_descriptors/#objective","title":"Objective","text":"<p>Enable users to define complex hardware setups using declarative descriptor files. Instead of hardcoding memory maps and peripherals, the simulator will load a System Manifest that describes the chip (e.g., STM32F103) and its connected environment (e.g., an I2C sensor).</p>"},{"location":"archive/design/system_descriptors/#1-descriptor-hierarchy","title":"1. Descriptor Hierarchy","text":""},{"location":"archive/design/system_descriptors/#a-chip-descriptor-chipsstm32f103yaml","title":"A. Chip Descriptor (<code>chips/stm32f103.yaml</code>)","text":"<p>Defines the internal architecture of a specific SoC. - CPU: Type (Cortex-M3), Clock frequency. - Memory Map: Flash, RAM, and Reserved regions. - Internal Peripherals: UART, GPIO, SPI, I2C, Timers (with base addresses).</p>"},{"location":"archive/design/system_descriptors/#b-boardsystem-manifest-boardsmy_projectyaml","title":"B. Board/System Manifest (<code>boards/my_project.yaml</code>)","text":"<p>Defines the \"Wiring\" and external components. - Target Chip: Reference to a Chip Descriptor. - External Devices: Stubs or functional models (e.g., Temperature Sensor). - Connections: How external devices map to chip pins/peripherals (e.g., Sensor on I2C1).</p>"},{"location":"archive/design/system_descriptors/#2-proposed-yaml-schema-example","title":"2. Proposed YAML Schema (Example)","text":"<pre><code># system.yaml\nname: \"Industrial Sensor Node\"\nchip: \"stm32f103c8\" # Looked up in chip registry\n\nmemory_overrides:\n  flash_size: 128KB\n  ram_size: 20KB\n\nperipherals:\n  - id: \"uart1\"\n    type: \"uart\"\n    base_address: 0x40013800\n    config:\n      baud_rate: 115200\n\nexternal_devices:\n  - id: \"temp_sensor\"\n    type: \"functional_stub\"\n    model: \"tmp102\"\n    connection:\n      interface: \"i2c1\"\n      address: 0x48\n    initial_state:\n      temperature: 25.0\n</code></pre>"},{"location":"archive/design/system_descriptors/#3-implementation-workflow","title":"3. Implementation Workflow","text":"<ol> <li><code>labwired-config</code> Crate: New crate to handle parsing and validation of YAML/JSON descriptors.</li> <li>Dynamic <code>SystemBus</code>: Refactor <code>SystemBus</code> to hold a collection of <code>Peripheral</code> trait objects mapped by address range, rather than hardcoded fields.</li> <li>Peripheral Factory: A central registry that instantiates peripherals (UART, Timer, etc.) based on the <code>type</code> string in the descriptor.</li> <li>Device Stubbing: Support for \"functional models\" where users can provide simple scripts or parameters to simulate external sensor data.</li> </ol>"},{"location":"archive/design/system_descriptors/#4-integration-with-cli","title":"4. Integration with CLI","text":"<p>The user will run: <pre><code>labwired --firmware firmware.elf --system my_project.yaml\n</code></pre> The simulator will auto-configure everything based on the YAML.</p>"},{"location":"archive/design/system_descriptors/#5-next-steps-iteration-6","title":"5. Next Steps (Iteration 6)","text":"<ol> <li>Define the <code>SystemManifest</code> struct.</li> <li>Implement YAML parsing using <code>serde_yaml</code>.</li> <li>Refactor <code>SystemBus</code> to use a dynamic memory map.</li> </ol>"},{"location":"development/git_flow/","title":"LabWired Git Flow","text":"<p>This document details our Git Flow branching strategy and the rules governing branch management.</p>"},{"location":"development/git_flow/#1-branch-hierarchy","title":"1. Branch Hierarchy","text":""},{"location":"development/git_flow/#permanent-branches","title":"Permanent Branches","text":"<ul> <li><code>main</code>: Represents the latest stable, production-ready release.</li> <li><code>develop</code>: The integration branch for the next release. Contains the latest successfully merged features.</li> </ul>"},{"location":"development/git_flow/#supporting-branches","title":"Supporting Branches","text":"<ul> <li><code>feature/*</code>: For new features, enhancements, or experiments.<ul> <li>Base: <code>develop</code></li> <li>Target: <code>develop</code> via Pull Request.</li> </ul> </li> <li><code>release/*</code>: For preparing a new production release.<ul> <li>Base: <code>develop</code></li> <li>Target: <code>main</code> AND <code>develop</code> via Pull Request.</li> </ul> </li> <li><code>hotfix/*</code>: For critical bug fixes in production.<ul> <li>Base: <code>main</code></li> <li>Target: <code>main</code> AND <code>develop</code> via Pull Request.</li> </ul> </li> </ul>"},{"location":"development/git_flow/#2-working-workflow","title":"2. Working Workflow","text":"<ol> <li>Create a branch: Start from <code>develop</code> for features or <code>main</code> for hotfixes.</li> <li>Commit changes: Follow Conventional Commits.</li> <li>Open a Pull Request: Target the appropriate branch (<code>develop</code> or <code>main</code>).</li> <li>Wait for CI: All automated tests, lints, and audits MUST pass.</li> <li>Resolve Conversations: All comments must be addressed or resolved.</li> <li>Merge:<ul> <li><code>feature/*</code> -&gt; <code>develop</code>: Squash and Merge.</li> <li><code>release/*</code> -&gt; <code>main</code>: Merge Commit (to preserve versioning history).</li> <li><code>hotfix/*</code> -&gt; <code>main</code>: Merge Commit.</li> </ul> </li> </ol>"},{"location":"development/git_flow/#3-branch-protection-rules","title":"3. Branch Protection Rules","text":"<p>The <code>main</code> and <code>develop</code> branches are protected with the following rules:</p> <ul> <li>Require status checks to pass: The CI <code>build</code> job (including tests, lints, and audits) must succeed.</li> <li>Require conversation resolution: All discussions must be closed.</li> </ul>"},{"location":"development/git_flow/#4-feature-implementation-rule","title":"4. Feature Implementation Rule","text":"<p>New functionality can ONLY be merged after a Pull Request is approved and all CI tests are confirmed green.</p>"},{"location":"examples/dma_exti_example/","title":"Example: DMA and Interrupt Logic","text":"<p>LabWired models Direct Memory Access (DMA) and External Interrupts (EXTI) using a deterministic two-phase execution cycle. This ensures that concurrent hardware events (like memory transfers and IRQ assertion) occur in a predictable order relative to CPU instruction execution.</p>"},{"location":"examples/dma_exti_example/#1-dma-memory-to-memory-transfer","title":"1. DMA Memory-to-Memory Transfer","text":"<p>The DMA controller processes transfer requests at the end of the CPU instruction cycle.</p>"},{"location":"examples/dma_exti_example/#configuration","title":"Configuration","text":"<p>To initiate a memory-to-memory transfer, the firmware must configure the DMA channel with the <code>MEM2MEM</code> bit set.</p> <pre><code>// DMA1 Channel 1 Configuration\nfn configure_dma_transfer(src: u32, dest: u32, len: u16) {\n    let dma = unsafe { &amp;*DMA1::ptr() };\n\n    // 1. Source and Destination Addresses\n    dma.ch1.cpar.write(|w| unsafe { w.bits(src) });\n    dma.ch1.cmar.write(|w| unsafe { w.bits(dest) });\n\n    // 2. Transfer Length\n    dma.ch1.cndtr.write(|w| unsafe { w.bits(len as u32) });\n\n    // 3. Control Register (Enable, Mem2Mem, Increment Ptrs)\n    dma.ch1.ccr.write(|w| w\n        .mem2mem().set_bit() \n        .pl().very_high()\n        .minc().enabled()\n        .pinc().enabled()\n        .en().enabled()\n    );\n}\n</code></pre>"},{"location":"examples/dma_exti_example/#execution-model","title":"Execution Model","text":"<ol> <li>Request Phase: When <code>CCR.EN</code> is set, the DMA controller registers a pending request internally. It does not immediately modify memory.</li> <li>Bus Arbitration: At the end of the current CPU cycle, the <code>SystemBus</code> polls the DMA controller.</li> <li>Transfer Phase: The bus executes the memory copy operation (read from source, write to destination).</li> </ol>"},{"location":"examples/dma_exti_example/#2-external-interrupts-exti","title":"2. External Interrupts (EXTI)","text":"<p>External signals are routed through the EXTI controller to the Nested Vectored Interrupt Controller (NVIC).</p>"},{"location":"examples/dma_exti_example/#stimulus-configuration","title":"Stimulus Configuration","text":"<p>To verify interrupt logic, use a test script to assert a GPIO pin state.</p> <p>System Manifest (<code>system.yaml</code>): <pre><code>chip: \"../chips/stm32f103.yaml\"\ninputs:\n  - id: \"user_button\"\n    pin: \"PA0\"\n    mode: \"PushPull\"\n</code></pre></p> <p>Test Script (<code>test_interrupts.yaml</code>): <pre><code>steps:\n  - run: 100ms\n  - set_pin: \n      pin: \"PA0\"\n      state: \"high\"\n  - run: 1us\n  - assert_interrupt: \"EXTI0\"\n</code></pre></p>"},{"location":"examples/dma_exti_example/#signal-propagation","title":"Signal Propagation","text":"<ol> <li>GPIO: The pin state change is detected by the GPIO peripheral.</li> <li>AFIO: The signal is routed to the corresponding EXTI line (e.g., PA0 -&gt; EXTI0) based on the AFIO_EXTICR configuration.</li> <li>EXTI: The controller detects the rising/falling edge and sets the Pending Register (PR) bit.</li> <li>NVIC: The interrupt is forwarded to the NVIC. If the priority acts, the CPU vectors to the ISR on the next instruction fetch.</li> </ol>"},{"location":"examples/i2c_sensor_example/","title":"Example: I2C Sensor Simulation","text":"<p>This example demonstrates how to simulate an I2C peripheral (e.g., TMP102) and verify its behavior using standard Rust firmware.</p>"},{"location":"examples/i2c_sensor_example/#1-system-configuration","title":"1. System Configuration","text":"<p>The simulation environment requires defining the sensor in the system manifest and connecting it to the appropriate I2C controller.</p>"},{"location":"examples/i2c_sensor_example/#configuration-systemyaml","title":"Configuration (<code>system.yaml</code>)","text":"<pre><code>chip: \"../chips/stm32f103.yaml\"\nperipherals:\n  - id: \"i2c1\"\n    type: \"i2c_master\"\n    base_address: 0x40005400\n\n  - id: \"tmp102\"\n    type: \"i2c_temp_sensor\"  # Instantiates the TMP102 model\n    address: 0x48            # 7-bit I2C address\n    bus: \"i2c1\"              # Connects to the I2C1 controller\n</code></pre>"},{"location":"examples/i2c_sensor_example/#2-firmware-integration","title":"2. Firmware Integration","text":"<p>The firmware uses standard HAL calls to interact with the simulated device. No simulation-specific code is required in the firmware itself.</p>"},{"location":"examples/i2c_sensor_example/#rust-implementation-stm32f1xx-hal","title":"Rust Implementation (<code>stm32f1xx-hal</code>)","text":"<pre><code>use stm32f1xx_hal::{i2c::{BlockingI2c, Mode}, pac};\n\nfn main() -&gt; ! {\n    let dp = pac::Peripherals::take().unwrap();\n    // ... Clock Configuration ...\n\n    // Initialize I2C1 (Standard Mode, 100kHz)\n    let mut i2c = BlockingI2c::i2c1(\n        dp.I2C1,\n        (scl, sda), // Pins PB6, PB7\n        &amp;mut afio.mapr,\n        Mode::Standard { frequency: 100.kHz() },\n        clocks,\n        &amp;mut rcc.apb1,\n        1000, 10, 1000, 1000,\n    );\n\n    let sensor_addr = 0x48;\n    let mut buffer = [0u8; 2];\n\n    loop {\n        // Read Temperature Register (0x00)\n        i2c.write_read(sensor_addr, &amp;[0x00], &amp;mut buffer).unwrap();\n\n        // Convert to Celsius (12-bit, 0.0625\u00b0C resolution)\n        let raw_temp = u16::from_be_bytes(buffer) &gt;&gt; 4;\n        let celsius = raw_temp as f32 * 0.0625;\n    }\n}\n</code></pre>"},{"location":"examples/i2c_sensor_example/#3-automated-verification","title":"3. Automated Verification","text":"<p>LabWired supports scripted fault injection to verify error handling logic.</p>"},{"location":"examples/i2c_sensor_example/#fault-injection-script-testsfault_testyaml","title":"Fault Injection Script (<code>tests/fault_test.yaml</code>)","text":"<p>Simulates a sensor failure or extreme environmental condition.</p> <pre><code>steps:\n  - run: 100ms\n  - write_peripheral:\n      id: \"tmp102\"\n      reg: \"TEMP\"\n      value: 0x7FF0 # Force sensor reading to 128\u00b0C\n  - run: 10ms\n  - assert_log: \"CRITICAL: OVERTEMP DETECTED\"\n</code></pre>"},{"location":"examples/i2c_sensor_example/#4-execution","title":"4. Execution","text":"<p>Run the simulation with the test script:</p> <pre><code>labwired test --script tests/fault_test.yaml\n</code></pre> <p>The simulator will execute the firmware, inject the fault at the specified time, and verify that the firmware correctly detects and logs the error condition.</p>"},{"location":"examples/integrated_test_walkthrough/","title":"Walkthrough: Integrated STM32 Test Example","text":"<p>This example demonstrates how to use the <code>labwired test</code> runner to verify a real STM32 firmware on a custom system configuration.</p>"},{"location":"examples/integrated_test_walkthrough/#1-the-building-blocks","title":"1. The Building Blocks","text":""},{"location":"examples/integrated_test_walkthrough/#chip-descriptor-stm32f103yaml","title":"Chip Descriptor (stm32f103.yaml)","text":"<p>Defines the memory map and peripherals (DMA, EXTI, AFIO, UART).</p>"},{"location":"examples/integrated_test_walkthrough/#system-manifest-stm32f103-integrated-testyaml","title":"System Manifest (stm32f103-integrated-test.yaml)","text":"<p>Wires the chip into a specific system context. In this case, it just uses the raw chip.</p>"},{"location":"examples/integrated_test_walkthrough/#firmware-mainrs","title":"Firmware (main.rs)","text":"<p>A Rust <code>no_std</code> firmware that: - Performs 32-bit division. - Configures DMA1 Channel 1 for a memory-to-memory transfer. - Triggers a software interrupt via EXTI Line 0. - Enters an infinite loop.</p>"},{"location":"examples/integrated_test_walkthrough/#2-the-test-script","title":"2. The Test Script","text":"<p>The test script (stm32f103_integrated_test.yaml) automates the simulation:</p> <pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"../../target/thumbv7m-none-eabi/debug/firmware\"\n  system: \"../../configs/systems/stm32f103-integrated-test.yaml\"\nlimits:\n  max_steps: 10000\n  no_progress_steps: 1000\nassertions:\n  - expected_stop_reason: no_progress\n</code></pre>"},{"location":"examples/integrated_test_walkthrough/#3-running-the-test","title":"3. Running the Test","text":"<p>Run the test locally using the CLI:</p> <pre><code>labwired test --script examples/tests/stm32f103_integrated_test.yaml --output-dir out/test-results\n</code></pre>"},{"location":"examples/integrated_test_walkthrough/#inspecting-results","title":"Inspecting Results","text":"<p>The runner generates several artifacts in <code>out/test-results</code>: - <code>result.json</code>: Summary of execution stats and assertion results. - <code>snapshot.json</code>: Full state of the CPU and peripherals at the end of the run. - <code>uart.log</code>: Captured data from the UART peripheral.</p>"},{"location":"examples/integrated_test_walkthrough/#4-ci-integration","title":"4. CI Integration","text":"<p>You can easily integrate this into a GitHub Actions workflow:</p> <pre><code>- name: Run LabWired Integrated Test\n  run: |\n    labwired test \\\n      --script examples/tests/stm32f103_integrated_test.yaml \\\n      --output-dir artifacts\n</code></pre>"}]}