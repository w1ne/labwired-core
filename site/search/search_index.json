{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LabWired Core Documentation","text":"<p>Welcome to the LabWired Core documentation. LabWired is a deterministic firmware simulation platform designed to replace physical hardware in CI pipelines.</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>If you are new to LabWired, start here:</p> <ul> <li>Running Your Firmware: Learn how to load ELF binaries and execute them in the simulator.</li> <li>Board Onboarding: Steps to add support for a new microcontroller or board.</li> </ul>"},{"location":"#core-concepts","title":"\ud83e\udde0 Core Concepts","text":"<p>Understand how LabWired achieves deterministic simulation:</p> <ul> <li>Architecture Overview: Explains the split between the CPU Core, System Bus, and Peripherals.</li> <li>Configuration Reference: Detailed schema for defining chips and systems (YAML).</li> </ul>"},{"location":"#developer-guides","title":"\ud83d\udee0 Developer Guides","text":"<p>For contributors extending the core engine or adding new peripherals:</p> <ul> <li>Peripheral Development: How to implement custom peripheral models in Rust.</li> <li>Declarative Registers: Defining register maps using simple YAML files.</li> <li>CI Integration: How to run LabWired in GitHub Actions or GitLab CI.</li> <li>Coverage Scoreboard: Top-target smoke coverage and deterministic status tracking.</li> <li>Onboarding Smoke CI: <code>core-onboarding-smoke.yml</code> publishes time-to-first-smoke metrics and scoreboard artifacts.</li> <li>Target Support Rubric: Objective support levels and promotion criteria.</li> </ul>"},{"location":"#debugging","title":"\ud83d\udd0d Debugging","text":"<ul> <li>VS Code Debugging: Recipes for <code>launch.json</code>.</li> <li>Native DAP: Architecture of the built-in Debug Adapter.</li> <li>GDB Integration: Using standard GDB clients.</li> </ul>"},{"location":"#ai-agents","title":"\ud83e\udd16 AI Agents","text":"<ul> <li>Core Agents Manual: Essential onboarding for AI coding agents working in this repository.</li> </ul>"},{"location":"#examples","title":"\ud83d\udcda Examples","text":"<p>Practical walkthroughs of specific features:</p> <ul> <li>I2C Sensor Simulation: Verify driver code against a mock I2C device.</li> <li>DMA &amp; Interrupts: Understanding the two-phase execution model.</li> </ul>"},{"location":"ARCHITECTURE/","title":"LabWired Architecture Guide","text":"<p>LabWired is a modular, high-fidelity embedded systems simulator written in Rust. It isolates hardware description (Asset Foundry) from execution logic (Core Engine), linked by a Strict Intermediate Representation (IR).</p> <pre><code>graph TD\n    %% Subsystems\n    subgraph \"Asset Foundry (Ingestion)\"\n        SVD[Vendor SVD] --&gt;|import-svd| IR[Strict IR (JSON)]\n        IR --&gt;|Codegen| RustModel[Rust Core Model]\n    end\n\n    subgraph \"Execution Engine (Core)\"\n        ELF[Firmware ELF] --&gt; Loader\n        Loader --&gt; Machine\n        RustModel --&gt; Machine\n\n        Machine --&gt; CPU[CPU (ARM/RISC-V)]\n        Machine --&gt; Bus[System Bus]\n        Bus --&gt; Memory\n        Bus --&gt; Peripherals\n    end\n\n    subgraph \"Interfaces\"\n        CLI[labwired-cli] --&gt; Machine\n        GDB[GDB Stub] -.-&gt; Machine\n        DAP[VS Code DAP] -.-&gt; Machine\n    end</code></pre>"},{"location":"ARCHITECTURE/#1-asset-foundry-cratesir","title":"1. Asset Foundry (<code>crates/ir</code>)","text":"<p>The Asset Foundry is the supply chain for simulation models. It solves the problem of \"dirty\" vendor data.</p> <ul> <li>Input: Vendor SVD files (often broken, inconsistent).</li> <li>Process: Use <code>labwired asset import-svd</code> to flatten, unroll, and sanitize.</li> <li>Output: Strict IR (<code>labwired-ir</code>). A JSON format where:<ul> <li>All arrays (<code>UART0</code>, <code>UART1</code>) are unrolled.</li> <li>All inheritance (<code>derivedFrom</code>) is resolved.</li> <li>All clusters are flattened.</li> </ul> </li> <li>Goal: Zero-ambiguity input for the simulation core.</li> </ul>"},{"location":"ARCHITECTURE/#2-the-core-engine-cratescore","title":"2. The Core Engine (<code>crates/core</code>)","text":"<p>The simulation runtime. It is <code>no_std</code> compatible and designed for deterministic execution.</p>"},{"location":"ARCHITECTURE/#components","title":"Components","text":"<ul> <li>Machine: The top-level container holding CPU, Bus, and Peripherals.</li> <li>Cpu Trait: Abstract interface allowing <code>Cortex-M</code> or <code>RISC-V</code> implementations to be swapped.</li> <li>SystemBus: dynamically routes memory accesses (<code>read</code>/<code>write</code>) to:<ul> <li>Linear Memory: RAM/Flash (byte arrays).</li> <li>Peripherals: Structs implementing the <code>Peripheral</code> trait.</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#two-phase-execution-state-side-effects","title":"Two-Phase Execution (State &amp; Side-Effects)","text":"<p>To satisfy Rust's borrow checker and ensure determinism: 1.  Tick Phase: Peripherals update internal state and return Request Objects (e.g., <code>DmaRequest</code>, <code>InterruptRequest</code>). 2.  Resolution Phase: The Bus processes these requests, modifying memory or triggering CPU exceptions.</p>"},{"location":"ARCHITECTURE/#3-peripheral-modeling","title":"3. Peripheral Modeling","text":"<p>We prioritize Tier 1 Devices for deep support (see <code>docs/SUPPORTED_DEVICES.md</code>): *   STM32F4 (Cortex-M4) *   RP2040 (Dual Cortex-M0+) *   nRF52 (Cortex-M4F)</p> <p>Peripherals are implemented as Rust structs that mimic hardware logic (registers, bitfields, state machines).</p>"},{"location":"ARCHITECTURE/#4-interfaces-cratescli-cratesdap","title":"4. Interfaces (<code>crates/cli</code>, <code>crates/dap</code>)","text":"<ul> <li>CLI: The main entry point. Runs simulations, imports assets, and manages configuration.</li> <li>DAP Server: Implements the Debug Adapter Protocol for seamless VS Code integration.<ul> <li>Typically listens on TCP <code>5000</code>.</li> <li>Provides specialized telemetry events (PC, Cycles, Power) to the IDE.</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#directory-structure","title":"Directory Structure","text":"<ul> <li><code>core/crates/ir</code>: Strict IR definitions and SVD transformation logic.</li> <li><code>core/crates/core</code>: CPU, Bus, and Device traits.</li> <li><code>core/crates/cli</code>: Command-line driver.</li> <li><code>core/crates/loader</code>: ELF parsing.</li> <li><code>core/crates/config</code>: Configuration file parsing (system manifest).</li> </ul>"},{"location":"CONTRIBUTING_PERIPHERALS/","title":"Contributing Peripheral Models to LabWired","text":"<p>Thank you for your interest in expanding the LabWired ecosystem! A simulation platform is only as useful as the hardware it can model. This document outlines the standards, philosophy, and review process for contributing new peripheral implementations to the <code>labwired-core</code> crate.</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#1-the-labwired-philosophy-determinism-and-fidelity","title":"1. The LabWired Philosophy: Determinism and Fidelity","text":"<p>Unlike abstract or high-level emulators, LabWired is built to serve as a Cyber-Physical Digital Twin. Peripheral models must be written with the following core principles in mind:</p> <ul> <li>Determinism: A simulation must yield the identical state (registers, memory, output traces) given the same inputs and instruction count, regardless of the host machine's speed.</li> <li>Performance via Actor Model: Peripherals must not block the main execution loop. Heavy processing must be avoided, and state mutations should be highly optimized.</li> <li>Strict Memory Safety: We use Rust to eliminate memory corruption bugs in the simulator. Unsafe blocks (<code>unsafe {}</code>) are strictly forbidden in peripheral code unless interacting with an explicitly approved lower-level abstraction (e.g., zero-copy IPC bridges for RTL co-simulation).</li> <li>State Serializability: To support Distributed Time-Travel Debugging (via Chandy-Lamport snapshots) and Agentic \"save-scumming\" (fuzzing), all internal peripheral state must be perfectly serializable. Avoid raw pointers or non-deterministic data structures (like standard <code>HashMap</code> without a stable hasher).</li> <li>Dynamic Level-of-Detail (LOD): Code must be decoupled from the core execution engine to allow \"hot-swapping\" at runtime. A user might run your functional model for 10 seconds of boot time, then dynamically swap it for a cycle-accurate Verilator model for a specific driver interaction.</li> </ul>"},{"location":"CONTRIBUTING_PERIPHERALS/#2-what-makes-a-good-peripheral-model","title":"2. What Makes a \"Good\" Peripheral Model?","text":"<p>When reviewing pull requests for new peripherals, maintainers look for the following characteristics:</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#21-functional-vs-cycle-accurate","title":"2.1 Functional vs. Cycle-Accurate","text":"<p>For the majority of community models, we target Functional Accuracy, augmented by instruction-level timing boundaries. *   Do: Ensure that writing to an I2C transmit register sets the \"TX Empty\" flag after the expected number of bus ticks. *   Do: Implement necessary side-effects (e.g., Read-to-Clear (RC) flags, Write-1-to-Clear (W1C)). *   Don't: Attempt to model complex internal pipeline stalls or pipeline bubbles within a standard functional peripheral unless the specification explicitly defines them as observable state. For absolute cycle-precision, LabWired supports RTL Co-Simulation (Verilator integrations), which is governed by a separate process.</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#22-event-emission-physicality","title":"2.2 Event Emission &amp; Physicality","text":"<p>Models should hook into the global event bus to facilitate headless CI assertions, VCD tracing, and external FMI 3.0 interactions. *   Use standard traits to emit IRQs to the NVIC rather than hacking global states. *   Trigger generic <code>Event::GpioEdge</code> or <code>Event::UartTx</code> rather than printing directly to <code>stdout</code>. *   Power States: (Future-Proofing) If your peripheral has active/sleep modes that significantly affect power budgets, emit power state transition events to feed the Instruction-Level Energy Model (ILEM).</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#23-idempotent-reads-and-side-effects","title":"2.3 Idempotent Reads and Side-Effects","text":"<p>Hardware registers are notoriously tricky. Ensure you clearly separate: *   <code>read()</code>: A pure read for the debugger (should have no side effects). *   <code>read_side_effect()</code>: A read performed by the simulated CPU (which might clear status flags or advance FIFOs).</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#3-contribution-workflow","title":"3. Contribution Workflow","text":"<ol> <li>Draft an Issue: Before writing significant code, open a GitHub Issue proposing the peripheral. Define its scope (e.g., \"STM32F4 Basic Timers TIM6/TIM7 only, excluding advanced PWM features\").</li> <li>Define the Schema: Ensure the register layout is defined in a <code>peripheral.yaml</code> or imported cleanly from an SVD (System View Description) representation. LabWired heavily utilizes declarative macros to generate register boilerplate.<ul> <li>AI Assist: If using the FlexEmu LLM pipeline, ensure your prompt maps the vendor C headers to LabWired's 9 Generic Primitives (e.g., <code>Reg</code>, <code>RegField</code>, <code>Evt</code> for interrupts, <code>Upd</code> for hardware updates, <code>MemField</code> for DMA).</li> </ul> </li> <li>Implement: Write the Rust model implementing the <code>Peripheral</code> trait in <code>crates/core/src/peripherals/</code>.</li> <li>Write Tests: This is the most critical step. (See section 4).</li> </ol>"},{"location":"CONTRIBUTING_PERIPHERALS/#4-testing-and-acceptance-criteria","title":"4. Testing and Acceptance Criteria","text":"<p>A peripheral will not be merged without accompanying regression tests demonstrating its fidelity against standard usage patterns.</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#41-hardware-fidelity-tests","title":"4.1 Hardware Fidelity Tests","text":"<p>You must integrate your model into the <code>crates/core/tests/hardware_fidelity.rs</code> suite. Your test must demonstrate: *   Register Read/Write capability (including read-only and reserved bit masking). *   Side-effect triggering (e.g., writing data starts an operation and raises an IRQ flag). *   Deterministic timing (asserting that an operation completes after exactly <code>X</code> simulated CPU steps/cycles).</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#42-performance-baselines","title":"4.2 Performance Baselines","text":"<p>Reviewers will profile the peripheral. Implementations that cause significant regressions in the benchmark (Instructions Per Second) due to excessive allocations or nested locking will require optimization before merging.</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#43-ai-generated-models-flexemuagents","title":"4.3 AI-Generated Models (FlexEmu/Agents)","text":"<p>LabWired explicitly encourages the use of LLMs and Agentic workflows (like the MAESTRO framework) to bootstrap peripheral implementations from vendor C headers.  *   The Baseline Rule: AI-generated code is subject to the exact same rigorous standards as human-written code. Reviewers will not accept models that \"look right\" but fail the <code>hardware_fidelity.rs</code> timing or side-effect assertions. *   Closed-Loop Verification: If generating a model autonomously, ensure your agent includes a compilation and driver execution step to verify the generated primitive mappings before submitting a PR.</p>"},{"location":"CONTRIBUTING_PERIPHERALS/#5-versioning-and-compatibility","title":"5. Versioning and Compatibility","text":"<p>LabWired adheres to Semantic Versioning as defined in the Simulation Protocol Specification.</p> <ul> <li>Binding to Protocol: Your peripheral's behavior contributes to the overall determinism of the Simulation Protocol.</li> <li>Bug Fixes vs. Breaking Changes:<ul> <li>Fixing a bug that violates the vendor datasheet is considered a patch. While it changes simulation behavior, the previous behavior was incorrect by definition.</li> <li>Adding support for a completely new, major mode of the peripheral (e.g., adding DMA support to an existing SPI controller) should be flagged in the PR so test assertions can be updated globally.</li> </ul> </li> <li>Deprecation: If a peripheral implementation is structurally rewritten (e.g., moving from a naive polling model to an optimized event-driven model), the old model may be preserved using a <code>legacy</code> feature flag for one minor release cycle to allow users to migrate their CI test baselines.</li> </ul>"},{"location":"RELEASE_DETERMINISM/","title":"Release-Gated Determinism Report","text":""},{"location":"RELEASE_DETERMINISM/#1-introduction-the-determinism-mandate","title":"1. Introduction: The Determinism Mandate","text":"<p>In the era of Agentic AI, fuzzing, and complex Cyber-Physical Systems (CPS), simulation is only valuable if it is strictly reproducible. If a Reinforcement Learning agent discovers a zero-day vulnerability at epoch 40,000, that execution path must be 100% reproducible on a developer's local machine to be actionable.</p> <p>LabWired guarantees Strict Determinism. A simulation run with the same Configuration, System Manifest, and Firmware Binary will produce the exact same observable state (registers, memory, output traces, and step count) across any supported host platform (Linux, macOS, Windows) and independent of host load.</p> <p>This document outlines the architectural guarantees and the mandatory \"Golden Board\" release gating process that ensures this contract is never broken.</p>"},{"location":"RELEASE_DETERMINISM/#2-core-architectural-guarantees","title":"2. Core Architectural Guarantees","text":"<p>LabWired achieves determinism by decoupling simulation progress from the host machine's wall-clock time.</p>"},{"location":"RELEASE_DETERMINISM/#21-instruction-level-time-advancement","title":"2.1 Instruction-Level Time Advancement","text":"<p>The fundamental unit of time in LabWired is the Retired Instruction (or simulated core clock cycle). *   Peripherals do not use <code>std::time::Instant</code> or any host OS timers. *   The <code>SystemBus</code> ticks peripherals strictly advancing based on the CPU's instruction execution budget. *   If a host machine suffers a 500ms latency spike due to an OS context switch, the simulated CPU simply halts until the host recovers. The simulation time does not \"drift.\"</p>"},{"location":"RELEASE_DETERMINISM/#22-the-lock-free-actor-model-and-gvt","title":"2.2 The Lock-Free Actor Model and GVT","text":"<p>LabWired utilizes a message-passing Actor Model for multi-core and multi-peripheral simulation. To prevent race conditions between simulated actors running on different host threads, we enforce a Global Virtual Time (GVT) algorithm. *   Actors compute local state speculatively. *   State mutations (e.g., asserting an IRQ, writing to shared memory) are only committed when the GVT catches up to the actor's local time. *   This ensures that concurrent events are resolved in the exact same order on an M2 Mac as they are on an x86 Linux CI runner.</p>"},{"location":"RELEASE_DETERMINISM/#23-floating-point-determinism","title":"2.3 Floating-Point Determinism","text":"<p>To avoid cross-platform floating-point discrepancies (e.g., fused multiply-add variations or 80-bit x87 precision leaks on older x86), LabWired strictly uses <code>softfloat</code> implementations for FPU instructions (like the Cortex-M4F <code>vadd.f32</code>), guaranteeing bit-exact IEEE-754 compliance across all targets.</p>"},{"location":"RELEASE_DETERMINISM/#3-the-golden-board-methodology","title":"3. The \"Golden Board\" Methodology","text":"<p>To systematically prevent regressions, the LabWired core team maintains a suite of Golden Boards. A Golden Board is a paired artifact consisting of: 1.  A pre-compiled, frozen firmware binary (e.g., <code>stm32f4_freertos_blinky.elf</code>). 2.  A frozen LabWired configuration (<code>test_script.yaml</code>, <code>system.yaml</code>). 3.  A known-good signature of the final execution state.</p>"},{"location":"RELEASE_DETERMINISM/#31-trace-hashing-the-state-signature","title":"3.1 Trace Hashing (The State Signature)","text":"<p>The ultimate test of determinism is the Value Change Dump (VCD) trace. Because the VCD captures the state of every observable pin and register at every simulated cycle, it represents the complete sum of the simulation.</p> <p>During the release process, the CI pipeline runs the Golden Boards and generates a <code>trace.vcd</code> and <code>result.json</code>. These files are then hashed (SHA-256).</p> <p>If a pull request introduces an optimization that subtly changes the timing of a single instruction by one cycle, the resulting VCD hash will differ from the Golden Hash, and the CI build will fail immediately.</p>"},{"location":"RELEASE_DETERMINISM/#4-the-release-gate-checklist","title":"4. The Release Gate Checklist","text":"<p>Before any tag (e.g., <code>v1.2.0</code>) is cut and published to crates.io or GitHub Releases, the following mandatory steps are executed automatically via GitHub Actions:</p> <ul> <li>[ ] Cross-Platform Verification: The Golden Board suite is executed on <code>ubuntu-latest</code>, <code>macos-latest</code>, and <code>windows-latest</code>.</li> <li>[ ] Hash Verification: The SHA-256 hashes of the resulting <code>trace.vcd</code> and <code>result.json</code> artifacts for every Golden Board must match the version-controlled <code>expected_hashes.json</code> exactly across all three platforms.</li> <li>[ ] Instruction Parity Check: The <code>steps_executed</code> and <code>cycles</code> fields in <code>result.json</code> must exactly match the expected values.</li> <li>[ ] RTL Co-simulation Sync: (If applicable) Any Verilator-backed peripherals must complete their integration tests proving zero-copy IPC did not drop or reorder bus transactions.</li> </ul>"},{"location":"RELEASE_DETERMINISM/#41-handling-legitimate-state-changes","title":"4.1 Handling Legitimate State Changes","text":"<p>If a PR genuinely fixes a timing bug in a peripheral (meaning the previous \"Golden\" hash was technically incorrect behavior), the PR author must: 1.  Document the exact hardware justification for the timing change (referencing the vendor datasheet). 2.  Update <code>expected_hashes.json</code> in the same commit. 3.  The PR must be tagged as a <code>Behavioral Change</code> and cannot be merged as a generic patch without explicit maintainer approval.</p>"},{"location":"advanced_peripherals/","title":"Advanced STM32 Peripherals Design","text":"<p>This document describes the architectural approach for supporting complex STM32 systems in LabWired, focusing on DMA, EXTI, and AFIO.</p>"},{"location":"advanced_peripherals/#direct-memory-access-dma","title":"Direct Memory Access (DMA)","text":"<p>LabWired implements DMA using a two-phase request/execute model to maintain architectural modularity and comply with Rust's ownership rules.</p>"},{"location":"advanced_peripherals/#design-principles","title":"Design Principles","text":"<ol> <li>Decoupling: The DMA controller is a standard <code>Peripheral</code>. It doesn't have direct access to the <code>SystemBus</code> to avoid circular dependencies.</li> <li>Request-Based Mastering: During its <code>tick()</code>, a peripheral (like DMA) returns a list of <code>DmaRequest</code> objects.</li> <li>Bus Execution: The <code>SystemBus</code> executes these requests after the peripheral tick phase, effectively acting as the \"arbiter\".</li> </ol>"},{"location":"advanced_peripherals/#execution-flow","title":"Execution Flow","text":"<ol> <li>Phase 1: Tick: <code>SystemBus</code> calls <code>tick()</code> on all peripherals.</li> <li>Phase 2: Collect: <code>SystemBus</code> aggregates all <code>DmaRequest</code>s returned by peripherals.</li> <li>Phase 3: Execute: <code>SystemBus</code> performs the memory operations (Read/Write) requested by the DMA.</li> </ol> <pre><code>sequenceDiagram\n    participant B as SystemBus\n    participant D as DMA Peripheral\n    participant R as RAM / Peripheral\n\n    B-&gt;&gt;D: tick()\n    D--&gt;&gt;B: Vec&lt;DmaRequest&gt;\n    loop Each Request\n        B-&gt;&gt;R: read_u8/write_u8\n    end</code></pre>"},{"location":"advanced_peripherals/#external-interrupts-exti-afio","title":"External Interrupts (EXTI) &amp; AFIO","text":"<p>EXTI and AFIO work together to map GPIO signals to processor interrupts.</p>"},{"location":"advanced_peripherals/#exti-mapping","title":"EXTI Mapping","text":"<p>EXTI handles 16 lines corresponding to GPIO pins 0-15. -   Line 0: GPIOA pin 0, GPIOB pin 0, etc. (selected via AFIO) -   Lines 16-19: Specific events (PVD, RTC, USB, etc.)</p>"},{"location":"advanced_peripherals/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Signal Propagation: Peripherals can now emit signals or trigger other peripherals via a <code>SignalBus</code> (future enhancement) or direct wiring in <code>SystemBus</code>.</li> <li>Configurable Mapping: AFIO registers define which GPIO port maps to which EXTI line.</li> </ol>"},{"location":"advanced_peripherals/#current-support-status","title":"Current Support Status","text":"Feature Status Notes DMA Mastering [x] Implemented Two-phase execution in <code>SystemBus</code>. EXTI Controller [ ] Planned Standard STM32F103 mapping. AFIO Remapping [ ] Planned Basic pin mapping support."},{"location":"agents/","title":"Core Agents Manual","text":"<p>This is the operating manual for AI coding agents working inside the <code>core</code> repository of LabWired.</p>"},{"location":"agents/#1-context","title":"1) Context","text":"<ul> <li>The <code>core</code> directory contains the main simulation engine, CLI, DAP (Debug Adapter Protocol), configuration files, and testing infrastructure.</li> <li>All code in this repo is written in Rust and is designed to create a deterministic, fast, and testable simulation environment for various MCU protocols and peripherals.</li> </ul>"},{"location":"agents/#2-key-documentation-links","title":"2) Key Documentation Links","text":"<p>Start your learning and reference with these key files: - README.md - The main entrypoint. - ARCHITECTURE.md - Core engine internals and architecture. - CONTRIBUTING.md - General connection and contributing guidelines. - CONTRIBUTING_PERIPHERALS.md - How to implement and integrate new peripheral models. - board_onboarding_playbook.md - Complete playbook for onboarding new boards and MSUs. - ci_test_runner.md - Details on how CI validation works and is triggered.</p>"},{"location":"agents/#3-standard-development-commands","title":"3) Standard Development Commands","text":"<p>Run all of these commands from the <code>core</code> root directory (i.e. <code>/home/andrii/Projects/labwired/core</code>).</p> <p>Building and Testing: <pre><code># Build the workspace excluding firmware cross-compilation crates\nEXCLUDES=\"--exclude firmware-armv6m-hello --exclude firmware-stm32f103-blinky --exclude firmware-stm32f103-uart --exclude firmware-armv6m-ci-fixture --exclude firmware-armv7m-benchmark --exclude firmware-f401-demo --exclude firmware-h563-demo --exclude firmware-h563-fullchip-demo --exclude firmware-h563-io-demo --exclude firmware-hil-showcase --exclude firmware-nrf52832-demo --exclude firmware-rp2040-pio-onboarding --exclude firmware-rv32i-ci-fixture --exclude firmware-rv32i-hello\"\ncargo build --workspace $EXCLUDES\ncargo test --workspace $EXCLUDES\n</code></pre></p> <p>Linting and Formatting: <pre><code># Verify the formatting\ncargo fmt --all -- --check\n# Run the linter\ncargo clippy --workspace $EXCLUDES -- -D warnings\n</code></pre></p> <p>Running the Simulator: <pre><code>cargo run -p labwired-cli -- --firmware path/to/firmware.elf --system path/to/system.yaml\n</code></pre></p> <p>Testing Simulator Accuracy (Unsupported Instruction Audit): <pre><code>./scripts/unsupported_instruction_audit.sh \\\n  --firmware target/thumbv7m-none-eabi/release/&lt;firmware-crate&gt; \\\n  --system configs/systems/&lt;board&gt;.yaml \\\n  --max-steps 200000 \\\n  --out-dir out/unsupported-audit/&lt;board&gt;\n</code></pre></p> <p>Analyzing Simulation Failures (Digital Twin Diagnostics): When a simulation fails (e.g., hits <code>max_steps</code> or a memory violation), the CLI produces a <code>result.json</code> in the output directory. This file is your primary diagnostic tool.</p> <ul> <li><code>cpu_state</code>: Contains the final PC and all core registers (<code>r0-r15</code>, <code>x0-x31</code>, etc.).</li> <li><code>stop_reason</code>: Explains why the simulation ended (e.g., <code>MaxSteps</code>, <code>Breakpoint</code>, <code>Halt</code>).</li> <li><code>uart.log</code>: Standard output from the guest firmware.</li> </ul> <p>Agents should use the <code>cpu_state</code> to cross-reference with the IR model or datasheet to identify stalled status-bit polling or incorrect memory mapping.</p>"},{"location":"agents/#4-standalone-ai-tools","title":"4) Standalone AI Tools","text":"<p>For advanced refinement, you can use the standalone AI utilities in the <code>ai/</code> directory:</p> <ul> <li><code>fixer.py</code>: Analyzes a <code>result.json</code> and suggests IR timing fixes for busy-wait loops.   <pre><code>export PYTHONPATH=$PYTHONPATH:$(pwd)/../ai\npython3 -m labwired_ai.fixer --model path/to/model.json --result path/to/result.json\n</code></pre></li> </ul>"},{"location":"agents/#6-board-onboarding-sop","title":"6) Board Onboarding SOP","text":"<p>Apply this checklist whenever the task is adding/simulating a new MCU/board target. </p>"},{"location":"agents/#procedure-phase-gates","title":"Procedure (Phase Gates)","text":"<ol> <li><code>P0 - Source grounding</code>: Read <code>core/docs/board_onboarding_playbook.md</code> and collect authoritative vendor docs.</li> <li><code>P1 - Engine fit</code>: Map requirements to supported peripherals (<code>rcc + gpio + uart + systick</code> by default).</li> <li><code>P2 - Implementation</code>: Add chip descriptor, system manifest, and smoke firmware.</li> <li><code>P3 - Example docs package</code>: Add <code>core/examples/&lt;board&gt;/</code> with README, VALIDATION, etc.</li> <li><code>P4 - Validation</code>: Run test/build/run commands and confirm deterministic UART output.</li> <li><code>P5 - Report</code>: Provide files changed, commands run, runtime evidence, and source links.</li> </ol>"},{"location":"agents/#required-deliverables","title":"Required Deliverables","text":"<ol> <li><code>core/configs/chips/&lt;chip&gt;.yaml</code></li> <li><code>core/configs/systems/&lt;board&gt;.yaml</code></li> <li>smoke firmware crate (new or adapted)</li> <li><code>core/examples/&lt;board&gt;/system.yaml</code></li> <li><code>core/examples/&lt;board&gt;/README.md</code></li> <li><code>core/examples/&lt;board&gt;/REQUIRED_DOCS.md</code></li> <li><code>core/examples/&lt;board&gt;/EXTERNAL_COMPONENTS.md</code></li> <li><code>core/examples/&lt;board&gt;/VALIDATION.md</code></li> </ol>"},{"location":"agents/#completion-criteria","title":"Completion Criteria","text":"<ol> <li><code>labwired-cli</code> runs firmware with the new system manifest.</li> <li>Reset initializes PC/SP correctly.</li> <li>Expected UART smoke output is observable (for example, <code>OK\\n</code>).</li> <li>New/updated tests pass for touched behavior.</li> <li>Unsupported-instruction audit report is generated and reviewed.</li> </ol>"},{"location":"agents/#5-best-practices-for-agent-work-in-core","title":"5) Best Practices for Agent Work in Core","text":"<ol> <li>Verify State Proactively: Before assuming a code fix works, compile it using the standard development commands and review <code>cargo test</code> results. Do not infer correctness without validation.</li> <li>Deterministic Outputs: Ensure your peripheral and bus implementation logic respects the deterministic execution model. Avoid unpredictable or non-reproducible states.</li> <li>Follow the Onboarding SOP: If onboarding a board, follow all phase gates in <code>docs/board_onboarding_playbook.md</code>. It mandates adding test fixtures, examples, config YAML files, and reporting.</li> <li>Scope Your Commits: Keep tasks strictly scoped to their definition. Avoid speculative refactors or out-of-bounds improvements to stable core files if not requested.</li> </ol>"},{"location":"architecture/","title":"Architecture Internals","text":"<p>LabWired is a modular execution engine designed to decouple the CPU core from the memory and peripheral bus. This design enables the simulation of multi-architecture systems within a unified peripheral environment.</p>"},{"location":"architecture/#1-core-execution-engine-labwired-core","title":"1. Core Execution Engine (<code>labwired-core</code>)","text":"<p>The <code>labwired-core</code> crate provides the central execution loop and state management.</p>"},{"location":"architecture/#pluggable-cpu-abstraction","title":"Pluggable CPU Abstraction","text":"<p>The execution engine is generic over a <code>Cpu</code> trait, allowing for different instruction set architectures (ISAs) to interface with the same system bus.</p> <pre><code>pub trait Cpu {\n    /// Resets the CPU state (PC, SP, etc.)\n    fn reset(&amp;mut self, bus: &amp;mut dyn Bus) -&gt; SimResult&lt;()&gt;;\n\n    /// Executes a single instruction cycle\n    fn step(\n        &amp;mut self, \n        bus: &amp;mut dyn Bus, \n        observers: &amp;[Arc&lt;dyn SimulationObserver&gt;],\n        config: &amp;SimulationConfig\n    ) -&gt; SimResult&lt;()&gt;;\n}\n</code></pre> <p>The system currently implements: - Cortex-M (ARMv7-M): Supports Thumb-2 instruction decoding. - RISC-V (RV32I): Supports base integer instruction set.</p>"},{"location":"architecture/#memory-model","title":"Memory Model","text":"<p>The memory system uses a linear addressing model mapped to host memory regions. - Flash: Read-only segments populated from the ELF binary. - RAM: Read-write segments initialized to zero. - MMIO: Addresses outside predefined memory regions are routed to the Peripheral Bus.</p>"},{"location":"architecture/#2-peripheral-interface","title":"2. Peripheral Interface","text":"<p>Peripherals communicate with the CPU via the <code>Peripheral</code> trait. This trait defines the contract for Memory-Mapped I/O (MMIO) and time-based state updates.</p> <pre><code>pub trait Peripheral {\n    fn read(&amp;self, offset: u64) -&gt; SimResult&lt;u8&gt;;\n    fn write(&amp;mut self, offset: u64, value: u8) -&gt; SimResult&lt;()&gt;;\n    fn tick(&amp;mut self) -&gt; PeripheralTickResult;\n}\n</code></pre> <p>This model prevents race conditions where a peripheral modifies memory while the CPU is executing, ensuring strict sequential consistency.</p>"},{"location":"architecture/#optimized-execution","title":"Optimized Execution","text":"<p>To achieve high MIPS (Million Instructions Per Second) for autonomous agents, LabWired supports configurable performance gates: - Instruction Decode Cache: A direct-mapped cache in the CPU core that avoids re-decoding instructions on every hit. - Multi-Byte Bus Fast-Path: Specialized 16/32-bit access methods in <code>SystemBus</code> that bypass the virtual <code>read_u8</code> loop for memory regions (RAM/Flash). - Batched Ticking: Configurable <code>peripheral_tick_interval</code>. Ticking every N cycles instead of every instruction significantly reduces virtual call overhead in the hot path.</p> <p>Defaults and gating are controlled via <code>SimulationConfig</code>. Setting <code>peripheral_tick_interval</code> to 1 and disabling caches restores strict cycle-accurate behavior for time-sensitive firmware.</p>"},{"location":"architecture/#3-thumb-2-decoder","title":"3. Thumb-2 Decoder","text":"<p>The Cortex-M implementation uses a custom stateless decoder for the ARMv7-M Thumb-2 instruction set.</p> <p>Supported Instruction Classes: - 32-bit Instructions: <code>BL</code>, <code>MOVW</code>, <code>MOVT</code> (handled via double half-word fetch). - Control Flow: <code>B</code>, <code>BL</code>, <code>BX</code>, <code>CBZ/CBNZ</code>, <code>IT</code> blocks. - Arithmetic/Logic: <code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>SDIV/UDIV</code>, <code>AND</code>, <code>ORR</code>, <code>EOR</code>. - Bit Manipulation: <code>BFI</code>, <code>UBFX</code>, <code>CLZ</code>, <code>RBIT</code>.</p>"},{"location":"architecture/#4-debug-integration","title":"4. Debug Integration","text":"<p>LabWired integrates with external debuggers via standard protocols.</p>"},{"location":"architecture/#gdb-remote-serial-protocol-rsp","title":"GDB Remote Serial Protocol (RSP)","text":"<p>The <code>labwired-gdbstub</code> crate implements the RSP server, allowing <code>gdb-multiarch</code> to attach to the simulation. It supports: - Breakpoints (Software/Hardware) - Single-stepping - Register and Memory inspection</p>"},{"location":"architecture/#debug-adapter-protocol-dap","title":"Debug Adapter Protocol (DAP)","text":"<p>The <code>labwired-dap</code> crate provides a direct interface for VS Code. It exposes: - State Inspection: Live view of registers and call stack. - Telemetry: A custom event stream for real-time performance metrics (Cycles, MIPS) without polling overhead.</p>"},{"location":"architecture_guide/","title":"LabWired Architecture Guide","text":"<p>LabWired is a modular, high-fidelity embedded systems simulator written in Rust. It isolates hardware description (Asset Foundry) from execution logic (Core Engine), linked by a Strict Intermediate Representation (IR).</p> <pre><code>graph TD\n    %% Subsystems\n    subgraph \"Asset Foundry (Ingestion)\"\n        SVD[Vendor SVD] --&gt;|import-svd| IR[Strict IR (JSON)]\n        IR --&gt;|Codegen| RustModel[Rust Core Model]\n    end\n\n    subgraph \"Execution Engine (Core)\"\n        ELF[Firmware ELF] --&gt; Loader\n        Loader --&gt; Machine\n        RustModel --&gt; Machine\n\n        Machine --&gt; CPU[CPU (ARM/RISC-V)]\n        Machine --&gt; Bus[System Bus]\n        Bus --&gt; Memory\n        Bus --&gt; Peripherals\n    end\n\n    subgraph \"Interfaces\"\n        CLI[labwired-cli] --&gt; Machine\n        GDB[GDB Stub] -.-&gt; Machine\n        DAP[VS Code DAP] -.-&gt; Machine\n    end</code></pre>"},{"location":"architecture_guide/#1-asset-foundry-cratesir","title":"1. Asset Foundry (<code>crates/ir</code>)","text":"<p>The Asset Foundry is the supply chain for simulation models. It solves the problem of \"dirty\" vendor data.</p> <ul> <li>Input: Vendor SVD files (often broken, inconsistent).</li> <li>Process: Use <code>labwired asset import-svd</code> to flatten, unroll, and sanitize.</li> <li>Output: Strict IR (<code>labwired-ir</code>). A JSON format where:<ul> <li>All arrays (<code>UART0</code>, <code>UART1</code>) are unrolled.</li> <li>All inheritance (<code>derivedFrom</code>) is resolved.</li> <li>All clusters are flattened.</li> </ul> </li> <li>Goal: Zero-ambiguity input for the simulation core.</li> </ul>"},{"location":"architecture_guide/#2-the-core-engine-cratescore","title":"2. The Core Engine (<code>crates/core</code>)","text":"<p>The simulation runtime. It is <code>no_std</code> compatible and designed for deterministic execution.</p>"},{"location":"architecture_guide/#components","title":"Components","text":"<ul> <li>Machine: The top-level container holding CPU, Bus, and Peripherals.</li> <li>Cpu Trait: Abstract interface allowing <code>Cortex-M</code> or <code>RISC-V</code> implementations to be swapped.</li> <li>SystemBus: dynamically routes memory accesses (<code>read</code>/<code>write</code>) to:<ul> <li>Linear Memory: RAM/Flash (byte arrays).</li> <li>Peripherals: Structs implementing the <code>Peripheral</code> trait.</li> </ul> </li> </ul>"},{"location":"architecture_guide/#two-phase-execution-state-side-effects","title":"Two-Phase Execution (State &amp; Side-Effects)","text":"<p>To satisfy Rust's borrow checker and ensure determinism: 1.  Tick Phase: Peripherals update internal state and return Request Objects (e.g., <code>DmaRequest</code>, <code>InterruptRequest</code>). 2.  Resolution Phase: The Bus processes these requests, modifying memory or triggering CPU exceptions.</p>"},{"location":"architecture_guide/#3-peripheral-modeling","title":"3. Peripheral Modeling","text":"<p>We prioritize Tier 1 Devices for deep support (see <code>../../docs/SUPPORTED_DEVICES.md</code>): *   STM32F4 (Cortex-M4) *   RP2040 (Dual Cortex-M0+) *   nRF52 (Cortex-M4F)</p> <p>Peripherals are implemented as Rust structs that mimic hardware logic (registers, bitfields, state machines).</p>"},{"location":"architecture_guide/#4-interfaces-cratescli-cratesdap","title":"4. Interfaces (<code>crates/cli</code>, <code>crates/dap</code>)","text":"<ul> <li>CLI: The main entry point. Runs simulations, imports assets, and manages configuration.</li> <li>DAP Server: Implements the Debug Adapter Protocol for seamless VS Code integration.<ul> <li>Typically listens on TCP <code>5000</code>.</li> <li>Provides specialized telemetry events (PC, Cycles, Power) to the IDE.</li> </ul> </li> </ul>"},{"location":"architecture_guide/#directory-structure","title":"Directory Structure","text":"<ul> <li><code>core/crates/ir</code>: Strict IR definitions and SVD transformation logic.</li> <li><code>core/crates/core</code>: CPU, Bus, and Device traits.</li> <li><code>core/crates/cli</code>: Command-line driver.</li> <li><code>core/crates/loader</code>: ELF parsing.</li> <li><code>core/crates/config</code>: Configuration file parsing (system manifest).</li> </ul>"},{"location":"board_onboarding_playbook/","title":"Board Onboarding Playbook","text":"<p>This guide documents the procedure for adding new board targets to LabWired. It is designed for contributors and agents to ensure consistent, high-quality board support.</p>"},{"location":"board_onboarding_playbook/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before starting, acquire the following primary sources: 1.  MCU Reference Manual (e.g., STM32H5 Reference Manual). 2.  Datasheet (for memory map boundaries). 3.  Board User Manual (for LED/Button GPIO mapping). 4.  CMSIS Device Headers (optional but helpful for IRQ numbers).</p>"},{"location":"board_onboarding_playbook/#2-fit-assessment","title":"2. Fit Assessment","text":"<p>Verify that LabWired supports the critical peripherals required for a minimal \"smoke test\" (boot + UART output).</p> <p>Supported Peripherals: - <code>rcc</code> (Reset and Clock Control) - Essential for boot. - <code>gpio</code> (General Purpose I/O) - Essential for pin muxing. - <code>uart</code> (Universal Asynchronous Receiver-Transmitter) - Essential for debug output. - <code>systick</code> (System Tick Timer) - Essential for RTOS/HAL timekeeping.</p> <p>If the board requires complex peripherals (USB, Ethernet) for basic operation, it may not be a good candidate for initial onboarding.</p>"},{"location":"board_onboarding_playbook/#3-implementation-steps","title":"3. Implementation Steps","text":""},{"location":"board_onboarding_playbook/#step-1-chip-descriptor-coreconfigschips","title":"Step 1: Chip Descriptor (<code>core/configs/chips/</code>)","text":"<p>Create a YAML file defining the MCU's memory map and internal peripherals.</p> <p>Example: <code>stm32h563.yaml</code> <pre><code>name: \"STM32H563\"\nflash:\n  base: 0x08000000\n  size: \"2MB\"\nram:\n  base: 0x20000000\n  size: \"640KB\"\n\nperipherals:\n  - id: \"rcc\"\n    type: \"rcc\"\n    base_address: 0x44020C00\n\n  - id: \"usart3\"\n    type: \"uart\"\n    base_address: 0x40004800\n    irq: 55\n</code></pre> Source of Truth: MCU Reference Manual (Memory Map section).</p>"},{"location":"board_onboarding_playbook/#step-2-system-manifest-coreconfigssystems","title":"Step 2: System Manifest (<code>core/configs/systems/</code>)","text":"<p>Create a YAML file instantiating the chip and defining board-level connections.</p> <p>Example: <code>nucleo-h563zi.yaml</code> <pre><code>name: \"NUCLEO-H563ZI\"\nchip: \"../chips/stm32h563.yaml\"\n\n# Define board-level connections (e.g., Virtual COM Port)\nconnectors:\n  - type: \"uart\"\n    peripheral: \"usart3\"\n    endpoint: \"host_console\"\n</code></pre> Source of Truth: Board User Manual (Schematics/Connector definition).</p>"},{"location":"board_onboarding_playbook/#step-3-smoke-firmware","title":"Step 3: Smoke Firmware","text":"<p>Create a minimal Rust/C firmware to verify execution. - Goal: Initialize UART and print \"OK\". - Constraints: No external dependencies if possible (minimize HAL complexity).</p>"},{"location":"board_onboarding_playbook/#4-validation","title":"4. Validation","text":"<p>Run the standardized onboarding test suite.</p> <pre><code># 1. Build Smoke Firmware\ncargo build --release --target thumbv7m-none-eabi -p smoke-firmware\n\n# 2. Run Simulation with Audit\nlabwired --firmware target/thumbv7m-none-eabi/release/smoke-firmware \\\n         --system configs/systems/nucleo-h563zi.yaml \\\n         --audit-unsupported\n</code></pre> <p>Success Criteria: 1.  Boot: PC initializes to Reset Vector. 2.  UART: \"OK\" printed to stdout. 3.  Audit: No critical \"Unmapped Peripheral\" errors (warnings are acceptable for unused blocks).</p>"},{"location":"board_onboarding_playbook/#5-documentation","title":"5. Documentation","text":"<p>Create a folder in <code>core/examples/&lt;board&gt;/</code> containing: 1.  <code>README.md</code>: Board specific instructions. 2.  <code>system.yaml</code>: A local copy of the system manifest for easy reproduction. 3.  <code>smoke.rs</code> (or reference): The source code used for validation.</p>"},{"location":"case_study_stm32/","title":"Case Study: Debugging STM32 Without Hardware","text":""},{"location":"case_study_stm32/#the-problem","title":"The Problem","text":"<p>Embedded development typically requires physical hardware, even for basic testing. This leads to several challenges: - Bottlenecks: Teams waiting for prototype hardware to arrive. - Complexity: Debugging I2C/SPI timing issues requires logic analyzers or oscilloscopes. - CI/CD Gaps: Hard to run automated tests for firmware on real hardware in every PR.</p>"},{"location":"case_study_stm32/#the-labwired-solution","title":"The LabWired Solution","text":"<p>LabWired allows developers to simulate an entire STM32-based system, including external peripherals like sensors, directly in their local environment and VS Code.</p>"},{"location":"case_study_stm32/#scenario-i2c-temperature-sensor-integration","title":"Scenario: I2C Temperature Sensor Integration","text":"<p>In this demo, we integrated a TMP102 temperature sensor with an STM32F103 microcontroller.</p>"},{"location":"case_study_stm32/#1-hardware-free-simulation","title":"1. Hardware-Free Simulation","text":"<p>Instead of wiring physical pins, we defined the sensor and its connection in a declarative YAML file:</p> <pre><code># system.yaml\nexternal_devices:\n  - id: \"temp_sensor\"\n    type: \"tmp102\"\n    connection: \"i2c1\"\n    config:\n      i2c_address: 0x48\n</code></pre>"},{"location":"case_study_stm32/#2-realistic-firmware","title":"2. Realistic Firmware","text":"<p>The firmware uses standard STM32 peripheral registers (RCC, GPIO, I2C) to communicate with the virtual sensor. The emulator handles these register accesses and routes them to the virtual device model.</p>"},{"location":"case_study_stm32/#3-one-click-debugging","title":"3. One-Click Debugging","text":"<p>Using the LabWired VS Code extension, the developer can: - Set Breakpoints: Pause execution exactly where the sensor is being read. - Inspect Registers: View the status of the I2C control registers and the data register. - Step Through Logic: Verify that the temperature conversion logic handles negative values or overflow correctly.</p>"},{"location":"case_study_stm32/#impact","title":"Impact","text":"<ul> <li>Zero Setup Costs: No hardware, cables, or probes required.</li> <li>Instant Reproducibility: High-fidelity simulation ensures a bug in simulation is a bug in hardware.</li> <li>Modern Workflow: Bring the power of modern software development (CI/CD, fast iteration) to the embedded world.</li> </ul>"},{"location":"case_study_stm32/#technical-highlights","title":"Technical Highlights","text":"<ul> <li>Cortex-M3 Core: High-fidelity instruction execution.</li> <li>Declarative Peripherals: Easily add new sensors by writing YAML descriptors.</li> <li>DAP Integration: Seamless connection to VS Code.</li> </ul> <p>Back to LabWired Core</p>"},{"location":"ci_integration/","title":"CI Integration","text":"<p>This guide details the integration of LabWired firmware simulations into continuous integration (CI) pipelines. By replacing physical hardware with deterministic simulation, teams can achieve scalable, parallelized regression testing.</p>"},{"location":"ci_integration/#1-quick-start","title":"1. Quick Start","text":""},{"location":"ci_integration/#github-actions","title":"GitHub Actions","text":"<p>To enable automated testing on every push, create a workflow file at <code>.github/workflows/firmware-test.yml</code>:</p> <pre><code>name: Firmware Simulation\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build Firmware\n        run: cargo build --release --target thumbv7m-none-eabi\n\n      - name: Run Simulation\n        uses: w1ne/labwired/.github/actions/labwired-test@main\n        with:\n          script: tests/basic_boot.yaml\n          artifact_name: test-results\n</code></pre>"},{"location":"ci_integration/#gitlab-ci","title":"GitLab CI","text":"<p>For GitLab, add the following to <code>.gitlab-ci.yml</code>:</p> <pre><code>test_simulation:\n  image: rust:latest\n  script:\n    - cargo build --release --target thumbv7m-none-eabi\n    - curl -L https://github.com/w1ne/labwired/releases/latest/download/labwired-cli -o labwired\n    - chmod +x labwired\n    - ./labwired test --script tests/basic_boot.yaml\n</code></pre>"},{"location":"ci_integration/#2-test-script-schema","title":"2. Test Script Schema","text":"<p>LabWired uses a YAML-based test definition format to specify inputs, constraints, and assertions.</p> <pre><code>schema_version: \"1.0\"\n\ninputs:\n  firmware: \"target/thumbv7m-none-eabi/release/firmware.elf\"\n  system: \"configs/system.yaml\"\n\nlimits:\n  max_steps: 100000        # Instruction limit\n  wall_time_ms: 5000       # Real-time timeout\n  max_cycles: 50000000     # Simulation cycle limit\n\nassertions:\n  - uart_contains: \"Boot Successful\"\n  - expected_stop_reason: \"halt\"\n</code></pre>"},{"location":"ci_integration/#3-integration-patterns","title":"3. Integration Patterns","text":""},{"location":"ci_integration/#matrix-testing","title":"Matrix Testing","text":"<p>Validate firmware across multiple compile targets or configurations in parallel.</p> <p>GitHub Actions Example: <pre><code>strategy:\n  matrix:\n    target: [thumbv6m-none-eabi, thumbv7m-none-eabi]\nsteps:\n  - run: cargo build --target ${{ matrix.target }}\n  - uses: w1ne/labwired/.github/actions/labwired-test@main\n    with:\n      script: tests/${{ matrix.target }}.yaml\n</code></pre></p>"},{"location":"ci_integration/#fault-injection","title":"Fault Injection","text":"<p>Simulate hardware failures (e.g., sensor disconnects) in CI to verify error handling paths that are difficult to trigger on physical devices.</p> <pre><code># tests/sensor_fail.yaml\nsteps:\n  - run: 100ms\n  - write_peripheral:\n      id: \"i2c1\"\n      reg: \"CR1\"\n      value: 0x0000 # Disable I2C controller mid-operation\n  - assert_log: \"I2C Error Detected\"\n</code></pre>"},{"location":"ci_integration/#4-artifacts-and-reporting","title":"4. Artifacts and Reporting","text":"<p>The test runner produces machine-readable outputs for integration with CI reporting tools.</p> <ul> <li><code>result.json</code>: Detailed execution statistics (cycles, instructions, assertion results).</li> <li><code>junit.xml</code>: Standard JUnit format for test result visualization in GitHub/GitLab UI.</li> <li><code>uart.log</code>: Captured serial output for debugging failures.</li> </ul> <p>Ensure your CI pipeline is configured to archive these artifacts upon failure.</p>"},{"location":"ci_integration/#5-onboarding-kpi-tracking","title":"5. Onboarding KPI Tracking","text":"<p>For board onboarding competitiveness, <code>core-onboarding-smoke.yml</code> runs a deterministic smoke path and emits:</p> <ul> <li><code>onboarding-metrics.json</code>: elapsed time, failure stage, and first error signature.</li> <li><code>onboarding-summary.md</code>: per-target summary for step output.</li> <li><code>onboarding-scoreboard.json</code> / <code>onboarding-scoreboard.md</code>: aggregated run-level view.</li> </ul> <p>This workflow uses a soft threshold (<code>3600s</code>) to track time-to-first-smoke without blocking merges.</p>"},{"location":"ci_test_runner/","title":"CI Test Runner (<code>labwired test</code>)","text":"<p>LabWired provides a CI-friendly runner mode driven by a YAML test script:</p> <pre><code>labwired test --script test.yaml\n</code></pre> <p>You can override script inputs with CLI flags:</p> <pre><code>labwired test --firmware path/to/fw.elf --system system.yaml --script test.yaml\n</code></pre>"},{"location":"ci_test_runner/#exit-codes","title":"Exit Codes","text":"Code Meaning Notes <code>0</code> Pass All assertions passed, and any non-success stop reason was explicitly asserted (if applicable). <code>1</code> Assertion failure Includes failed assertions, and hitting <code>wall_time_ms</code> / <code>max_uart_bytes</code> / <code>no_progress_steps</code> without asserting the matching <code>expected_stop_reason</code>. <code>2</code> Config/script error Invalid YAML, unknown fields, unsupported schema_version, missing/invalid inputs/limits, or a safety guard (e.g. max-steps cap). <code>3</code> Simulation/runtime error Runtime failure (e.g. <code>memory_violation</code>, <code>decode_error</code>) unless an <code>expected_stop_reason</code> assertion matches the stop reason. <p>Exit-code precedence: 1) Any failed assertion \u21d2 <code>1</code> (even if a runtime error also occurred) 2) <code>wall_time</code> / <code>max_uart_bytes</code> / <code>no_progress</code> stop without matching <code>expected_stop_reason</code> \u21d2 <code>1</code> 3) Runtime error stop without matching <code>expected_stop_reason</code> \u21d2 <code>3</code> 4) Otherwise \u21d2 <code>0</code></p>"},{"location":"ci_test_runner/#script-schema-v10","title":"Script Schema (v1.0)","text":"<pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"relative/or/absolute/path/to/fw.elf\"\n  system: \"optional/path/to/system.yaml\"\nlimits:\n  max_steps: 100000\n  max_cycles: 123456     # optional\n  max_uart_bytes: 4096   # optional\n  no_progress_steps: 500 # optional (PC unchanged for N steps)\n  wall_time_ms: 5000   # optional\nassertions:\n  - uart_contains: \"Hello\"\n  - uart_regex: \"^Hello.*$\"\n  - expected_stop_reason: max_steps\n</code></pre> <p>Notes: - Unknown fields are rejected (script parse/validation returns exit code <code>2</code>). - Relative <code>inputs.firmware</code> / <code>inputs.system</code> paths are resolved relative to the directory containing the script file (not the current working directory). - CLI flags override script inputs:   - <code>--firmware</code> overrides <code>inputs.firmware</code>   - <code>--system</code> overrides <code>inputs.system</code> - CLI flags override script limits:   - <code>--max-steps</code> overrides <code>limits.max_steps</code>   - <code>--max-cycles</code> overrides <code>limits.max_cycles</code>   - <code>--max-uart-bytes</code> overrides <code>limits.max_uart_bytes</code>   - <code>--detect-stuck</code> (alias: <code>--no-progress</code>) overrides <code>limits.no_progress_steps</code> - <code>--breakpoint &lt;addr&gt;</code> (repeatable) stops the run when PC matches and sets <code>stop_reason: halt</code>.</p>"},{"location":"ci_test_runner/#deprecated-legacy-schema-v1","title":"Deprecated Legacy Schema (v1)","text":"<p>For backward compatibility, <code>schema_version: 1</code> is still accepted, but is deprecated and will be removed in a future release.</p> <p>Legacy shape:</p> <pre><code>schema_version: 1\nfirmware: \"optional/path/to/fw.elf\"   # optional (can be provided by --firmware)\nsystem: \"optional/path/to/system.yaml\"\nmax_steps: 100000\nwall_time_ms: 5000   # optional\nassertions: []\n</code></pre>"},{"location":"ci_test_runner/#stop-reasons","title":"Stop Reasons","text":"<p><code>expected_stop_reason</code> supports: - <code>max_steps</code> - <code>max_cycles</code> - <code>max_uart_bytes</code> - <code>no_progress</code> - <code>wall_time</code> - <code>memory_violation</code> - <code>decode_error</code> - <code>halt</code> - <code>config_error</code> (runner failed before simulation started; e.g. script parse/validation error)</p> <p>Semantics: - If the simulator hits <code>wall_time_ms</code>, the run is treated as an assertion failure (exit code <code>1</code>) unless an <code>expected_stop_reason</code> assertion matches <code>wall_time</code>. - If the simulator hits <code>max_uart_bytes</code> or <code>no_progress_steps</code>, the run is treated as an assertion failure (exit code <code>1</code>) unless an <code>expected_stop_reason</code> assertion matches (<code>max_uart_bytes</code> / <code>no_progress</code>). - If the simulator hits <code>max_steps</code> or <code>max_cycles</code>, the run is considered a normal stop (exit code <code>0</code>) as long as assertions pass. - If the simulator hits a runtime error stop reason (e.g. <code>memory_violation</code>), the run is treated as a runtime error (exit code <code>3</code>) unless an <code>expected_stop_reason</code> assertion matches the stop reason.</p> <p><code>result.json</code> uses: - <code>result_schema_version</code>: version of the <code>result.json</code> contract (currently <code>\"1.0\"</code>) - <code>stop_reason</code>: the terminal reason the simulator stopped - <code>stop_reason_details</code>: which stop condition triggered (+ the limit/observed value when applicable) - <code>limits</code>: the resolved limits used for the run (after applying any CLI overrides) - <code>status</code>: one of <code>pass</code>, <code>fail</code>, <code>error</code></p>"},{"location":"ci_test_runner/#artifacts","title":"Artifacts","text":"<p>Use <code>--output-dir</code> to write artifacts:</p> <pre><code>labwired test --script test.yaml --output-dir out/artifacts\n</code></pre> <p>Artifacts: - <code>out/artifacts/result.json</code>: machine-readable summary - <code>out/artifacts/snapshot.json</code>: machine-readable snapshot of CPU state (or config error details) - <code>out/artifacts/uart.log</code>: captured UART TX bytes - <code>out/artifacts/junit.xml</code>: JUnit XML report (one testcase for <code>run</code> + one per assertion)</p> <p>Alternatively, you can write JUnit XML to a specific path:</p> <pre><code>labwired test --script test.yaml --junit out/junit.xml\n</code></pre>"},{"location":"ci_test_runner/#path-resolution-rules","title":"Path Resolution Rules","text":"<ul> <li><code>--script</code>: if relative, resolved relative to the current working directory.</li> <li>Script-relative paths:</li> <li><code>inputs.firmware</code>, <code>inputs.system</code> (v1.0)</li> <li><code>firmware</code>, <code>system</code> (legacy v1)   are resolved relative to the directory containing the script file.</li> <li>System manifest-relative paths: <code>system.yaml</code> may reference <code>chip: ...</code>; this <code>chip</code> path is resolved relative to the directory containing the system manifest file.</li> <li><code>--output-dir</code> / <code>--junit</code>: if relative, resolved relative to the current working directory.</li> </ul>"},{"location":"ci_test_runner/#resultjson-contract-v10","title":"<code>result.json</code> Contract (v1.0)","text":"<p>The runner writes <code>result.json</code> only when <code>--output-dir</code> is provided (including config/script errors that exit with code <code>2</code>).</p>"},{"location":"ci_test_runner/#json-schema","title":"JSON Schema","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"LabWired CI runner result.json (v1.0)\",\n  \"type\": \"object\",\n  \"additionalProperties\": false,\n  \"required\": [\n    \"result_schema_version\",\n    \"status\",\n    \"steps_executed\",\n    \"cycles\",\n    \"instructions\",\n    \"stop_reason\",\n    \"stop_reason_details\",\n    \"limits\",\n    \"assertions\",\n    \"firmware_hash\",\n    \"config\"\n  ],\n  \"properties\": {\n    \"result_schema_version\": {\n      \"type\": \"string\",\n      \"enum\": [\"1.0\"]\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\"pass\", \"fail\", \"error\"]\n    },\n    \"steps_executed\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"cycles\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"instructions\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"stop_reason\": {\n      \"type\": \"string\",\n      \"enum\": [\n        \"config_error\",\n        \"max_steps\",\n        \"max_cycles\",\n        \"max_uart_bytes\",\n        \"no_progress\",\n        \"wall_time\",\n        \"memory_violation\",\n        \"decode_error\",\n        \"halt\"\n      ]\n    },\n    \"message\": { \"type\": [\"string\", \"null\"] },\n    \"stop_reason_details\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\"triggered_stop_condition\", \"triggered_limit\", \"observed\"],\n      \"properties\": {\n        \"triggered_stop_condition\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"config_error\",\n            \"max_steps\",\n            \"max_cycles\",\n            \"max_uart_bytes\",\n            \"no_progress\",\n            \"wall_time\",\n            \"memory_violation\",\n            \"decode_error\",\n            \"halt\"\n          ]\n        },\n        \"triggered_limit\": {\n          \"type\": [\"object\", \"null\"],\n          \"additionalProperties\": false,\n          \"required\": [\"name\", \"value\"],\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"value\": { \"type\": \"integer\", \"minimum\": 0 }\n          }\n        },\n        \"observed\": {\n          \"type\": [\"object\", \"null\"],\n          \"additionalProperties\": false,\n          \"required\": [\"name\", \"value\"],\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"value\": { \"type\": \"integer\", \"minimum\": 0 }\n          }\n        }\n      }\n    },\n    \"limits\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\n        \"max_steps\",\n        \"max_cycles\",\n        \"max_uart_bytes\",\n        \"no_progress_steps\",\n        \"wall_time_ms\"\n      ],\n      \"properties\": {\n        \"max_steps\": { \"type\": \"integer\", \"minimum\": 0 },\n        \"max_cycles\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"max_uart_bytes\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"no_progress_steps\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 },\n        \"wall_time_ms\": { \"type\": [\"integer\", \"null\"], \"minimum\": 0 }\n      }\n    },\n    \"message\": {\n      \"type\": \"string\",\n      \"description\": \"Present only for config errors / invalid inputs.\"\n    },\n    \"assertions\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"assertion\", \"passed\"],\n        \"properties\": {\n          \"passed\": { \"type\": \"boolean\" },\n          \"assertion\": {\n            \"oneOf\": [\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"uart_contains\"],\n                \"properties\": { \"uart_contains\": { \"type\": \"string\" } }\n              },\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"uart_regex\"],\n                \"properties\": { \"uart_regex\": { \"type\": \"string\" } }\n              },\n              {\n                \"type\": \"object\",\n                \"additionalProperties\": false,\n                \"required\": [\"expected_stop_reason\"],\n                \"properties\": {\n                  \"expected_stop_reason\": {\n                    \"type\": \"string\",\n                    \"enum\": [\n                      \"max_steps\",\n                      \"max_cycles\",\n                      \"max_uart_bytes\",\n                      \"no_progress\",\n                      \"wall_time\",\n                      \"memory_violation\",\n                      \"decode_error\",\n                      \"halt\"\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    },\n    \"firmware_hash\": {\n      \"type\": \"string\",\n      \"description\": \"SHA-256 of the firmware ELF bytes (lowercase hex).\",\n      \"pattern\": \"^[0-9a-f]{64}$\"\n    },\n    \"config\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"required\": [\"firmware\", \"system\", \"script\"],\n      \"properties\": {\n        \"firmware\": { \"type\": \"string\" },\n        \"system\": { \"type\": [\"string\", \"null\"] },\n        \"script\": { \"type\": \"string\" }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"ci_test_runner/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>- name: Run LabWired tests\n  run: |\n    cargo build --release -p labwired-cli\n    ./target/release/labwired test \\\n      --script examples/ci/dummy-max-steps.yaml \\\n      --output-dir out/artifacts \\\n      --no-uart-stdout\n- name: Upload artifacts (pass/fail)\n  if: always()\n  uses: actions/upload-artifact@v4\n  with:\n    name: labwired-artifacts\n    path: out/artifacts\n    if-no-files-found: warn\n</code></pre>"},{"location":"ci_test_runner/#copy-paste-workflow-composite-action","title":"Copy-Paste Workflow (Composite Action)","text":"<p>This repo includes a minimal composite action wrapper at <code>.github/actions/labwired-test</code> that: - builds <code>labwired</code> (<code>crates/cli</code>) - runs <code>labwired test</code> - emits artifact paths as outputs - writes a small summary into the GitHub Actions step summary</p> <p>Copy-paste this workflow into <code>.github/workflows/labwired-test.yml</code>:</p> <pre><code>name: LabWired CI Test\n\non:\n  pull_request:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  labwired-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run labwired test\n        id: labwired\n        uses: ./.github/actions/labwired-test\n        with:\n          script: examples/ci/dummy-max-steps.yaml\n          output_dir: out/artifacts\n          no_uart_stdout: true\n          profile: release\n\n      - name: Upload artifacts (pass/fail)\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: labwired-artifacts\n          path: ${{ steps.labwired.outputs.artifacts_dir }}\n          if-no-files-found: warn\n\n      - name: Fail job if test failed\n        if: ${{ steps.labwired.outputs.exit_code != '0' }}\n        run: |\n          echo \"labwired test failed with exit_code=${{ steps.labwired.outputs.exit_code }}\"\n          exit ${{ steps.labwired.outputs.exit_code }}\n</code></pre>"},{"location":"ci_test_runner/#local-vs-ci-parity","title":"Local vs CI Parity","text":"<p>CI runs the same <code>labwired test</code> command you can run locally; the only CI-specific behavior is how artifacts are uploaded and how the summary is displayed.</p> <p>Local (native):</p> <pre><code>cargo build --release -p labwired-cli\n./target/release/labwired test --script examples/ci/dummy-max-steps.yaml --output-dir out/artifacts --no-uart-stdout\n</code></pre> <p>Local (Docker, closest to \u201cclean CI machine\u201d):</p> <pre><code>docker build -t labwired-ci .\ndocker run --rm -v \"$PWD:/work\" -w /work labwired-ci \\\n  labwired test --script examples/ci/dummy-max-steps.yaml --output-dir out/artifacts --no-uart-stdout\n</code></pre>"},{"location":"cli_reference/","title":"CLI Reference","text":"<p>The <code>labwired</code> command-line interface is the primary entry point for running simulations, testing, and managing assets.</p>"},{"location":"cli_reference/#global-options","title":"Global Options","text":"<p>These options apply to the interactive runner and most subcommands.</p> Option Description <code>--trace</code> Enable instruction-level execution tracing (prints every executed instruction). <code>--json</code> Output errors and diagnostics as structured JSON for agent consumption. <code>--vcd &lt;PATH&gt;</code> Output a Value Change Dump (VCD) trace file to the specified path. <code>--version</code> Print version information. <code>--help</code> Print help message."},{"location":"cli_reference/#modes-commands","title":"Modes &amp; Commands","text":""},{"location":"cli_reference/#interactive-run-mode-default","title":"Interactive / Run Mode (Default)","text":"<p>Executes a firmware simulation interactively. If no subcommand is provided, this mode is used.</p> <pre><code>labwired [OPTIONS] --firmware &lt;ELF&gt; --system &lt;YAML&gt;\n</code></pre> <p>Options: - <code>--firmware &lt;PATH&gt;</code>: Path to the ELF binary to load (Required). - <code>--system &lt;PATH&gt;</code>: Path to the System Manifest YAML (Required). - <code>--max-steps &lt;N&gt;</code>: Stop simulation after N instructions (default: 20000). - <code>--gdb &lt;PORT&gt;</code>: Start a GDB RSP server on the specified port (e.g., 3333). - <code>--breakpoint &lt;ADDR&gt;</code>: Breakpoint PC address (decimal or 0xHex). Repeatable. - <code>--snapshot &lt;PATH&gt;</code>: Write a state snapshot (JSON) upon exit.</p>"},{"location":"cli_reference/#test","title":"<code>test</code>","text":"<p>Runs a CI-friendly test script with assertions.</p> <pre><code>labwired test --script &lt;YAML&gt; [OVERRIDES]\n</code></pre> <p>Options: - <code>-c, --script &lt;PATH&gt;</code>: Path to the test script (see Test Runner). - <code>-f, --firmware &lt;PATH&gt;</code>: Override the firmware path defined in the script. - <code>-s, --system &lt;PATH&gt;</code>: Override the system manifest defined in the script. - <code>--output-dir &lt;PATH&gt;</code>: Directory to write artifacts (<code>result.json</code>, <code>uart.log</code>). - <code>--junit &lt;PATH&gt;</code>: Path to write JUnit XML report. - <code>--max-steps &lt;N&gt;</code>: Override default step limit. - <code>--max-cycles &lt;N&gt;</code>: Override cycle limit. - <code>--max-uart-bytes &lt;N&gt;</code>: Override UART output limit. - <code>--no-progress &lt;N&gt;</code>: Fail if PC doesn't change for N steps (detects hangs). - <code>--no-uart-stdout</code>: Disable echoing UART output to the console. - <code>--max-vcd-bytes &lt;N&gt;</code>: Limit the size of the generated VCD file.</p>"},{"location":"cli_reference/#asset","title":"<code>asset</code>","text":"<p>Utilities for managing LabWired assets (SVD import, Code Generation, etc.).</p> <pre><code>labwired asset &lt;SUBCOMMAND&gt;\n</code></pre> <p>Subcommands: - <code>import-svd</code>: Import an SVD file and convert it to Strict IR (JSON).   - <code>-i, --input &lt;SVD&gt;</code>: Input SVD file.   - <code>-o, --output &lt;JSON&gt;</code>: Output JSON file. - <code>codegen</code>: Generate Rust code from Strict IR.   - <code>-i, --input &lt;JSON&gt;</code>: Input IR file.   - <code>-o, --output &lt;RS&gt;</code>: Output Rust source file. - <code>init</code>: Initialize a new project skeleton.   - <code>-o, --output &lt;DIR&gt;</code>: Output directory.   - <code>-c, --chip &lt;NAME&gt;</code>: Chip name to base the project on. - <code>add-peripheral</code>: Add a peripheral to an existing chip descriptor.   - <code>-c, --chip &lt;YAML&gt;</code>: Target chip descriptor.   - <code>--id &lt;NAME&gt;</code>: New peripheral ID.   - <code>--base &lt;ADDR&gt;</code>: Base address.   - <code>--ir-path &lt;PATH&gt;</code>: Path to IR descriptor. - <code>validate</code>: Validate a System Manifest and its referenced Chip. - <code>list-chips</code>: List available chip descriptors.</p>"},{"location":"cli_reference/#machine","title":"<code>machine</code>","text":"<p>Machine state control operations.</p> <p>Subcommands: - <code>load</code>: Load a machine state from a snapshot and resume simulation.   - <code>-s, --snapshot &lt;JSON&gt;</code>: Path to snapshot file.   - <code>--max-steps &lt;N&gt;</code>: Override step limit.   - <code>--trace</code>: Enable tracing.</p>"},{"location":"cli_reference/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>RUST_LOG</code>: Controls logging level (e.g., <code>info</code>, <code>debug</code>).</li> <li>Native logging uses <code>tracing</code>.</li> <li>Example: <code>RUST_LOG=labwired_core=debug</code></li> </ul>"},{"location":"configuration_reference/","title":"Configuration Reference","text":"<p>LabWired uses a YAML-based configuration system to define the simulated hardware environment. This separation allows the same firmware binary to be tested against different hardware configurations (e.g., changing memory sizes or remapping peripherals) without recompilation.</p>"},{"location":"configuration_reference/#1-file-hierarchy","title":"1. File Hierarchy","text":"<p>A complete simulation requires two descriptor files:</p> <ol> <li>Chip Descriptor (<code>chips/&lt;name&gt;.yaml</code>): Defines the internal architecture of the SoC (Flash/RAM size, internal peripheral addresses).</li> <li>System Manifest (<code>systems/&lt;name&gt;.yaml</code>): Instantiates a chip and defines board-level wiring (external sensors, UART loopbacks).</li> </ol>"},{"location":"configuration_reference/#2-chip-descriptor-schema","title":"2. Chip Descriptor Schema","text":"<p>Defines the invariant properties of the silicon.</p> <pre><code>name: \"STM32F103\"\nflash:\n  base: 0x08000000\n  size: \"64KB\"  # Supports KB/MB suffixes\nram:\n  base: 0x20000000\n  size: \"20KB\"\n\nperipherals:\n  # Internal Peripheral Definition\n  - id: \"usart1\"\n    type: \"uart\"\n    base_address: 0x40013800\n    irq: 37\n    config:\n      profile: \"stm32f1\"  # Loads architecture-specific register map\n\n  - id: \"gpioa\"\n    type: \"gpio\"\n    base_address: 0x40010800\n    config:\n      profile: \"stm32f1\"\n\n  # Declarative Peripheral (Custom)\n  - id: \"my_custom_timer\"\n    type: \"declarative\"\n    base_address: 0x40004000\n    config:\n      path: \"../peripherals/custom_timer.yaml\"\n</code></pre>"},{"location":"configuration_reference/#supported-peripheral-types","title":"Supported Peripheral Types","text":"<ul> <li><code>uart</code>, <code>usart</code>: Universal Asynchronous Receiver Transmitter</li> <li><code>gpio</code>: General Purpose I/O</li> <li><code>rcc</code>: Reset and Clock Control</li> <li><code>timer</code>: Basic Timer</li> <li><code>i2c</code>: Inter-Integrated Circuit</li> <li><code>spi</code>: Serial Peripheral Interface</li> <li><code>exti</code>: External Interrupt Controller</li> <li><code>afio</code>: Alternate Function I/O</li> <li><code>dma</code>: Direct Memory Access Controller</li> <li><code>systick</code>: System Tick Timer</li> <li><code>declarative</code>: Loads a generic peripheral from a YAML register description.</li> </ul>"},{"location":"configuration_reference/#3-system-manifest-schema","title":"3. System Manifest Schema","text":"<p>Defines the board-level environment.</p> <pre><code>name: \"BluePill Board\"\nchip: \"../chips/stm32f103.yaml\"  # Path relative to this file\n\n# External Device Connections (Planned)\nconnectors:\n  - type: \"uart\"\n    peripheral: \"usart1\"\n    endpoint: \"host_console\"  # Pipes UART output to simulator stdout\n</code></pre>"},{"location":"configuration_reference/#4-cli-usage","title":"4. CLI Usage","text":"<p>To run a simulation, provide both the firmware and the system manifest:</p> <pre><code>labwired --firmware firmware.elf --system configs/systems/bluepill.yaml\n</code></pre> <p>The simulator loads the system manifest, resolves the chip descriptor, initializes the memory map, and begins execution at the Reset Vector.</p>"},{"location":"coverage_scoreboard/","title":"Coverage Scoreboard","text":"<p>Date: February 22, 2026 Scope: Priority-1 Top-5 matrix baseline for deterministic smoke.</p> <p>This document is the baseline scoreboard referenced by the Top-20 coverage plan. Values should be updated by CI artifacts from the matrix smoke workflow.</p>"},{"location":"coverage_scoreboard/#automated-scoreboard-artifact","title":"Automated Scoreboard Artifact","text":"<p>The matrix workflow now generates:</p> <ul> <li><code>coverage-matrix-scoreboard/scoreboard.md</code></li> <li><code>coverage-matrix-scoreboard/scoreboard.json</code></li> </ul> <p>These artifacts are published on every matrix run and summarized in GitHub Actions step summary.</p> <p>Current CI hard gate: - Top-5 executable deterministic targets must maintain &gt;=80% pass rate. - Gate is enforced in <code>core-coverage-matrix-smoke.yml</code> scoreboard job.</p> <p>Latest validated run: - Date: <code>2026-02-22</code> - Run: <code>https://github.com/w1ne/labwired-core/actions/runs/22281072679</code> - Summary: <code>6/6 pass</code>, <code>0 fail</code>, <code>0 missing</code> - Top-5 gate: <code>5/5 pass</code> (<code>100%</code>, threshold <code>&gt;=80%</code>)</p>"},{"location":"coverage_scoreboard/#current-snapshot","title":"Current Snapshot","text":"Metric Baseline Value Notes Top-5 targets defined <code>5</code> Defined in <code>docs/spec/TOP20_COVERAGE_MATRIX.md</code> Top-5 with runnable smoke script <code>5/5</code> <code>stm32f401-nucleo</code> smoke package added Top-5 with deterministic evidence artifacts in matrix CI <code>5/5</code> Published in <code>coverage-matrix-scoreboard</code> artifact Top-5 with unsupported-instruction audit artifacts <code>5/5</code> Published per-target under matrix artifacts Top-5 with explicit known-limitations entries <code>3/5</code> <code>stm32f103-bluepill</code>, <code>stm32h563-nucleo</code>, <code>stm32f401-nucleo</code>"},{"location":"coverage_scoreboard/#target-level-baseline","title":"Target-Level Baseline","text":"Target ID Smoke Script Build Path Baseline State Evidence Path (when available) <code>stm32f103-bluepill</code> <code>examples/demo-blinky/io-smoke.yaml</code> <code>cargo build -p demo-blinky --release --target thumbv7m-none-eabi</code> <code>passing</code> <code>out/coverage-matrix/coverage-matrix-stm32f103-bluepill/</code> <code>stm32h563-nucleo</code> <code>examples/nucleo-h563zi/uart-smoke.yaml</code> <code>cargo build -p firmware-h563-demo --release --target thumbv7m-none-eabi</code> <code>passing</code> <code>out/coverage-matrix/coverage-matrix-stm32h563-nucleo/</code> <code>stm32f401-nucleo</code> <code>examples/nucleo-f401re/uart-smoke.yaml</code> <code>cargo build -p firmware-f401-demo --release --target thumbv7em-none-eabi</code> <code>passing</code> <code>out/coverage-matrix/coverage-matrix-stm32f401-nucleo/</code> <code>riscv-ci-fixture</code> <code>examples/ci/riscv-uart-ok.yaml</code> <code>cargo build -p riscv-ci-fixture --release --target riscv32i-unknown-none-elf</code> <code>passing</code> <code>out/coverage-matrix/coverage-matrix-riscv-ci-fixture/</code> <code>demo-blinky-stm32f103</code> <code>examples/demo-blinky/io-smoke.yaml</code> <code>cargo build -p demo-blinky --release --target thumbv7m-none-eabi</code> <code>passing</code> <code>out/coverage-matrix/coverage-matrix-demo-blinky-stm32f103/</code> <p>Additional matrix sentinel target: - <code>ci-fixture-armv6m</code> (included in matrix run, excluded from Top-5 hard gate)</p>"},{"location":"coverage_scoreboard/#update-protocol","title":"Update Protocol","text":"<ol> <li>Matrix CI uploads per-target artifacts under <code>out/coverage-matrix/&lt;target-id&gt;/</code>.</li> <li>Matrix CI aggregates and publishes scoreboard artifacts via <code>scripts/generate_coverage_matrix_scoreboard.py</code>.</li> <li>Update this file when the Top-5 scope, thresholds, or status policy changes.</li> <li>Do not mark <code>green</code> without deterministic re-run evidence.</li> </ol>"},{"location":"debugging/","title":"Debugging (DAP)","text":"<p>LabWired implements a native Debug Adapter Protocol (DAP) server, enabling direct integration with IDEs like VS Code without intermediate GDB processes.</p>"},{"location":"debugging/#1-architecture","title":"1. Architecture","text":"<p>The DAP server operates as a sidecar process or an internal thread within the simulation runner.</p> <ul> <li>Protocol: JSON-RPC over Standard Input/Output (stdio) or TCP.</li> <li>Capabilities:<ul> <li><code>launch</code>: Starts a new simulation instance.</li> <li><code>attach</code>: Connects to a running simulation.</li> <li><code>setBreakpoints</code>: Supports source-level and instruction-level breakpoints.</li> <li><code>threads</code>: Exposes the CPU core as a single thread.</li> <li><code>stackTrace</code>: Unwinds the stack frame based on the current PC and SP.</li> <li><code>scopes</code> / <code>variables</code>: Inspects registers and local variables.</li> </ul> </li> </ul>"},{"location":"debugging/#2-vs-code-integration","title":"2. VS Code Integration","text":"<p>The <code>labwired-vscode</code> extension bundles the DAP client.</p>"},{"location":"debugging/#launch-configuration-launchjson","title":"Launch Configuration (<code>launch.json</code>)","text":"<p>To debug a firmware image, define a generic DAP launch configuration:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"labwired\",\n            \"request\": \"launch\",\n            \"name\": \"Debug Firmware\",\n            \"program\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"args\": [\"--system\", \"config/system.yaml\"],\n            \"stopOnEntry\": true,\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre>"},{"location":"debugging/#configuration-options","title":"Configuration Options","text":"<ul> <li>program: Path to the ELF binary with debug symbols (DWARF).</li> <li>args: Command-line arguments passed to the LabWired CLI.</li> <li>stopOnEntry: If <code>true</code>, the simulator halts at the Reset Vector.</li> <li>cwd: Current working directory for the simulation process.</li> </ul>"},{"location":"debugging/#3-telemetry-extensions","title":"3. Telemetry Extensions","text":"<p>The LabWired DAP implementation extends the protocol to support real-time telemetry.</p>"},{"location":"debugging/#custom-events","title":"Custom Events","text":"<p>The server emits a <code>telemetry</code> event every 100ms containing performance metrics.</p> <p>Payload Schema: <pre><code>{\n  \"type\": \"event\",\n  \"event\": \"telemetry\",\n  \"body\": {\n    \"cycles\": 120500,\n    \"mips\": 12.5,\n    \"pc\": \"0x080001a4\"\n  }\n}\n</code></pre></p> <p>This allows the VS Code extension to render a live \"Dashboard\" view without polling the debug interface, minimizing protocol overhead.</p>"},{"location":"debugging/#4-troubleshooting","title":"4. Troubleshooting","text":""},{"location":"debugging/#unknown-request-errors","title":"\"Unknown Request\" Errors","text":"<p>If the debug console shows protocol errors: 1.  Verify the <code>labwired-cli</code> version matches the extension version. 2.  Enable verbose logging in <code>launch.json</code>: <code>\"trace\": true</code>.</p>"},{"location":"debugging/#source-mapping-issues","title":"Source Mapping Issues","text":"<p>If breakpoints cannot be set: 1.  Ensure the ELF was compiled with <code>debug = true</code>. 2.  Verify the <code>program</code> path matches the binary being displayed in the editor.</p>"},{"location":"declarative_registers/","title":"Declarative Register Definitions","text":"<p>LabWired uses declarative YAML specifications to define the register interface of peripherals. This system decouples the hardware description from the implementation logic, ensuring consistent behavior across all simulated devices.</p>"},{"location":"declarative_registers/#1-specification-schema","title":"1. Specification Schema","text":"<p>The schema defines the register map, access permissions, and side-effects.</p> <pre><code>peripheral: \"SPI\"\nversion: \"1.0\"\nregisters:\n  - id: \"CR1\"\n    address_offset: 0x00\n    size: 16\n    access: \"R/W\"\n    reset_value: 0x0000\n    fields:\n      - name: \"SPE\"\n        bit_range: [6, 6]\n        description: \"SPI Enable\"\n        access: \"R/W\"\n\n  - id: \"DR\"\n    address_offset: 0x0C\n    size: 16\n    access: \"R/W\"\n    side_effects:\n      on_read: \"clear_rxne\"\n      on_write: \"start_tx\"\n</code></pre>"},{"location":"declarative_registers/#key-components","title":"Key Components","text":"<ul> <li>id: Unique identifier for the register.</li> <li>address_offset: Byte offset from the peripheral base address.</li> <li>access: Access permissions (<code>R</code>, <code>W</code>, <code>R/W</code>). Violations trigger a BusFault.</li> <li>side_effects: Hooks that invoke custom Rust logic when the register is accessed.</li> </ul>"},{"location":"declarative_registers/#2-implementation-architecture","title":"2. Implementation Architecture","text":"<p>The declarative system consists of three phases:</p> <ol> <li>Parsing: The <code>labwired-config</code> crate deserializes the YAML into a <code>PeripheralDescriptor</code> intermediate representation (IR).</li> <li>Runtime: The <code>GenericPeripheral</code> implementation in <code>labwired-core</code> uses this descriptor to serve <code>read()</code> and <code>write()</code> requests. It handles bounds checking, access permissions, and bit masking automatically.</li> <li>Hooks: The <code>GenericPeripheral</code> delegates to a <code>HookHandler</code> trait when a side-effect (e.g., <code>on_write: \"start_tx\"</code>) is triggered.</li> </ol>"},{"location":"declarative_registers/#3-workflow","title":"3. Workflow","text":"<ol> <li>Generation: Use <code>svd-to-yaml</code> to generate the initial descriptor from vendor SVD files.</li> <li>Refinement: Manually add <code>side_effects</code> to registers that require custom logic (e.g., triggering a state machine transition).</li> <li>Implementation: Implement the corresponding hook functions in Rust.</li> </ol>"},{"location":"demos/","title":"LabWired Demos &amp; Examples","text":"<p>Welcome to the LabWired Demo Portal. This directory helps you navigate the various ways to experience the platform, from high-fidelity hardware simulation to autonomous agentic workflows.</p>"},{"location":"demos/#1-agentic-interface-demos-the-wow-factor","title":"\ud83e\udd16 1. Agentic Interface Demos (The \"WOW\" Factor)","text":"<p>These demos showcase the Interface-First philosophy, where AI agents use LabWired as a high-fidelity sandbox to generate and verify hardware models.</p> Demo Description Path Autonomous Fix Watch an agent detect a bug in a peripheral model and fix it via simulation feedback. Available in Commercial Tier E2E Pipeline The full \"Datasheet -&gt; IR -&gt; Codegen -&gt; Simulation\" path in one script. Available in Commercial Tier"},{"location":"demos/#2-hardware-capability-demos","title":"\ud83d\udd0c 2. Hardware Capability Demos","text":"<p>High-fidelity machine models showcasing peripheral accuracy and hardware parity.</p> Demo Description Path NUCLEO-H563ZI Our flagship demo: Absolute parity between simulation and the real physical board. <code>core/examples/nucleo-h563zi/</code> Demo Blinky The classic \"Hello World\" of embedded systems, running on a modeled Cortex-M3. <code>core/examples/demo-blinky/</code> RISC-V Virt Showcasing multi-architecture support via the <code>riscv-virt</code> machine. <code>core/examples/riscv-virt/</code>"},{"location":"demos/#3-ci-automation-demos","title":"\ud83e\uddea 3. CI &amp; Automation Demos","text":"<p>Headless, deterministic execution for scaled regression testing.</p> Demo Description Path UART Smoke Test Simple deterministic test runner (<code>labwired test</code>) example. <code>core/examples/ci/uart-ok.yaml</code> Workflow Templates Ready-to-use GitHub Actions and GitLab CI files. <code>core/examples/workflows/</code>"},{"location":"demos/#how-to-run","title":"\ud83d\ude80 How to Run","text":"<p>Most demos can be run via the CLI. Ensure you have the core built first: <pre><code>cd core &amp;&amp; cargo build --release\n</code></pre></p> <p>Then, follow the README in each specific demo directory.</p>"},{"location":"gdb_integration/","title":"GDB Integration (RSP)","text":"<p>LabWired implements the GDB Remote Serial Protocol (RSP), allowing standard GDB clients (<code>arm-none-eabi-gdb</code>, <code>gdb-multiarch</code>) to connect for interactive debugging.</p>"},{"location":"gdb_integration/#1-server-configuration","title":"1. Server Configuration","text":"<p>The GDB server is embedded within the <code>labwired-cli</code>. It listens on TCP port <code>3333</code> by default.</p>"},{"location":"gdb_integration/#starting-the-server-manually","title":"Starting the Server manually","text":"<pre><code>labwired --gdb --port 3333 --firmware firmware.elf --system system.yaml\n</code></pre>"},{"location":"gdb_integration/#2-connecting-with-gdb","title":"2. Connecting with GDB","text":"<p>Launch your cross-architecture GDB client and connect to the remote target.</p> <pre><code>arm-none-eabi-gdb target/firmware.elf\n</code></pre> <p>Inside GDB: <pre><code>(gdb) target remote localhost:3333\n(gdb) load            # Optional: Reloads sections if modified\n(gdb) break main\n(gdb) continue\n</code></pre></p>"},{"location":"gdb_integration/#3-supported-commands","title":"3. Supported Commands","text":"<p>The RSP implementation supports the following subsets:</p> Command Description Notes <code>g</code> / <code>G</code> Read/Write All Registers Full context switch support <code>P</code> Write Single Register PC modification supported <code>m</code> / <code>M</code> Read/Write Memory Used for variable inspection <code>Z0</code> / <code>z0</code> Software Breakpoints Uses BKPT instruction injection <code>vCont</code> Continue / Step Supports single-stepping <code>qSupported</code> Feature Negotiation XML target description"},{"location":"gdb_integration/#4-ide-integration-cortex-debug","title":"4. IDE Integration (Cortex-Debug)","text":"<p>For VS Code users preferring the GDB workflow (e.g., for extensive peripheral viewing via SVD), configured <code>launch.json</code> as follows:</p> <pre><code>{\n    \"type\": \"cortex-debug\",\n    \"request\": \"launch\",\n    \"servertype\": \"external\",\n    \"gdbTarget\": \"localhost:3333\",\n    \"executable\": \"${workspaceFolder}/target/firmware.elf\",\n    \"runToEntryPoint\": \"main\",\n    \"svdFile\": \"${workspaceFolder}/STM32F103.svd\"\n}\n</code></pre> <p>Note: You must start the LabWired GDB server manually or via a pre-launch task before starting the debug session.</p>"},{"location":"getting_started_firmware/","title":"Running Firmware Images","text":"<p>LabWired executes standard ELF binaries compiled for ARM Cortex-M targets. The simulation environment requires two components: a valid firmware image and a declarative system configuration.</p>"},{"location":"getting_started_firmware/#1-compatible-firmware","title":"1. Compatible Firmware","text":"<p>LabWired loads ELF files generated by standard toolchains (Rust <code>rustc</code>, GCC <code>arm-none-eabi-gcc</code>).</p>"},{"location":"getting_started_firmware/#requirements","title":"Requirements","text":"<ul> <li>Format: ELF (Executable and Linkable Format).</li> <li>Architecture: ARMv7-M (Cortex-M3) or compatible.</li> <li>Memory Layout: Sections must be linked to valid addresses defined in the Chip Descriptor.</li> <li>Entry Point: The Vector Table must be placed at the Flash base address (typically <code>0x0800_0000</code>).</li> </ul>"},{"location":"getting_started_firmware/#compilation-example-rust","title":"Compilation Example (Rust)","text":"<p>Ensure the target is installed and build in release mode for performance:</p> <pre><code>rustup target add thumbv7m-none-eabi\ncargo build --release --target thumbv7m-none-eabi\n</code></pre>"},{"location":"getting_started_firmware/#2-system-definition","title":"2. System Definition","text":"<p>The simulation hardware is defined via two YAML configuration files: 1.  Chip Descriptor: Defines the internal memory map and peripheral base addresses. 2.  System Manifest: Defines the board-level configuration and instantiates the chip.</p>"},{"location":"getting_started_firmware/#chip-descriptor-chipyaml","title":"Chip Descriptor (<code>chip.yaml</code>)","text":"<p>Defines the MCU's physical memory layout.</p> <pre><code>name: \"STM32F103\"\nflash:\n  base: 0x08000000\n  size: \"64KB\"\nram:\n  base: 0x20000000\n  size: \"20KB\"\nperipherals:\n  - id: \"rcc\"\n    type: \"rcc\"\n    base_address: 0x40021000\n</code></pre>"},{"location":"getting_started_firmware/#system-manifest-systemyaml","title":"System Manifest (<code>system.yaml</code>)","text":"<p>Instantiates the chip and configures external connections.</p> <pre><code>name: \"bluepill-board\"\nchip: \"../chips/stm32f103.yaml\"\n</code></pre>"},{"location":"getting_started_firmware/#3-simulation-execution","title":"3. Simulation Execution","text":"<p>Invoke the <code>labwired-cli</code> with the firmware path and system configuration:</p> <pre><code>labwired --firmware firmware.elf --system system.yaml\n</code></pre>"},{"location":"getting_started_firmware/#loading-process","title":"Loading Process","text":"<ol> <li>Segment Loading: The loader creates a virtual memory space based on the Chip Descriptor. <code>PT_LOAD</code> segments from the ELF are copied to their respective addresses (Flash/RAM).</li> <li>Vector Table Initialization: The initial Stack Pointer (SP) is loaded from <code>FlashBase + 0x00</code>. The Reset Vector (PC) is loaded from <code>FlashBase + 0x04</code>.</li> <li>Execution Loop: The CPU begins fetching and executing instructions from the Reset Vector.</li> </ol>"},{"location":"getting_started_firmware/#4-common-runtime-issues","title":"4. Common Runtime Issues","text":""},{"location":"getting_started_firmware/#invalid-memory-access-busfault","title":"Invalid Memory Access (BusFault)","text":"<p>Symptom: Simulation terminates with <code>MemoryAccessViolation</code>. Cause: The firmware attempted to read/write an address not mapped in <code>chip.yaml</code>. Resolution: Verify linker script memory regions match the Chip Descriptor.</p>"},{"location":"getting_started_firmware/#vector-table-mismatch","title":"Vector Table Mismatch","text":"<p>Symptom: HardFault immediately upon start. Cause: The Vector Table is not located at the Flash Base Address. Resolution: inspected the ELF headers (<code>objdump -h</code>) to confirm <code>.vector_table</code> placement.</p>"},{"location":"getting_started_firmware/#peripheral-stalls","title":"Peripheral Stalls","text":"<p>Symptom: Firmware hangs in a polling loop (e.g., waiting for <code>RCC_CR_HSIRDY</code>). Cause: The peripheral model does not fully implement the status flag logic required by the HAL. Resolution: Run with <code>--trace</code> to identify the spinning loop. Use a <code>StubPeripheral</code> to mock the expected status bit if a full model is unavailable.</p>"},{"location":"peripheral_development/","title":"Peripheral Development Guide","text":"<p>This document outlines the architectural patterns and best practices for implementing custom peripherals in LabWired.</p>"},{"location":"peripheral_development/#1-peripheral-interface-contract","title":"1. Peripheral Interface Contract","text":"<p>All peripherals must implement the <code>Peripheral</code> trait from <code>labwired-core</code>. This interface abstracts the hardware behavior into three primary operations.</p> <pre><code>pub trait Peripheral: std::fmt::Debug + Send {\n    /// Handler for CPU read operations.\n    /// Offset: Memory address relative to the peripheral base.\n    /// Returns: 8-bit value or SimResult::Err on BusFault.\n    fn read(&amp;self, offset: u64) -&gt; SimResult&lt;u8&gt;;\n\n    /// Handler for CPU write operations.\n    /// Offset: Memory address relative to the peripheral base.\n    /// Value: 8-bit data to write.\n    fn write(&amp;mut self, offset: u64, value: u8) -&gt; SimResult&lt;()&gt;;\n\n    /// State update function called once per simulation step.\n    /// Used for time-based logic (timers, UART baud rate) and interrupt generation.\n    fn tick(&amp;mut self) -&gt; PeripheralTickResult;\n}\n</code></pre>"},{"location":"peripheral_development/#2-register-access-patterns","title":"2. Register Access Patterns","text":""},{"location":"peripheral_development/#byte-level-granularity","title":"Byte-Level Granularity","text":"<p>The <code>SystemBus</code> performs all transactions at byte granularity. 32-bit CPU instructions (like <code>STR</code>) are decomposed into four consecutive 8-bit writes. Peripherals must handle this reconstruction if they model 32-bit registers.</p> <p>Implementation Pattern: <pre><code>fn read(&amp;self, offset: u64) -&gt; SimResult&lt;u8&gt; {\n    // 1. Align offset to 4-byte boundary to identify the register\n    let reg_val = match offset &amp; !3 {\n        0x00 =&gt; self.control_reg,\n        0x04 =&gt; self.status_reg,\n        _ =&gt; return Ok(0), // Define unmapped behavior (RAZ/WI)\n    };\n\n    // 2. Extract the specific byte requested\n    let shift = (offset % 4) * 8;\n    Ok((reg_val &gt;&gt; shift) as u8)\n}\n</code></pre></p>"},{"location":"peripheral_development/#side-effects","title":"Side Effects","text":"<p>Operations that clear flags or trigger hardware actions (e.g., \"Write 1 to Clear\") should be implemented in the <code>write</code> handler.</p> <pre><code>fn write(&amp;mut self, offset: u64, value: u8) -&gt; SimResult&lt;()&gt; {\n    if offset == 0x00 { // status_reg\n        // Clear flags if bit is set in value (W1C behavior)\n        self.status_reg &amp;= !(value as u32);\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"peripheral_development/#3-time-based-logic-tick","title":"3. Time-Based Logic (<code>tick</code>)","text":"<p>The <code>tick()</code> method provides the simulation time base. It is invoked synchronously at the end of every CPU instruction cycle.</p>"},{"location":"peripheral_development/#implementation-guidelines","title":"Implementation Guidelines","text":"<ul> <li>Deterministic Execution: Avoid <code>std::thread::sleep</code> or system time. Behavior must rely solely on the tick count to ensuring deterministic replayability.</li> <li>Performance: This method is on the hot path. Minimal logic should execute on every tick. Use state counters to decimate high-frequency logic.</li> </ul> <p>Example: 1MHz Timer at 100MHz CPU Clock <pre><code>fn tick(&amp;mut self) -&gt; PeripheralTickResult {\n    self.cycles += 1;\n    if self.cycles &gt;= 100 { // 100 CPU cycles per timer tick\n        self.cycles = 0;\n        self.counter += 1;\n        // Trigger IRQ logic...\n    }\n    PeripheralTickResult::default()\n}\n</code></pre></p>"},{"location":"peripheral_development/#4-svd-ingestion-tool","title":"4. SVD Ingestion Tool","text":"<p>For standard peripherals, manual implementation of the register map is redundant. LabWired provides an SVD parsing tool to generate the boilerplate <code>PeripheralDescriptor</code> YAML.</p> <p>Usage: <pre><code>cargo run -p svd-ingestor -- --input STM32F4.svd --filter UART1 --output-dir crates/config/peripherals\n</code></pre></p> <p>This generates a YAML file compatible with the <code>GenericPeripheral</code> implementation, requiring only the hook logic to be written in Rust.</p>"},{"location":"reference_client_flows/","title":"LabWired Reference Client Flows","text":"<p>The Simulation Protocol provides a deterministic contract for simulation. The true power of LabWired, however, is unlocked when this protocol is integrated into your existing development tools. </p> <p>This document outlines the standard, supported \"Client Flows\" for integrating LabWired into CI pipelines, Interactive IDE Debugging, and AI Agent workflows.</p>"},{"location":"reference_client_flows/#1-headless-ci-integration-github-actions","title":"1. Headless CI Integration (GitHub Actions)","text":"<p>The primary use-case for the Simulation Protocol is deterministic, headless regression testing in Continuous Integration (CI) pipelines.</p>"},{"location":"reference_client_flows/#the-ci-flow","title":"The CI Flow","text":"<ol> <li>Trigger: A developer pushes code or opens a Pull Request.</li> <li>Setup: The CI runner checks out the code, builds the firmware (e.g., <code>cargo build</code> or <code>make</code>), and downloads the <code>labwired-cli</code>.</li> <li>Execution: The runner invokes <code>labwired test</code> parsing a predefined <code>test_script.yaml</code>.</li> <li>Assertion: LabWired executes the simulation deterministically and asserts against the defined limits (cycles, UART output).</li> <li>Reporting: LabWired exits with standard POSIX codes and emits strict artifact files (<code>result.json</code>, <code>junit.xml</code>, <code>trace.vcd</code>). </li> <li>Integration: CI systems natively ingest <code>junit.xml</code> to display inline success/failure on the Pull Request.</li> </ol>"},{"location":"reference_client_flows/#reference-configuration-githubworkflowssimyml","title":"Reference Configuration (<code>.github/workflows/sim.yml</code>)","text":"<pre><code>name: Firmware Simulation\non: [push, pull_request]\n\njobs:\n  simulate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      # Step 1: Build the firmware\n      - name: Build Firmware\n        run: cargo build --release --target thumbv7em-none-eabihf\n\n      # Step 2: Install LabWired\n      - name: Install LabWired CLI\n        uses: labwired/setup-action@v1\n        with:\n          version: 'latest'\n\n      # Step 3: Run the deterministic protocol headless\n      - name: Run Simulation\n        run: labwired test --script tests/hardware_validation.yaml\n\n      # Step 4: Archive deterministic artifacts (VCD traces) on failure\n      - name: Upload Traces\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: failure-traces\n          path: trace.vcd\n</code></pre>"},{"location":"reference_client_flows/#2-interactive-ide-debugging-vs-code","title":"2. Interactive IDE Debugging (VS Code)","text":"<p>While the protocol excels at headless execution, developers need interactive introspection. LabWired translates the deterministic protocol into standard GDB-RSP (Remote Serial Protocol) to \"trick\" standard debuggers into talking to the simulator as if it were a physical J-Link adapter.</p>"},{"location":"reference_client_flows/#the-interactive-flow","title":"The Interactive Flow","text":"<ol> <li>Start Server: The developer runs <code>labwired gdbserver --firmware app.elf --system system.yaml</code>. LabWired initializes the simulation state and pauses, opening a TCP port (e.g., <code>3333</code>).</li> <li>Attach Interface: The IDE's debugger adapter (e.g., <code>cortex-debug</code> in VS Code) connects to TCP port <code>3333</code>.</li> <li>Debug: The developer sets breakpoints, steps through code, and inspects variables. LabWired translates GDB's <code>vCont</code> (step) commands into precise Instruction-Level advances in the simulator core.</li> </ol>"},{"location":"reference_client_flows/#reference-configuration-vscodelaunchjson","title":"Reference Configuration (<code>.vscode/launch.json</code>)","text":"<p>To use LabWired with the popular <code>cortex-debug</code> extension in VS Code:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"LabWired: Debug STM32\",\n      \"type\": \"cortex-debug\",\n      \"request\": \"launch\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"executable\": \"${workspaceRoot}/target/thumbv7em-none-eabihf/release/app\",\n      \"servertype\": \"external\",\n      \"gdbTarget\": \"localhost:3333\",\n      \"gdbPath\": \"arm-none-eabi-gdb\",\n      \"preLaunchTask\": \"Start LabWired GDBSERVER\",\n      \"svdFile\": \"${workspaceRoot}/chips/stm32f401.svd\",\n      \"runToEntryPoint\": \"main\",\n    }\n  ]\n}\n</code></pre>"},{"location":"reference_client_flows/#3-agent-integration-aipi-toolset","title":"3. Agent Integration (AIPi Toolset)","text":"<p>LabWired acts as a deterministic hardware oracle for AI agents. Rather than a purely conceptual framework, LabWired is building a dedicated toolset that external orchestrators can use to safely generate, verify, and emulate hardware peripherals against vendor datasheets.</p>"},{"location":"reference_client_flows/#the-agentic-iterative-loop-protocol","title":"The Agentic \"Iterative Loop\" Protocol","text":"<p>Agents interact with the simulator via an iterative reinforcement loop: 1.  Hypothesize: The agent extracts an initial model structure from unstructured data (e.g., a PDF datasheet). 2.  Simulate: The agent loads the model into the LabWired sandbox. 3.  Verify: The agent applies stimulus (register writes) and checks responses (reads/interrupts). 4.  Audit: The simulation behavior is compared against formal <code>HardwareRules</code>. 5.  Fix: If a deviation occurs, the agent updates the model and repeats the loop.</p>"},{"location":"reference_client_flows/#web-based-agent-apis-coming-soon","title":"Web-Based Agent APIs (Coming Soon)","text":"<p>To ensure the highest fidelity and control, the complete AIPi toolkit and Agentic execution APIs will be provided exclusively through the LabWired Web Platform in a future update. </p> <p>Users will be able to connect their LLM pipelines or RL fuzzers directly to our managed cloud infrastructure, executing the \"Iterative Loop\" without needing to manage local Python SDKs or compile Rust toolchains.</p> <p>(Note: Enterprise MAESTRO fuzzing integration examples will also be made available to commercial tier subscribers via the web portal).</p>"},{"location":"release_strategy/","title":"LabWired Release &amp; Merging Strategy","text":""},{"location":"release_strategy/#1-branching-model-trunk-based-development","title":"1. Branching Model: Trunk-Based Development","text":"<p>We use trunk-based development on the <code>main</code> branch with short-lived feature branches. - <code>main</code>: The primary development branch. All work happens here via feature branches and PRs. Tags are created here for releases. - <code>feature/*</code>: Short-lived branches for individual work items. Created from <code>main</code>, merged back to <code>main</code> via PR.     - Naming convention: <code>feature/short-description</code> or <code>feature/issue-id-description</code>. - <code>hotfix/*</code>: Critical bug fixes. Created from <code>main</code>, merged back to <code>main</code> via PR.</p>"},{"location":"release_strategy/#merging-rules","title":"Merging Rules","text":"<ul> <li>Pull Requests (PRs) are mandatory for all merges.</li> <li>Approvals: At least 1 review approval is required.</li> <li>CI Checks: All checks (Build, Test, Lint, Audit) must pass.</li> <li>History: Use \"Squash and Merge\" for feature branches to keep history clean. Use \"Merge Commit\" for releases to preserve the valid history.</li> </ul>"},{"location":"release_strategy/#2-quality-gates","title":"2. Quality Gates","text":"<p>Every PR and commit to <code>main</code> must pass the following automated gates. Developers MUST run these locally before opening a PR.</p>"},{"location":"release_strategy/#automated-checks-ci","title":"Automated Checks (CI)","text":"Check Command Failure Condition Formatting <code>cargo fmt -- --check</code> Any formatting violation. Linting <code>cargo clippy -- -D warnings</code> Any warnings or errors. Tests <code>cargo test</code> Any test failure. Security <code>cargo audit</code> Known vulnerabilities in dependencies. Build <code>cargo build</code> Compilation error."},{"location":"release_strategy/#test-coverage","title":"Test Coverage","text":"<ul> <li>Goal: &gt;80% Code Coverage.</li> <li>Tool: <code>cargo-tarpaulin</code>.</li> <li>Enforcement: CI will generate a coverage report. Significant drops in coverage should block the PR.</li> </ul>"},{"location":"release_strategy/#32-release-notes-format-verbatim","title":"3.2. Release Notes Format (Verbatim)","text":"<p>When preparing a release, the following verbatim format MUST be used for the GitHub Release notes:</p> <p>Title: <code>Release vX.Y.Z: &lt;Short Summary of Key Changes&gt;</code></p> <p>Body Structure: <pre><code>Features:\n- &lt;Feature 1 description&gt;\n- &lt;Feature 2 description&gt;\n\nImprovements:\n- &lt;Improvement 1 description&gt;\n- &lt;Improvement 2 description&gt;\n\nFixes: (Optional)\n- &lt;Fix 1 description&gt;\n</code></pre></p> <p>Example:</p> <p>Release v0.9.0: Variable PD Types and Integration Testing</p> <p>Features: - Variable PD types (1_V and 2_V) with dynamic length changes (2-32 bytes) - Integration testing infrastructure (test_device_connection.py, test_integration.sh)</p> <p>Improvements: - Enhanced Virtual Master with set_pd_length() method - Comprehensive test suites for all M-sequence types</p>"},{"location":"release_strategy/#33-steps-to-release","title":"3.3. Steps to Release","text":"<ol> <li>Prepare: Create a release preparation branch from <code>main</code> (optional, can also work directly on <code>main</code>).</li> <li>Bump: Update version numbers in <code>Cargo.toml</code> (workspace and crates).</li> <li>Changelog: Update <code>CHANGELOG.md</code> with features and fixes.</li> <li>Verify: Run the full regression suite, lints, and formatting check locally:<ul> <li>Host: <code>cargo test --workspace --exclude firmware</code></li> <li>Firmware: <code>cargo build -p firmware --target thumbv7m-none-eabi</code></li> <li>Lints: <code>cargo clippy --workspace --exclude firmware -- -D warnings</code></li> <li>Format: <code>cargo fmt --all -- --check</code></li> </ul> </li> <li>Draft Release: Create a GitHub Release draft using the Verbatim format above.</li> <li>Merge &amp; Tag:<ul> <li>Merge changes to <code>main</code> via PR.</li> <li>Tag <code>main</code> with <code>vX.Y.Z</code>.</li> </ul> </li> <li>Publish:<ul> <li>Push the <code>vX.Y.Z</code> tag to trigger release workflows.</li> <li>Ensure CI validation workflows are green (<code>.github/workflows/core-ci.yml</code> and <code>.github/workflows/vscode-ci.yml</code>).</li> <li>Publish release artifacts (CLI binaries, docs, and extension package) using the current manual publishing process.</li> <li>If/when a dedicated release workflow is added, document it here and make it part of the required gates.</li> </ul> </li> </ol>"},{"location":"release_strategy/#4-coding-standards-documentation","title":"4. Coding Standards documentation","text":"<ul> <li>Style: Follow standard Rust style (<code>rustfmt</code>).</li> <li>Docs: Public APIs must be documented (<code>/// doc comments</code>).</li> <li>Errors: Use <code>thiserror</code> for library errors and <code>anyhow</code> for application/CLI errors.</li> <li>Commits: Follow Conventional Commits (e.g., <code>feat: allow loading hex files</code>, <code>fix: resolve crash on empty input</code>).</li> </ul>"},{"location":"safety/","title":"LabWired Simulation Safety Guidelines","text":"<p>This document provides guidance on configuring simulation limits to prevent memory exhaustion and system crashes.</p>"},{"location":"safety/#overview","title":"Overview","text":"<p>LabWired provides multiple safety mechanisms to prevent runaway simulations from consuming excessive resources:</p> Limit Purpose Recommended Value Maximum Safe Value <code>max_steps</code> Prevents infinite loops 1,000,000 100,000,000 <code>max_cycles</code> Limits CPU cycle count 10,000,000 1,000,000,000 <code>max_uart_bytes</code> Prevents excessive UART output 1 MB (1,048,576) 100 MB <code>wall_time_ms</code> Limits real-time execution 10,000 (10s) 300,000 (5min) <code>no_progress_steps</code> Detects stuck execution 1,000 100,000 <code>max_vcd_bytes</code> Limits VCD trace file size 100 MB 1 GB"},{"location":"safety/#safety-mechanisms","title":"Safety Mechanisms","text":""},{"location":"safety/#1-execution-limits","title":"1. Execution Limits","text":"<p>max_steps (required) - Limits the total number of simulation steps - Always set this - it's your primary safety net - For quick tests: 10,000 - 100,000 steps - For standard tests: 1,000,000 steps - For stress tests: 10,000,000 - 100,000,000 steps</p> <p>max_cycles (optional) - Limits total CPU cycles (includes peripheral wait states) - Use when you need precise cycle-count budgeting - Typically 10x higher than max_steps for simple code</p> <p>wall_time_ms (optional) - Hard real-time limit regardless of simulation progress - Useful for CI/CD pipelines with strict time budgets - Prevents hanging on pathological cases</p>"},{"location":"safety/#2-output-limits","title":"2. Output Limits","text":"<p>max_uart_bytes (optional) - Prevents memory exhaustion from excessive UART output - Set to 1-10 MB for most tests - Firmware with verbose logging may need higher limits</p> <p>max_vcd_bytes (optional, interactive mode only) - Limits VCD trace file size - VCD files grow ~100-500 bytes per instruction - For 1M instructions: expect 100-500 MB VCD file - Recommended: 100 MB for debugging, 1 GB for detailed analysis</p>"},{"location":"safety/#3-hang-detection","title":"3. Hang Detection","text":"<p>no_progress_steps (optional) - Detects when PC doesn't change (infinite loop at same address) - Recommended: 1,000 steps for quick detection - Set higher (10,000+) if firmware intentionally spins</p>"},{"location":"safety/#configuration-examples","title":"Configuration Examples","text":""},{"location":"safety/#quick-validation-run-1-second","title":"Quick Validation Run (&lt; 1 second)","text":"<pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"firmware.elf\"\nlimits:\n  max_steps: 10000\n  wall_time_ms: 1000\n  no_progress_steps: 100\n</code></pre>"},{"location":"safety/#standard-test-run-10-seconds","title":"Standard Test Run (&lt; 10 seconds)","text":"<pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"firmware.elf\"\nlimits:\n  max_steps: 1000000\n  max_cycles: 10000000\n  max_uart_bytes: 1048576  # 1 MB\n  wall_time_ms: 10000\n  no_progress_steps: 1000\n</code></pre>"},{"location":"safety/#long-running-stress-test","title":"Long-Running Stress Test","text":"<pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"firmware.elf\"\nlimits:\n  max_steps: 100000000\n  max_cycles: 1000000000\n  max_uart_bytes: 104857600  # 100 MB\n  wall_time_ms: 300000  # 5 minutes\n  no_progress_steps: 10000\n</code></pre>"},{"location":"safety/#interactive-debugging-with-vcd","title":"Interactive Debugging with VCD","text":"<pre><code>labwired --firmware firmware.elf \\\\\n  --vcd trace.vcd \\\\\n  --max-steps 1000000\n</code></pre> <p>[!WARNING] VCD files can grow very large. A 1M step simulation can produce a 100-500 MB VCD file. Use <code>max_vcd_bytes</code> or limit <code>max_steps</code> when generating VCD traces.</p>"},{"location":"safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"safety/#simulation-runs-out-of-memory","title":"Simulation Runs Out of Memory","text":"<p>Symptoms: System becomes unresponsive, OOM killer terminates process</p> <p>Solutions: 1. Reduce <code>max_steps</code> to limit simulation length 2. Add <code>max_uart_bytes</code> to prevent UART buffer growth 3. Disable VCD output or add <code>max_vcd_bytes</code> limit 4. Add <code>wall_time_ms</code> as a hard timeout</p>"},{"location":"safety/#simulation-hangs-indefinitely","title":"Simulation Hangs Indefinitely","text":"<p>Symptoms: Simulation runs but never completes</p> <p>Solutions: 1. Add <code>wall_time_ms</code> for hard timeout 2. Add <code>no_progress_steps</code> to detect infinite loops 3. Reduce <code>max_steps</code> if firmware is expected to complete quickly</p>"},{"location":"safety/#vcd-file-too-large","title":"VCD File Too Large","text":"<p>Symptoms: Disk fills up, VCD viewer crashes</p> <p>Solutions: 1. Reduce <code>max_steps</code> to limit trace length 2. Add <code>max_vcd_bytes</code> limit (e.g., 100 MB) 3. Only enable VCD for specific debugging sessions 4. Use breakpoints to stop before generating excessive trace data</p>"},{"location":"safety/#best-practices","title":"Best Practices","text":"<ol> <li>Always set max_steps: This is your primary safety mechanism</li> <li>Use wall_time_ms in CI: Prevents hung builds in automated pipelines</li> <li>Start conservative: Begin with low limits and increase as needed</li> <li>Monitor resource usage: Check memory and disk usage during long runs</li> <li>Combine multiple limits: Use both step-based and time-based limits for defense in depth</li> <li>Test limits locally: Verify limits work before deploying to CI/CD</li> </ol>"},{"location":"safety/#pathological-cases","title":"Pathological Cases","text":""},{"location":"safety/#infinite-loop","title":"Infinite Loop","text":"<pre><code>while(1) {\n    // Stuck here forever\n}\n</code></pre> <p>Protection: <code>no_progress_steps</code> detects PC not changing</p>"},{"location":"safety/#verbose-logging","title":"Verbose Logging","text":"<pre><code>while(1) {\n    printf(\"Debug: iteration %d\\\\n\", i++);\n}\n</code></pre> <p>Protection: <code>max_uart_bytes</code> prevents memory exhaustion</p>"},{"location":"safety/#long-running-computation","title":"Long-Running Computation","text":"<pre><code>for(int i = 0; i &lt; 1000000000; i++) {\n    compute();\n}\n</code></pre> <p>Protection: <code>max_steps</code> or <code>max_cycles</code> limits execution</p>"},{"location":"safety/#vcd-trace-explosion","title":"VCD Trace Explosion","text":"<pre><code>labwired --firmware long_running.elf --vcd trace.vcd --max-steps 100000000\n</code></pre> <p>Protection: <code>max_vcd_bytes</code> limits file size (or reduce <code>max_steps</code>)</p>"},{"location":"safety/#agent-usage","title":"Agent Usage","text":"<p>When running simulations programmatically, always set appropriate limits:</p> <pre><code>import subprocess\nimport json\n\ndef run_safe_simulation(firmware_path, max_steps=1_000_000):\n    \"\"\"Run simulation with safe default limits\"\"\"\n    script = {\n        \"schema_version\": \"1.0\",\n        \"inputs\": {\n            \"firmware\": firmware_path\n        },\n        \"limits\": {\n            \"max_steps\": max_steps,\n            \"max_cycles\": max_steps * 10,\n            \"max_uart_bytes\": 1_048_576,  # 1 MB\n            \"wall_time_ms\": 30_000,  # 30 seconds\n            \"no_progress_steps\": 1_000\n        }\n    }\n\n    # Write script and run\n    with open(\"test.yaml\", \"w\") as f:\n        yaml.dump(script, f)\n\n    result = subprocess.run(\n        [\"labwired\", \"test\", \"--script\", \"test.yaml\"],\n        capture_output=True,\n        timeout=60  # Additional OS-level timeout\n    )\n\n    return json.loads(result.stdout)\n</code></pre>"},{"location":"safety/#summary","title":"Summary","text":"<ul> <li>Always use max_steps - your primary safety net</li> <li>Add wall_time_ms for CI/CD - prevents hung builds</li> <li>Limit UART output - prevents memory exhaustion from logging</li> <li>Be careful with VCD - files can grow very large</li> <li>Combine multiple limits - defense in depth</li> <li>Test limits locally first - before deploying to production</li> </ul>"},{"location":"schema_compatibility/","title":"YAML Schema Compatibility Policy","text":""},{"location":"schema_compatibility/#version-10-current","title":"Version 1.0 (Current)","text":"<p>The following schemas are frozen as v1.0: - <code>chip.yaml</code> (ChipDescriptor) - <code>system.yaml</code> (SystemManifest) - <code>peripheral.yaml</code> (PeripheralDescriptor)</p>"},{"location":"schema_compatibility/#stability-guarantees","title":"Stability Guarantees","text":"<ol> <li>Backwards Compatibility: All v1.0 schemas will be supported indefinitely</li> <li>Additive Changes Only: New optional fields may be added to v1.0 schemas</li> <li>No Breaking Changes: Required fields and their semantics will not change</li> <li>Deprecation Policy: Deprecated fields will be supported for at least 2 major versions</li> </ol>"},{"location":"schema_compatibility/#schema-evolution","title":"Schema Evolution","text":"<p>When breaking changes are required: 1. Increment schema version (e.g., <code>schema_version: \"2.0\"</code>) 2. Support both versions for at least 6 months 3. Provide migration tooling (<code>labwired asset migrate</code>) 4. Document migration path in release notes</p>"},{"location":"schema_compatibility/#schema-version-field","title":"Schema Version Field","text":"<p>All YAML configuration files support an optional <code>schema_version</code> field:</p> <pre><code>schema_version: \"1.0\"\nname: \"my-chip\"\n# ... rest of config\n</code></pre> <p>If omitted, the schema version defaults to <code>\"1.0\"</code> for backwards compatibility.</p>"},{"location":"schema_compatibility/#version-history","title":"Version History","text":""},{"location":"schema_compatibility/#v10-2026-02-14","title":"v1.0 (2026-02-14)","text":"<ul> <li>Initial frozen schema version</li> <li>Includes: ChipDescriptor, SystemManifest, PeripheralDescriptor</li> <li>Default version for all existing configs without explicit <code>schema_version</code> field</li> </ul>"},{"location":"simulation_protocol/","title":"LabWired Simulation Protocol","text":""},{"location":"simulation_protocol/#overview","title":"Overview","text":"<p>The LabWired Simulation Protocol defines the stable, versioned contract between the core simulation engine and external integrations (CI pipelines, agentic workflows, custom tooling). Unlike interactive debugger protocols like DAP or GDB RSP, which target live human inspection, the Simulation Protocol focuses on determinism, machine-readable inputs/outputs, and reproducible verification.</p> <p>This specification documents the v1.0 schema for inputs, expected event lifecycles, and output artifacts.</p>"},{"location":"simulation_protocol/#1-simulation-lifecycle","title":"1. Simulation Lifecycle","text":"<p>The lifecycle of a headless simulation run is strictly defined as follows:</p> <ol> <li>Configuration: The runner parses the test script, system manifest, and hardware models.</li> <li>Reset: The CPU and all peripherals are initialized. The firmware image is loaded into memory.</li> <li>Execution Loop:<ul> <li>The CPU fetches and executes an instruction.</li> <li>The system bus ticks all peripherals, incrementing cycle counts.</li> <li>Limits and assertions are evaluated.</li> </ul> </li> <li>Halt Condition: The simulation stops when one of the terminal conditions (limits, assertions, or exceptions) evaluates to true.</li> <li>Artifact Emission: The runner flushes final VCD traces, emits <code>result.json</code> and JUnit XML, and exits with a standardized code.</li> </ol>"},{"location":"simulation_protocol/#2-input-manifests-v10","title":"2. Input Manifests (v1.0)","text":"<p>LabWired relies on declarative configuration files to define the \"digital twin\" of your hardware.</p>"},{"location":"simulation_protocol/#21-test-script-test_scriptyaml","title":"2.1 Test Script (<code>test_script.yaml</code>)","text":"<p>The test script dictates the bounds and expectations of the simulation.</p> <pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"path/to/firmware.elf\"\n  system: \"path/to/system.yaml\"      # Optional: default board is used if omitted\nlimits:\n  max_steps: 100000000               # Required: Hard limit on CPU instructions\n  max_cycles: 150000000              # Optional: Limit on core clock cycles\n  wall_time_ms: 10000                # Optional: Timeout in real-world wall clock milliseconds\n  max_uart_bytes: 512000             # Optional: Limit on total UART characters emitted\n  no_progress_steps: 50000           # Optional: Halt if PC remains unchanged\n  max_energy_joules: 5.0             # Future (v1.1): Halt if estimated energy exceeds budget\nassertions:\n  - expected_stop_reason: halt       # Halt instruction (e.g., BKPT, WFI loop)\n  - uart_contains: \"TEST PASSED\"     # Substring match on the UART output stream\n</code></pre>"},{"location":"simulation_protocol/#22-system-manifest-systemyaml","title":"2.2 System Manifest (<code>system.yaml</code>)","text":"<p>Defines the board topology, Memory Management overrides, and IO mappings.</p> <pre><code>schema_version: \"1.0\"\nname: \"nucleo-f401re\"\nchip: \"stm32f401.yaml\"\nmemory_overrides:\n  flash: \"512KB\"\nboard_io:\n  - id: \"USER_LED\"\n    kind: \"led\"\n    peripheral: \"GPIOA\"\n    pin: 5\n    active_high: true\n</code></pre>"},{"location":"simulation_protocol/#23-environment-manifest-environmentyaml-future-v11","title":"2.3 Environment Manifest (<code>environment.yaml</code> - Future v1.1)","text":"<p>To support Distributed Time-Travel Debugging (via Chandy-Lamport algorithms), the protocol introduces an environment manifest grouping multiple systems into a cluster.</p> <pre><code>schema_version: \"1.1-draft\"\nname: \"mesh-network-test\"\nnodes:\n  - id: \"gateway\"\n    system: \"gateway.yaml\"\n  - id: \"sensor-01\"\n    system: \"sensor.yaml\"\ninterconnects:\n  - type: \"virtual_switch\"\n    nodes: [\"gateway\", \"sensor-01\"]\n</code></pre>"},{"location":"simulation_protocol/#24-hardware-descriptors-chipyaml-peripheralyaml","title":"2.4 Hardware Descriptors (<code>chip.yaml</code> &amp; <code>peripheral.yaml</code>)","text":"<p>For peripheral definitions, refer to the schema compatibility guide. LabWired supports strict IR definitions encompassing registers, fields, reset values, and side-effects (<code>WriteOneToClear</code>).</p>"},{"location":"simulation_protocol/#3-event-taxonomy","title":"3. Event Taxonomy","text":"<p>While the simulation executes deterministically, it emits a standardized stream of events that can be asserted against or captured in output traces.</p>"},{"location":"simulation_protocol/#31-uart-events","title":"3.1 UART Events","text":"<ul> <li>Emission: Occurs when a simulated CPU writes to a memory-mapped UART Transmission Data Register (TDR).</li> <li>Semantics: Aggregated into a continuous stream per UART instance. Standard assertions (<code>uart_contains</code>, <code>uart_regex</code>) operate on this stream.</li> </ul>"},{"location":"simulation_protocol/#32-gpio-events","title":"3.2 GPIO Events","text":"<ul> <li>Emission: Occurs when a GPIO output data register or bit set/reset register is modified.</li> <li>Semantics: Captured as discrete rising/falling edges in the VCD trace. In future v1.1, GPIO events will support routing to external FMUs (Functional Mock-up Units) for Hardware-in-the-Loop simulation via FMI 3.0.</li> </ul>"},{"location":"simulation_protocol/#33-interrupt-requests-irq","title":"3.3 Interrupt Requests (IRQ)","text":"<ul> <li>Emission: Occurs when a peripheral asserts an interrupt line to the NVIC (Nested Vectored Interrupt Controller) or equivalent core interrupt controller.</li> <li>Semantics: Traces capture both the assertion of the IRQ line by the peripheral and the subsequent entry into the Exception Handler by the CPU.</li> </ul>"},{"location":"simulation_protocol/#34-faults-and-exceptions","title":"3.4 Faults and Exceptions","text":"<ul> <li>Emission: Generated synchronously by the CPU when an illegal operation is attempted (e.g., HardFault, MemManage, UsageFault).</li> <li>Semantics: Faults transition execution to a fault handler. If the fault is unrecoverable (e.g., branching to unmapped memory), it triggers a <code>MemoryViolation</code> or <code>DecodeError</code> stop condition.</li> </ul>"},{"location":"simulation_protocol/#4-output-artifacts","title":"4. Output Artifacts","text":"<p>Upon completion of a deterministic run, LabWired produces a bundle of artifacts.</p>"},{"location":"simulation_protocol/#41-structured-summary-resultjson","title":"4.1 Structured Summary (<code>result.json</code>)","text":"<p>Provides programmatic access to the simulation's final state and metrics.</p> <pre><code>{\n  \"result_schema_version\": \"1.0\",\n  \"status\": \"passed\",\n  \"steps_executed\": 451203,\n  \"cycles\": 620001,\n  \"instructions\": 451203,\n  \"energy_estimated_joules\": 0.045, \n  \"carbon_impact_grams\": 0.002,     \n  \"stop_reason\": \"halt\",\n  \"stop_reason_details\": {\n    \"triggered_stop_condition\": \"halt\",\n    \"triggered_limit\": null,\n    \"observed\": {\n      \"name\": \"pc\",\n      \"value\": 134218844\n    }\n  },\n  \"limits\": {\n    \"max_steps\": 100000000\n  },\n  \"assertions\": [\n    {\n      \"assertion\": { \"expected_stop_reason\": { \"expected_stop_reason\": \"halt\" } },\n      \"passed\": true\n    }\n  ],\n  \"firmware_hash\": \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n  \"config\": {\n    \"firmware\": \"test.elf\",\n    \"system\": \"system.yaml\",\n    \"script\": \"test.yaml\"\n  }\n}\n</code></pre>"},{"location":"simulation_protocol/#42-value-change-dump-tracevcd","title":"4.2 Value Change Dump (<code>trace.vcd</code>)","text":"<p>If VCD tracing is enabled, LabWired emits an IEEE 1364-2001 compliant <code>.vcd</code> trace capable of being inspected in GTKWave or PulseView.</p>"},{"location":"simulation_protocol/#43-junit-xml-junitxml","title":"4.3 JUnit XML (<code>junit.xml</code>)","text":"<p>Standard CI test reporting format mapped directly from <code>test_script.yaml</code> assertions.</p>"},{"location":"simulation_protocol/#5-error-taxonomy-exit-codes","title":"5. Error Taxonomy &amp; Exit Codes","text":"<p>LabWired CI runners exit with specific, predictable status codes.</p> Exit Code Constant Name Semantics Protocol Action <code>0</code> <code>EXIT_PASS</code> All assertions passed, simulation hit expected terminal condition. Treat as CI Success. <code>1</code> <code>EXIT_ASSERT_FAIL</code> At least one assertion failed (e.g., missing UART string, unexpected stop reason). Treat as CI Failure (Logic Error). <code>2</code> <code>EXIT_CONFIG_ERROR</code> Schema validation failed, missing files, or bad YAML. Fix configuration inputs before retry. <code>3</code> <code>EXIT_RUNTIME_ERROR</code> Internal simulation panic or unrecoverable error. Report issue / Check hardware compatibility."},{"location":"simulation_protocol/#51-stop-reasons","title":"5.1 Stop Reasons","text":"<p>The <code>stop_reason</code> represents the exact trigger that transitioned the simulator out of the Execution Loop:</p> <ul> <li><code>ConfigError</code>: Configuration or parsing failed.</li> <li><code>MaxSteps</code>: Exceeded <code>max_steps</code> limit.</li> <li><code>MaxCycles</code>: Exceeded <code>max_cycles</code> limit.</li> <li><code>MaxUartBytes</code>: Exceeded <code>max_uart_bytes</code> limit.</li> <li><code>MaxEnergy</code>: (Future) Exceeded <code>max_energy_joules</code> sustainability budget.</li> <li><code>NoProgress</code>: CPU is spinning without meaningful state change (e.g., stuck in a tight loop reading the same address).</li> <li><code>WallTime</code>: Exceeded <code>wall_time_ms</code>.</li> <li><code>MemoryViolation</code>: Accessing unmapped memory or violating access permissions.</li> <li><code>DecodeError</code>: Encountered an invalid opcode.</li> <li><code>Halt</code>: The CPU hit a software breakpoint or halted intentionally.</li> <li><code>AgentIntervention</code>: (Future) An external AI actor issued a halt command via the MAESTRO API.</li> <li><code>FmiTimeout</code>: (Future) Hardware-in-the-loop (FMI 3.0) plant simulation diverged.</li> </ul>"},{"location":"simulation_protocol/#6-compatibility-and-versioning-policy","title":"6. Compatibility and Versioning Policy","text":"<p>LabWired's Simulation Protocol follows strict Semantic Versioning.</p> <ul> <li>Schema Versioning: <code>schema_version: \"1.0\"</code> declarations are frozen. Any breaking changes to field names, allowed values, or structured outputs will require a schema bump to <code>v2.0</code> or <code>v1.1</code>.</li> <li>Deprecation: Legacy formats (e.g., the top-heavy <code>v1</code> legacy script) are guaranteed to be supported. A deprecation warning will be printed to <code>stderr</code> indicating the migration path.</li> <li>Forward Compatibility: Unknown fields inside manifests will generally be rejected to ensure reproducible, strict execution (i.e., <code>deny_unknown_fields</code>).</li> </ul>"},{"location":"simulation_protocol/#7-future-proofing-extensibility-hooks","title":"7. Future-Proofing Extensibility Hooks","text":"<p>The Simulation Protocol is designed to be future-proof against upcoming shifts in hardware simulation requirements. The following schemas and interactions are reserved for future major and minor releases without breaking the core <code>1.x</code> execution bounds:</p> <ul> <li>Hybrid Co-Simulation (RTL Integration): Future protocol additions will allow binding <code>peripheral.yaml</code> registers to Verilator/C++ RTL models via high-speed, zero-copy shared memory IPC interfaces.</li> <li>Agentic AI API (MAESTRO Framework): The simulator will expose a gRPC/WebSocket streaming endpoint synchronized to this protocol's lifecycle (Reset -&gt; Execution -&gt; Halt). This allows external AI agents to read the virtual memory map, evaluate register states, map vulnerabilities, and trigger <code>AgentIntervention</code> limits autonomously.</li> <li>Multi-Physics &amp; FMI 3.0: Future revisions will support <code>board_io</code> mapping extensions. IO pins will map not just to basic UI components (LEDs), but to external FMU (Functional Mock-up Unit) properties modeling dynamic Battery State-of-Charge and CPU Thermal throttling behavior in time-sync with the Execution Loop.</li> </ul>"},{"location":"supported_devices/","title":"LabWired Tier 1 Device Support Strategy","text":"<p>To demonstrate the power of LabWired, we are committing to full, deep support for the three most popular microcontroller families in the industry/hobbyist space.</p> <p>These devices will serve as the \"Gold Standard\" for our simulation fidelity, driving the development of the core engine.</p>"},{"location":"supported_devices/#the-tier-1-trio","title":"The Tier 1 Trio","text":"Device Core Why Selected? Key Features to Support STM32F401 ARM Cortex-M4F Industry standard for embedded dev. Massive ecosystem. RCC (complex clock tree), DMA, GPIO Matrix. RP2040 Dual Cortex-M0+ Raspberry Pi Pico. Huge hobbyist following. Unique PIO. Dual Core simulation, PIO (Programmable I/O), SIO. nRF52832 ARM Cortex-M4F Dominant in IoT/BLE. Radio peripheral modeling, PPI (Programmable Peripheral Interconnect), EasyDMA."},{"location":"supported_devices/#support-definition-fully-supported","title":"Support Definition (\"Fully Supported\")","text":"<p>For a Tier 1 device, \"support\" means more than just loading the ELF. It includes:</p> <ol> <li>Strict IR Model: Full SVD ingestion (Done).</li> <li>Memory Map: Accurate RAM/ROM regions defined in <code>labwired-core</code>.</li> <li>Interrupt Controller (NVIC): Correct vector table sizing and priority grouping.</li> <li>Key Peripherals:<ul> <li>GPIO: Pin state visualization.</li> <li>UART: Interactive console I/O.</li> <li>Timers: Accurate counting and interrupt generation.</li> </ul> </li> <li>Board Integration: Specific board presets (e.g., \"Nucleo-F401RE\", \"Pico\").</li> </ol>"},{"location":"supported_devices/#roadmap","title":"Roadmap","text":""},{"location":"supported_devices/#phase-1-ingestion-current","title":"Phase 1: Ingestion (Current)","text":"<ul> <li>Verify SVD ingestion for all three (STM32, RP2040, nRF52).</li> <li>Generate <code>models/&lt;device&gt;.json</code> ground truth.</li> </ul>"},{"location":"supported_devices/#phase-2-core-integration","title":"Phase 2: Core Integration","text":"<ul> <li>Add <code>DeviceConfig</code> presets in <code>crates/config</code>.</li> <li>Implement specific peripheral hooks (e.g. hooking RP2040 SIO to core logic).</li> </ul>"},{"location":"supported_devices/#phase-3-validation","title":"Phase 3: Validation","text":"<ul> <li>Run standard Blinky/UART firmware binaries from unmodified SDKs (STM32Cube, Pico SDK, Zephyr) on the simulator.</li> </ul>"},{"location":"target_support_rubric/","title":"Target Support Rubric","text":"<p>Date: February 22, 2026 Purpose: Define when a target can be described as \"supported\" in docs and release notes.</p>"},{"location":"target_support_rubric/#support-levels","title":"Support Levels","text":"Level Label Minimum Requirements L0 <code>declared</code> Chip and system config files exist and validate. No smoke evidence required. L1 <code>smoke-supported</code> Deterministic smoke script exists and passes in CI with reproducible artifacts. PC/SP reset path validated. L2 <code>ci-qualified</code> L1 plus repeated CI pass history and known-limitations file. Unsupported-instruction audit generated and reviewed. L3 <code>production-ready</code> L2 plus Tier-1 peripheral baseline validated (<code>clock/rcc</code>, <code>gpio</code>, <code>uart</code>, <code>timer</code>, <code>dma</code>, <code>irq</code>) and stable benchmark variance."},{"location":"target_support_rubric/#definition-of-supported","title":"Definition of Supported","text":"<p>A target is \"supported\" for public communication only at <code>L1</code> or above.</p>"},{"location":"target_support_rubric/#mandatory-evidence-for-l1","title":"Mandatory Evidence for L1+","text":"<ol> <li>Runnable example script under <code>core/examples/</code>.</li> <li>Deterministic CI artifact bundle with:</li> <li>execution result JSON,</li> <li>UART output log (if UART is used),</li> <li>summary fingerprint/hash.</li> <li>Captured stop reason and assertion outcomes.</li> <li>Explicit known limitations section in target docs.</li> </ol>"},{"location":"target_support_rubric/#tier-1-peripheral-checklist","title":"Tier-1 Peripheral Checklist","text":"<p>Mark each as <code>pass</code>, <code>partial</code>, or <code>blocked</code>:</p> <ol> <li><code>clock/rcc</code></li> <li><code>gpio</code></li> <li><code>uart</code></li> <li><code>timer</code></li> <li><code>dma</code></li> <li><code>interrupt controller / irq delivery</code></li> </ol> <p><code>L3</code> requires all six at <code>pass</code> for the documented scenario set.</p>"},{"location":"target_support_rubric/#promotion-rules","title":"Promotion Rules","text":"<ol> <li><code>L0 -&gt; L1</code>: add deterministic smoke and CI evidence.</li> <li><code>L1 -&gt; L2</code>: add audit artifacts and trend stability over repeated runs.</li> <li><code>L2 -&gt; L3</code>: complete Tier-1 peripheral checklist with no blocking gaps.</li> </ol>"},{"location":"target_support_rubric/#demotion-rules","title":"Demotion Rules","text":"<p>Demote one level when any of the following occurs:</p> <ol> <li>deterministic smoke no longer passes in CI.</li> <li>reset path or core assertions regress.</li> <li>known limitations are missing or stale for current behavior.</li> </ol>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide addresses common issues encountered when using LabWired Core.</p>"},{"location":"troubleshooting/#simulation-issues","title":"Simulation Issues","text":""},{"location":"troubleshooting/#memory-violation-at-0x","title":"\"Memory Violation at 0x...\"","text":"<p>Symptom: The simulator halts with <code>StopReason::MemoryViolation(address)</code>. Cause: The firmware attempted to access an address that is not mapped to Flash, RAM, or any registered peripheral. Solution: 1. Check your <code>chips/&lt;chip&gt;.yaml</code> definition. Does the address fall within the declared Flash or RAM regions? 2. Check your <code>system.yaml</code>. Is there a peripheral missing that should be at that address? 3. Verify the firmware linker script (<code>memory.x</code>). It might be placing data in valid hardware regions that the simulator doesn't know about yet.</p>"},{"location":"troubleshooting/#instruction-decode-error","title":"\"Instruction Decode Error\"","text":"<p>Symptom: <code>StopReason::DecodeError(address)</code>. Cause: The CPU attempted to execute an instruction that is invalid or undefined for the current architecture (e.g., executing data as code). Solution: 1. Check the Vector Table. Is the Reset Vector pointing to the correct entry point (usually <code>_start</code> or <code>Reset_Handler</code> + 1 for Thumb mode)? 2. Verify <code>load_firmware</code> succeeded. Run with <code>--trace</code> to see the first few instructions. If it crashes immediately, the entry point might be wrong. 3. Cortex-M requires the PC LSB to be 1 (Thumb mode). If your vector table has an even address (e.g., <code>0x08000100</code>), the CPU will switch to ARM mode and fault.</p>"},{"location":"troubleshooting/#dap-server-unreachable","title":"\"DAP Server Unreachable\"","text":"<p>Symptom: VS Code displays \"Connection refused\" or \"Timeout\" when starting a debug session. Cause: The LabWired instance isn't running, or the port is blocked. Solution: 1. Ensure LabWired is started with <code>--gdb</code> or is in interactive mode. 2. Check the port (default <code>3333</code>). Is it in use by another OpenOCD/J-Link instance? 3. In <code>launch.json</code>, verify <code>miDebuggerServerAddress</code> matches <code>localhost:&lt;port&gt;</code>.</p>"},{"location":"troubleshooting/#uart-output-is-garbage","title":"\"UART Output is Garbage\"","text":"<p>Symptom: <code>uart.log</code> contains random characters. Cause: Baud rate mismatch between firmware and simulator config. Solution: 1. LabWired's UART model is currently \"byte-perfect\" (it doesn't simulate physical baud timing errors), but ensure your firmware is actually writing valid ASCII. 2. Check if <code>echo_stdout</code> is enabled or if you are looking at raw binary data.</p>"},{"location":"troubleshooting/#cicd-issues","title":"CI/CD Issues","text":""},{"location":"troubleshooting/#max-steps-reached","title":"\"Max Steps Reached\"","text":"<p>Symptom: CI fails with <code>StopReason::MaxSteps</code>. Cause: The proprietary <code>max_steps</code> limit in your test script is too low for the initialization code to complete. Solution: 1. Increase <code>max_steps</code> in your <code>.yaml</code> test script. 2. Optimize your firmware boot sequence (e.g., reduce PLL validation timeouts).</p>"},{"location":"troubleshooting/#no-progress-stuck","title":"\"No Progress / Stuck\"","text":"<p>Symptom: <code>StopReason::NoProgress</code>. Cause: The PC has stayed in the same range (or exactly the same address) for <code>no_progress_steps</code>. This usually means an infinite loop (e.g., <code>while(1) {}</code> or a HardFault handler). Solution: 1. Use <code>--trace</code> to identify the loop. 2. If it's a valid strict polling loop, insert a <code>asm!(\"nop\")</code> or similar to vary the PC, or increase <code>no_progress_steps</code>.</p>"},{"location":"vscode_debugging/","title":"VS Code Debugging Configurations","text":"<p>LabWired supports two primary debugging methods in VS Code: Native DAP (Recommended) and GDB via Cortex-Debug.</p>"},{"location":"vscode_debugging/#1-native-dap-recommended","title":"1. Native DAP (Recommended)","text":"<p>Uses the LabWired VS Code extension directly. Best for simplicity and live telemetry performance.</p> <p><code>.vscode/launch.json</code>: <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"labwired\",\n            \"request\": \"launch\",\n            \"name\": \"LabWired: Native DAP\",\n            \"program\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"args\": [\"--system\", \"config/system.yaml\"],\n            \"stopOnEntry\": true,\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre></p> <p>See Debugging Guide for architectural details.</p>"},{"location":"vscode_debugging/#2-gdb-cortex-debug","title":"2. GDB / Cortex-Debug","text":"<p>Uses the standard <code>cortex-debug</code> extension connected to LabWired's GDB server. Best if you need SVD peripheral views or other Cortex-Debug specific features.</p> <p><code>.vscode/launch.json</code>: <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"cortex-debug\",\n            \"request\": \"launch\",\n            \"name\": \"LabWired: GDB Remote\",\n            \"servertype\": \"external\",\n            \"gdbTarget\": \"localhost:3333\",\n            \"executable\": \"${workspaceFolder}/target/thumbv7m-none-eabi/debug/firmware\",\n            \"runToEntryPoint\": \"main\",\n            \"svdFile\": \"${workspaceFolder}/STM32F103.svd\",\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n</code></pre></p> <p>Note: You must start the LabWired GDB server manually before launching this configuration: <pre><code>labwired --gdb --port 3333 --firmware ...\n</code></pre></p>"},{"location":"archive/design/modular_components/","title":"Modular Components Design Document","text":"<p>This document describes the architectural vision for making LabWired components (Cores, Peripherals, and Interconnects) truly modular and swappable.</p>"},{"location":"archive/design/modular_components/#architectural-boundaries","title":"Architectural Boundaries","text":"<p>LabWired follows a \"Wiring\" model where components are connected via explicit signals rather than being tightly coupled in code.</p>"},{"location":"archive/design/modular_components/#1-core-cpu","title":"1. Core (CPU)","text":"<p>The Core is responsible for instruction execution. It interacts with the rest of the system through: - Bus Interface: A standard interface for memory transactions (Read/Write). - Interrupt Interface: A set of input lines (IRQs) that can trigger exception handling. - Clock/Reset Interface: Inputs to control execution state and timing.</p>"},{"location":"archive/design/modular_components/#2-bus-interconnect","title":"2. Bus / Interconnect","text":"<p>The Bus serves as the system's central nervous system, routing transactions between the Core and Peripherals. - Static Mapping: Memory-mapped regions (Flash, RAM, Peripherals). - Arbitration: Handling multiple masters (DMA, Cores) accessing shared resources.</p>"},{"location":"archive/design/modular_components/#3-peripheral-model","title":"3. Peripheral Model","text":"<p>Peripherals are standalone components that: - Map to one or more address ranges. - Expose Signals (GPIO pins, IRQ lines). - Can be \"ticked\" to simulate internal state transitions over time.</p>"},{"location":"archive/design/modular_components/#multi-architecture-vision","title":"Multi-Architecture Vision","text":"<p>To \"emulate them all,\" LabWired must support a variety of popular architectures beyond ARM Cortex-M.</p>"},{"location":"archive/design/modular_components/#supported-architectures-targets","title":"Supported Architectures (Targets)","text":"<ul> <li>ARM Cortex-M (e.g., STM32, RP2040): Current focus. Strong emphasis on NVIC and Thumb ISA.</li> <li>RISC-V (e.g., ESP32-C3, CH32V): Rapidly growing open-source ISA. Simplified interrupt models (CLINT/CLIC).</li> <li>Xtensa (e.g., ESP32, ESP32-S3): Popular for high-performance IoT. Features complex multi-level interrupt controllers and windowed registers.</li> <li>AVR (e.g., ATmega328P): Legacy but still widespread in industrial/hobbyist sectors. 8-bit architecture with direct vector table mapping.</li> </ul>"},{"location":"archive/design/modular_components/#multi-core-support","title":"Multi-Core Support","text":"<p>Many modern MCUs (ESP32, RP2040) are multi-core. Our architecture must transition from a single <code>cpu</code> ownership model to a flexible execution model.</p>"},{"location":"archive/design/modular_components/#1-multicoremachine","title":"1. MultiCoreMachine","text":"<p>The <code>Machine</code> struct will be evolved to support multiple cores sharing a common <code>SystemBus</code>. - Inter-Processor Communication (IPC): Support for hardware semaphores and mailboxes. - Shared Peripherals: Proper handling of concurrent access to atomic peripherals.</p>"},{"location":"archive/design/modular_components/#2-heterogeneous-cores","title":"2. Heterogeneous Cores","text":"<p>Some systems combine different architectures (e.g., a Cortex-M4 and a Cortex-M0+, or a RISC-V co-processor). Modular boundaries allow these cores to \"plug into\" the same bus regardless of their internal ISA.</p>"},{"location":"archive/design/modular_components/#revised-interrupt-model-for-portability","title":"Revised Interrupt Model for Portability","text":"<p>To support diverse architectures, the \"Interrupt Controller\" must move from being an ARM-specific NVIC to a generic component that translates <code>InterruptLine</code> signals into ISA-specific exceptions.</p> <ul> <li>AVR: Signals map directly to vector table offsets.</li> <li>Xtensa: Signals map to specific interrupt levels and priority groups.</li> <li>RISC-V: Signals map to Local or Global (PLIC) interrupt inputs.</li> </ul>"},{"location":"archive/design/modular_components/#migration-path-emulate-them-all","title":"Migration Path: \"Emulate Them All\"","text":"<ol> <li>Generic Cpu Trait refinement: Ensure <code>Cpu</code> does not expose ARM-specific registers or concepts in its core interface.</li> <li>Pluggable Interrupt Controllers: Move NVIC logic into a standalone peripheral that implements a generic <code>InterruptController</code> trait.</li> <li>Multi-core Scheduler: Introduce a simulation tick that propagates cycles across all active cores in a <code>Machine</code>.</li> </ol>"},{"location":"archive/design/multi_arch_refactor/","title":"Multi-Architecture Support Refactoring","text":""},{"location":"archive/design/multi_arch_refactor/#context","title":"Context","text":"<p>LabWired core is currently tightly coupled to ARM Cortex-M architecture, specifically regarding system peripherals like NVIC and SCB, and the Vector Table Offset Register (VTOR). To support other architectures (RISC-V, AVR, etc.), we need to decouple the generic <code>Machine</code> and <code>Cpu</code> trait from these specifics.</p>"},{"location":"archive/design/multi_arch_refactor/#goals","title":"Goals","text":"<ul> <li>Remove hardcoded dependencies on ARM Cortex-M architecture (NVIC, SCB, VTOR) from the generic <code>Cpu</code> trait.</li> <li>Make <code>Machine</code> struct a pure execution container, agnostic of specific system peripherals.</li> <li>Introduce specific system configuration helpers for Cortex-M.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#implementation-plan","title":"Implementation Plan","text":""},{"location":"archive/design/multi_arch_refactor/#1-refactor-cpu-trait","title":"1. Refactor <code>Cpu</code> Trait","text":"<p>File: <code>crates/core/src/cpu/mod.rs</code></p> <ul> <li>Remove <code>get_vtor</code>, <code>set_vtor</code>, <code>set_shared_vtor</code> from <code>Cpu</code> trait.</li> <li>Keep <code>set_exception_pending</code> as it is a generic concept.</li> <li><code>CortexM</code> implementation will retain <code>vtor</code> logic but it will not be exposed via the generic trait.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#2-decouple-machine-from-system-peripherals","title":"2. Decouple <code>Machine</code> from System Peripherals","text":"<p>File: <code>crates/core/src/lib.rs</code></p> <ul> <li>Remove <code>Machine::with_bus()</code> logic that automatically instantiates and attaches <code>Nvic</code> and <code>Scb</code> peripherals.</li> <li><code>Machine</code> should only accept an already configured <code>Bus</code> and <code>Cpu</code>.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#3-introduce-system-helper","title":"3. Introduce System Helper","text":"<p>File: <code>crates/core/src/lib.rs</code> (or a sidebar module)</p> <ul> <li>Create a helper function/struct <code>configure_cortex_m(bus: &amp;mut SystemBus) -&gt; (CortexM, Arc&lt;NvicState&gt;)</code> or similar.</li> <li>This helper will:<ul> <li>Create shared <code>AtomicU32</code> for VTOR.</li> <li>Create <code>CortexM</code> CPU instance with this VTOR.</li> <li>Create <code>Nvic</code> and <code>Scb</code> peripherals, sharing the VTOR and NVIC state.</li> <li>Attach peripherals to the bus.</li> </ul> </li> </ul>"},{"location":"archive/design/multi_arch_refactor/#4-update-consumers-cli-tests","title":"4. Update Consumers (CLI &amp; Tests)","text":"<p>File: <code>crates/cli/src/main.rs</code>, <code>crates/core/tests.rs</code></p> <ul> <li>Update <code>run_interactive</code> and <code>run_test</code> to explicitly call the Cortex-M configuration logic before creating the <code>Machine</code>.</li> </ul>"},{"location":"archive/design/multi_arch_refactor/#status-completed","title":"Status: Completed","text":"<p>The multi-architecture refactor has been successfully implemented: -   Core Interface: Generic <code>Cpu</code> trait is decoupled from ARM-specific registers. -   Machine Initialization: <code>Machine</code> is now architecture-agnostic, with system setup helpers for Cortex-M and RISC-V. -   Snapshots: <code>CpuSnapshot</code> refactored into an enum, supporting standardized state capture for both ARM and RISC-V. -   Test Runner: The <code>labwired test</code> command automatically detects the architecture from ELF files and runs the appropriate simulation loop. -   Regression Testing: CI pipeline validated with real ELF binaries for ARM (M0, M3) and RISC-V.</p>"},{"location":"archive/design/system_descriptors/","title":"Design: LabWired System Descriptors","text":""},{"location":"archive/design/system_descriptors/#objective","title":"Objective","text":"<p>Enable users to define complex hardware setups using declarative descriptor files. Instead of hardcoding memory maps and peripherals, the simulator will load a System Manifest that describes the chip (e.g., STM32F103) and its connected environment (e.g., an I2C sensor).</p>"},{"location":"archive/design/system_descriptors/#1-descriptor-hierarchy","title":"1. Descriptor Hierarchy","text":""},{"location":"archive/design/system_descriptors/#a-chip-descriptor-chipsstm32f103yaml","title":"A. Chip Descriptor (<code>chips/stm32f103.yaml</code>)","text":"<p>Defines the internal architecture of a specific SoC. - CPU: Type (Cortex-M3), Clock frequency. - Memory Map: Flash, RAM, and Reserved regions. - Internal Peripherals: UART, GPIO, SPI, I2C, Timers (with base addresses).</p>"},{"location":"archive/design/system_descriptors/#b-boardsystem-manifest-boardsmy_projectyaml","title":"B. Board/System Manifest (<code>boards/my_project.yaml</code>)","text":"<p>Defines the \"Wiring\" and external components. - Target Chip: Reference to a Chip Descriptor. - External Devices: Stubs or functional models (e.g., Temperature Sensor). - Connections: How external devices map to chip pins/peripherals (e.g., Sensor on I2C1).</p>"},{"location":"archive/design/system_descriptors/#2-proposed-yaml-schema-example","title":"2. Proposed YAML Schema (Example)","text":"<pre><code># system.yaml\nname: \"Industrial Sensor Node\"\nchip: \"stm32f103c8\" # Looked up in chip registry\n\nmemory_overrides:\n  flash_size: 128KB\n  ram_size: 20KB\n\nperipherals:\n  - id: \"uart1\"\n    type: \"uart\"\n    base_address: 0x40013800\n    config:\n      baud_rate: 115200\n\nexternal_devices:\n  - id: \"temp_sensor\"\n    type: \"functional_stub\"\n    model: \"tmp102\"\n    connection:\n      interface: \"i2c1\"\n      address: 0x48\n    initial_state:\n      temperature: 25.0\n</code></pre>"},{"location":"archive/design/system_descriptors/#3-implementation-workflow","title":"3. Implementation Workflow","text":"<ol> <li><code>labwired-config</code> Crate: New crate to handle parsing and validation of YAML/JSON descriptors.</li> <li>Dynamic <code>SystemBus</code>: Refactor <code>SystemBus</code> to hold a collection of <code>Peripheral</code> trait objects mapped by address range, rather than hardcoded fields.</li> <li>Peripheral Factory: A central registry that instantiates peripherals (UART, Timer, etc.) based on the <code>type</code> string in the descriptor.</li> <li>Device Stubbing: Support for \"functional models\" where users can provide simple scripts or parameters to simulate external sensor data.</li> </ol>"},{"location":"archive/design/system_descriptors/#4-integration-with-cli","title":"4. Integration with CLI","text":"<p>The user will run: <pre><code>labwired --firmware firmware.elf --system my_project.yaml\n</code></pre> The simulator will auto-configure everything based on the YAML.</p>"},{"location":"archive/design/system_descriptors/#5-next-steps-iteration-6","title":"5. Next Steps (Iteration 6)","text":"<ol> <li>Define the <code>SystemManifest</code> struct.</li> <li>Implement YAML parsing using <code>serde_yaml</code>.</li> <li>Refactor <code>SystemBus</code> to use a dynamic memory map.</li> </ol>"},{"location":"examples/dma_exti_example/","title":"Example: DMA and Interrupt Logic","text":"<p>LabWired models Direct Memory Access (DMA) and External Interrupts (EXTI) using a deterministic two-phase execution cycle. This ensures that concurrent hardware events (like memory transfers and IRQ assertion) occur in a predictable order relative to CPU instruction execution.</p>"},{"location":"examples/dma_exti_example/#1-dma-memory-to-memory-transfer","title":"1. DMA Memory-to-Memory Transfer","text":"<p>The DMA controller processes transfer requests at the end of the CPU instruction cycle.</p>"},{"location":"examples/dma_exti_example/#configuration","title":"Configuration","text":"<p>To initiate a memory-to-memory transfer, the firmware must configure the DMA channel with the <code>MEM2MEM</code> bit set.</p> <pre><code>// DMA1 Channel 1 Configuration\nfn configure_dma_transfer(src: u32, dest: u32, len: u16) {\n    let dma = unsafe { &amp;*DMA1::ptr() };\n\n    // 1. Source and Destination Addresses\n    dma.ch1.cpar.write(|w| unsafe { w.bits(src) });\n    dma.ch1.cmar.write(|w| unsafe { w.bits(dest) });\n\n    // 2. Transfer Length\n    dma.ch1.cndtr.write(|w| unsafe { w.bits(len as u32) });\n\n    // 3. Control Register (Enable, Mem2Mem, Increment Ptrs)\n    dma.ch1.ccr.write(|w| w\n        .mem2mem().set_bit() \n        .pl().very_high()\n        .minc().enabled()\n        .pinc().enabled()\n        .en().enabled()\n    );\n}\n</code></pre>"},{"location":"examples/dma_exti_example/#execution-model","title":"Execution Model","text":"<ol> <li>Request Phase: When <code>CCR.EN</code> is set, the DMA controller registers a pending request internally. It does not immediately modify memory.</li> <li>Bus Arbitration: At the end of the current CPU cycle, the <code>SystemBus</code> polls the DMA controller.</li> <li>Transfer Phase: The bus executes the memory copy operation (read from source, write to destination).</li> </ol>"},{"location":"examples/dma_exti_example/#2-external-interrupts-exti","title":"2. External Interrupts (EXTI)","text":"<p>External signals are routed through the EXTI controller to the Nested Vectored Interrupt Controller (NVIC).</p>"},{"location":"examples/dma_exti_example/#stimulus-configuration","title":"Stimulus Configuration","text":"<p>To verify interrupt logic, use a test script to assert a GPIO pin state.</p> <p>System Manifest (<code>system.yaml</code>): <pre><code>chip: \"../chips/stm32f103.yaml\"\ninputs:\n  - id: \"user_button\"\n    pin: \"PA0\"\n    mode: \"PushPull\"\n</code></pre></p> <p>Test Script (<code>test_interrupts.yaml</code>): <pre><code>steps:\n  - run: 100ms\n  - set_pin: \n      pin: \"PA0\"\n      state: \"high\"\n  - run: 1us\n  - assert_interrupt: \"EXTI0\"\n</code></pre></p>"},{"location":"examples/dma_exti_example/#signal-propagation","title":"Signal Propagation","text":"<ol> <li>GPIO: The pin state change is detected by the GPIO peripheral.</li> <li>AFIO: The signal is routed to the corresponding EXTI line (e.g., PA0 -&gt; EXTI0) based on the AFIO_EXTICR configuration.</li> <li>EXTI: The controller detects the rising/falling edge and sets the Pending Register (PR) bit.</li> <li>NVIC: The interrupt is forwarded to the NVIC. If the priority acts, the CPU vectors to the ISR on the next instruction fetch.</li> </ol>"},{"location":"examples/i2c_sensor_example/","title":"Example: I2C Sensor Simulation","text":"<p>This example demonstrates how to simulate an I2C peripheral (e.g., TMP102) and verify its behavior using standard Rust firmware.</p>"},{"location":"examples/i2c_sensor_example/#1-system-configuration","title":"1. System Configuration","text":"<p>The simulation environment requires defining the sensor in the system manifest and connecting it to the appropriate I2C controller.</p>"},{"location":"examples/i2c_sensor_example/#configuration-systemyaml","title":"Configuration (<code>system.yaml</code>)","text":"<pre><code>chip: \"../chips/stm32f103.yaml\"\nperipherals:\n  - id: \"i2c1\"\n    type: \"i2c_master\"\n    base_address: 0x40005400\n\n  - id: \"tmp102\"\n    type: \"i2c_temp_sensor\"  # Instantiates the TMP102 model\n    address: 0x48            # 7-bit I2C address\n    bus: \"i2c1\"              # Connects to the I2C1 controller\n</code></pre>"},{"location":"examples/i2c_sensor_example/#2-firmware-integration","title":"2. Firmware Integration","text":"<p>The firmware uses standard HAL calls to interact with the simulated device. No simulation-specific code is required in the firmware itself.</p>"},{"location":"examples/i2c_sensor_example/#rust-implementation-stm32f1xx-hal","title":"Rust Implementation (<code>stm32f1xx-hal</code>)","text":"<pre><code>use stm32f1xx_hal::{i2c::{BlockingI2c, Mode}, pac};\n\nfn main() -&gt; ! {\n    let dp = pac::Peripherals::take().unwrap();\n    // ... Clock Configuration ...\n\n    // Initialize I2C1 (Standard Mode, 100kHz)\n    let mut i2c = BlockingI2c::i2c1(\n        dp.I2C1,\n        (scl, sda), // Pins PB6, PB7\n        &amp;mut afio.mapr,\n        Mode::Standard { frequency: 100.kHz() },\n        clocks,\n        &amp;mut rcc.apb1,\n        1000, 10, 1000, 1000,\n    );\n\n    let sensor_addr = 0x48;\n    let mut buffer = [0u8; 2];\n\n    loop {\n        // Read Temperature Register (0x00)\n        i2c.write_read(sensor_addr, &amp;[0x00], &amp;mut buffer).unwrap();\n\n        // Convert to Celsius (12-bit, 0.0625\u00b0C resolution)\n        let raw_temp = u16::from_be_bytes(buffer) &gt;&gt; 4;\n        let celsius = raw_temp as f32 * 0.0625;\n    }\n}\n</code></pre>"},{"location":"examples/i2c_sensor_example/#3-automated-verification","title":"3. Automated Verification","text":"<p>LabWired supports scripted fault injection to verify error handling logic.</p>"},{"location":"examples/i2c_sensor_example/#fault-injection-script-testsfault_testyaml","title":"Fault Injection Script (<code>tests/fault_test.yaml</code>)","text":"<p>Simulates a sensor failure or extreme environmental condition.</p> <pre><code>steps:\n  - run: 100ms\n  - write_peripheral:\n      id: \"tmp102\"\n      reg: \"TEMP\"\n      value: 0x7FF0 # Force sensor reading to 128\u00b0C\n  - run: 10ms\n  - assert_log: \"CRITICAL: OVERTEMP DETECTED\"\n</code></pre>"},{"location":"examples/i2c_sensor_example/#4-execution","title":"4. Execution","text":"<p>Run the simulation with the test script:</p> <pre><code>labwired test --script tests/fault_test.yaml\n</code></pre> <p>The simulator will execute the firmware, inject the fault at the specified time, and verify that the firmware correctly detects and logs the error condition.</p>"},{"location":"examples/integrated_test_walkthrough/","title":"Walkthrough: Integrated STM32 Test Example","text":"<p>This example demonstrates how to use the <code>labwired test</code> runner to verify a real STM32 firmware on a custom system configuration.</p>"},{"location":"examples/integrated_test_walkthrough/#1-the-building-blocks","title":"1. The Building Blocks","text":""},{"location":"examples/integrated_test_walkthrough/#chip-descriptor-stm32f103yaml","title":"Chip Descriptor (stm32f103.yaml)","text":"<p>Defines the memory map and peripherals (DMA, EXTI, AFIO, UART).</p>"},{"location":"examples/integrated_test_walkthrough/#system-manifest-stm32f103-integrated-testyaml","title":"System Manifest (stm32f103-integrated-test.yaml)","text":"<p>Wires the chip into a specific system context. In this case, it just uses the raw chip.</p>"},{"location":"examples/integrated_test_walkthrough/#firmware-mainrs","title":"Firmware (main.rs)","text":"<p>A Rust <code>no_std</code> firmware that: - Performs 32-bit division. - Configures DMA1 Channel 1 for a memory-to-memory transfer. - Triggers a software interrupt via EXTI Line 0. - Enters an infinite loop.</p>"},{"location":"examples/integrated_test_walkthrough/#2-the-test-script","title":"2. The Test Script","text":"<p>The test script (stm32f103_integrated_test.yaml) automates the simulation:</p> <pre><code>schema_version: \"1.0\"\ninputs:\n  firmware: \"../../target/thumbv7m-none-eabi/debug/firmware\"\n  system: \"../../configs/systems/stm32f103-integrated-test.yaml\"\nlimits:\n  max_steps: 10000\n  no_progress_steps: 1000\nassertions:\n  - expected_stop_reason: no_progress\n</code></pre>"},{"location":"examples/integrated_test_walkthrough/#3-running-the-test","title":"3. Running the Test","text":"<p>Run the test locally using the CLI:</p> <pre><code>labwired test --script examples/tests/stm32f103_integrated_test.yaml --output-dir out/test-results\n</code></pre>"},{"location":"examples/integrated_test_walkthrough/#inspecting-results","title":"Inspecting Results","text":"<p>The runner generates several artifacts in <code>out/test-results</code>: - <code>result.json</code>: Summary of execution stats and assertion results. - <code>snapshot.json</code>: Full state of the CPU and peripherals at the end of the run. - <code>uart.log</code>: Captured data from the UART peripheral.</p>"},{"location":"examples/integrated_test_walkthrough/#4-ci-integration","title":"4. CI Integration","text":"<p>You can easily integrate this into a GitHub Actions workflow:</p> <pre><code>- name: Run LabWired Integrated Test\n  run: |\n    labwired test \\\n      --script examples/tests/stm32f103_integrated_test.yaml \\\n      --output-dir artifacts\n</code></pre>"},{"location":"postmortems/2026-02-15-io-smoke-failure/","title":"Postmortem: STM32H563 GPIO ODR Failure (io-smoke)","text":"<p>Date: 2026-02-15 Status: Resolved Authors: @w1ne, @antigravity</p>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#issue-summary","title":"Issue Summary","text":"<p>The <code>io-smoke</code> regression test for the <code>nucleo-h563zi</code> board failed to assert the expected LED states. The firmware reported <code>PB0=0</code> even when the simulator's internal state showed the ODR was correctly set to <code>1</code>. This led to an initial investigation into GPIO peripheral logic, but the actual root cause was found in the CPU simulation.</p>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#impact","title":"Impact","text":"<ul> <li>Severity: High (Initially thought to be Medium, but CPU instruction failures have broad impact).</li> <li>Release: v0.12.0 will proceed AS PLANNED with this fix included.</li> <li>Tests Affected: <code>examples/nucleo-h563zi/io-smoke.yaml</code>.</li> </ul>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#root-cause-analysis","title":"Root Cause Analysis","text":""},{"location":"postmortems/2026-02-15-io-smoke-failure/#1-gpio-peripheral-verified-correct","title":"1. GPIO Peripheral (Verified Correct)","text":"<ul> <li>The ODR verification logs confirmed that the peripheral was correctly processing <code>BSRR</code> writes and updating the <code>ODR</code> value.</li> <li>The suspicion regarding <code>GpioPort</code> write buffering was a false positive.</li> </ul>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#2-cpu-simulation-actual-root-cause","title":"2. CPU Simulation (Actual Root Cause)","text":"<ul> <li>Missing <code>IT</code> (If-Then) Support: The Thumb-2 <code>IT</code> instruction was previously decoded as a <code>Nop</code>. In the guest firmware, conditional logic (e.g., <code>movpl r1, #48</code> inside an <code>IT PL</code> block) was being executed unconditionally or skipped incorrectly.</li> <li>Incomplete Thumb-2 Decoding: Instructions like <code>MOVW</code>, <code>MOVT</code>, and 32-bit <code>LDR</code>/<code>STR</code> variants were not correctly handled by the modular decoder, leading to inconsistent register state during the GPIO-to-UART reporting phase.</li> <li>Result: The firmware's reporting loop was correctly reading the <code>ODR</code> bit but incorrectly processing the character to send over UART because the conditional \"if bit is 1, send '1'\" logic was failing at the CPU level.</li> </ul>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#resolution","title":"Resolution","text":"<ul> <li><code>IT</code> Block State Management: Implemented <code>it_state</code> in the <code>CortexM</code> step loop to handle conditioned instructions correctly.</li> <li>Architectural Decoder Expansion: Updated <code>arm.rs</code> to handle <code>IT</code>, <code>MOVW</code>, <code>MOVT</code>, <code>LDR.W</code>, <code>STR.W</code>, and <code>UXTB.W</code> instructions.</li> <li>Verification: The <code>io-smoke</code> test now passes with <code>PB0=1</code>.</li> </ul>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#timeline-of-attempts","title":"Timeline of Attempts","text":"<ol> <li>Infinite Loop Fix: Fixed delay loop with <code>black_box</code>.</li> <li>Binary Freshness: Forced rebuild with correct target.</li> <li>RCC Enable: Enabled clocks in firmware.</li> <li>Diagnostic Trace: Added register write logging; identified that <code>MOVPL</code> was executing when it shouldn't have, pointing to <code>IT</code> failure.</li> <li>Fix: Implemented <code>IT</code> state machine and Thumb-2 instructions.</li> </ol>"},{"location":"postmortems/2026-02-15-io-smoke-failure/#permanent-mitigation","title":"Permanent Mitigation","text":"<p>The following strategies have been integrated into the v0.2.0 roadmap to prevent future silent instruction-level regressions: 1.  Automated ISA Audit: CI-time disassembly check of guest binaries to verify all used opcodes are implemented. 2.  Strict CPU Trap Mode: Configurable <code>--strict-cpu</code> flag to Promote <code>Unknown</code> instructions to hard panics during tests. 3.  Exhaustive Conformance Tests: Integration of ARM Thumb-2 test suites for bit-accurate verification. 4.  HIL Trace Comparison: Automated diffing of simulation traces against real hardware (Nucleo-H563ZI) logic analyzer logs.</p>"}]}