// Generated by LabWired Codegen
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
pub mod spi3 { # [doc = "Serial peripheral interface"] pub struct SPI3 ; impl SPI3 { pub const BASE_ADDR : u64 = 1073757184u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rtc { # [doc = "Real-time clock"] pub struct RTC ; impl RTC { pub const BASE_ADDR : u64 = 1073752064u64 ; } # [doc = "time register"] pub struct TR (u32) ; impl TR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Second units in BCD format"] pub fn su (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Second units in BCD format"] pub fn set_su (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Second tens in BCD format"] pub fn st (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Second tens in BCD format"] pub fn set_st (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Minute units in BCD format"] pub fn mnu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Minute units in BCD format"] pub fn set_mnu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Minute tens in BCD format"] pub fn mnt (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Minute tens in BCD format"] pub fn set_mnt (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hour units in BCD format"] pub fn hu (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Hour units in BCD format"] pub fn set_hu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Hour tens in BCD format"] pub fn ht (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Hour tens in BCD format"] pub fn set_ht (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "AM/PM notation"] pub fn pm (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "AM/PM notation"] pub fn set_pm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "date register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 8449u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Date units in BCD format"] pub fn du (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Date units in BCD format"] pub fn set_du (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Date tens in BCD format"] pub fn dt (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Date tens in BCD format"] pub fn set_dt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Month units in BCD format"] pub fn mu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Month units in BCD format"] pub fn set_mu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Month tens in BCD format"] pub fn mt (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Month tens in BCD format"] pub fn set_mt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Week day units"] pub fn wdu (& self) -> u32 { (self . 0 >> 13u32) & 7u32 } # [doc = "Week day units"] pub fn set_wdu (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Year units in BCD format"] pub fn yu (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Year units in BCD format"] pub fn set_yu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Year tens in BCD format"] pub fn yt (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Year tens in BCD format"] pub fn set_yt (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Wakeup clock selection"] pub fn wcksel (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Wakeup clock selection"] pub fn set_wcksel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Time-stamp event active\n              edge"] pub fn tsedge (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Time-stamp event active\n              edge"] pub fn set_tsedge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Reference clock detection enable (50 or\n              60 Hz)"] pub fn refckon (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Reference clock detection enable (50 or\n              60 Hz)"] pub fn set_refckon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Bypass the shadow\n              registers"] pub fn bypshad (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Bypass the shadow\n              registers"] pub fn set_bypshad (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Hour format"] pub fn fmt (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Hour format"] pub fn set_fmt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Coarse digital calibration\n              enable"] pub fn dce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Coarse digital calibration\n              enable"] pub fn set_dce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Alarm A enable"] pub fn alrae (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Alarm A enable"] pub fn set_alrae (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alarm B enable"] pub fn alrbe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Alarm B enable"] pub fn set_alrbe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Wakeup timer enable"] pub fn wute (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Wakeup timer enable"] pub fn set_wute (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Time stamp enable"] pub fn tse (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Time stamp enable"] pub fn set_tse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Alarm A interrupt enable"] pub fn alraie (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Alarm A interrupt enable"] pub fn set_alraie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alarm B interrupt enable"] pub fn alrbie (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Alarm B interrupt enable"] pub fn set_alrbie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Wakeup timer interrupt\n              enable"] pub fn wutie (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Wakeup timer interrupt\n              enable"] pub fn set_wutie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Time-stamp interrupt\n              enable"] pub fn tsie (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Time-stamp interrupt\n              enable"] pub fn set_tsie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Add 1 hour (summer time\n              change)"] pub fn add1h (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Add 1 hour (summer time\n              change)"] pub fn set_add1h (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Subtract 1 hour (winter time\n              change)"] pub fn sub1h (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Subtract 1 hour (winter time\n              change)"] pub fn set_sub1h (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Backup"] pub fn bkp (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Backup"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Calibration Output\n              selection"] pub fn cosel (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Calibration Output\n              selection"] pub fn set_cosel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Output polarity"] pub fn pol (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Output polarity"] pub fn set_pol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Output selection"] pub fn osel (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Output selection"] pub fn set_osel (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Calibration output enable"] pub fn coe (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Calibration output enable"] pub fn set_coe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "initialization and status\n          register"] pub struct ISR (u32) ; impl ISR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alarm A write flag"] pub fn alrawf (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Alarm B write flag"] pub fn alrbwf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Wakeup timer write flag"] pub fn wutwf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Shift operation pending"] pub fn shpf (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Shift operation pending"] pub fn set_shpf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Initialization status flag"] pub fn inits (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Registers synchronization\n              flag"] pub fn rsf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Registers synchronization\n              flag"] pub fn set_rsf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Initialization flag"] pub fn initf (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Initialization mode"] pub fn init (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Initialization mode"] pub fn set_init (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Alarm A flag"] pub fn alraf (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Alarm A flag"] pub fn set_alraf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alarm B flag"] pub fn alrbf (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Alarm B flag"] pub fn set_alrbf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Wakeup timer flag"] pub fn wutf (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Wakeup timer flag"] pub fn set_wutf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Time-stamp flag"] pub fn tsf (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Time-stamp flag"] pub fn set_tsf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Time-stamp overflow flag"] pub fn tsovf (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Time-stamp overflow flag"] pub fn set_tsovf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Tamper detection flag"] pub fn tamp1f (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Tamper detection flag"] pub fn set_tamp1f (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "TAMPER2 detection flag"] pub fn tamp2f (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "TAMPER2 detection flag"] pub fn set_tamp2f (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Recalibration pending Flag"] pub fn recalpf (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler register"] pub struct PRER (u32) ; impl PRER { pub const RESET_VALUE : u32 = 8323327u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Synchronous prescaler\n              factor"] pub fn prediv_s (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Synchronous prescaler\n              factor"] pub fn set_prediv_s (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Asynchronous prescaler\n              factor"] pub fn prediv_a (& self) -> u32 { (self . 0 >> 16u32) & 127u32 } # [doc = "Asynchronous prescaler\n              factor"] pub fn set_prediv_a (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "wakeup timer register"] pub struct WUTR (u32) ; impl WUTR { pub const RESET_VALUE : u32 = 65535u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Wakeup auto-reload value\n              bits"] pub fn wut (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Wakeup auto-reload value\n              bits"] pub fn set_wut (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "calibration register"] pub struct CALIBR (u32) ; impl CALIBR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Digital calibration"] pub fn dc (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Digital calibration"] pub fn set_dc (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Digital calibration sign"] pub fn dcs (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Digital calibration sign"] pub fn set_dcs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "alarm A register"] pub struct ALRMAR (u32) ; impl ALRMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Second units in BCD format"] pub fn su (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Second units in BCD format"] pub fn set_su (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Second tens in BCD format"] pub fn st (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Second tens in BCD format"] pub fn set_st (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alarm A seconds mask"] pub fn msk1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Alarm A seconds mask"] pub fn set_msk1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Minute units in BCD format"] pub fn mnu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Minute units in BCD format"] pub fn set_mnu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Minute tens in BCD format"] pub fn mnt (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Minute tens in BCD format"] pub fn set_mnt (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alarm A minutes mask"] pub fn msk2 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Alarm A minutes mask"] pub fn set_msk2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Hour units in BCD format"] pub fn hu (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Hour units in BCD format"] pub fn set_hu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Hour tens in BCD format"] pub fn ht (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Hour tens in BCD format"] pub fn set_ht (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "AM/PM notation"] pub fn pm (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "AM/PM notation"] pub fn set_pm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Alarm A hours mask"] pub fn msk3 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Alarm A hours mask"] pub fn set_msk3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Date units or day in BCD\n              format"] pub fn du (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Date units or day in BCD\n              format"] pub fn set_du (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Date tens in BCD format"] pub fn dt (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Date tens in BCD format"] pub fn set_dt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Week day selection"] pub fn wdsel (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Week day selection"] pub fn set_wdsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Alarm A date mask"] pub fn msk4 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Alarm A date mask"] pub fn set_msk4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "alarm B register"] pub struct ALRMBR (u32) ; impl ALRMBR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Second units in BCD format"] pub fn su (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Second units in BCD format"] pub fn set_su (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Second tens in BCD format"] pub fn st (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Second tens in BCD format"] pub fn set_st (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alarm B seconds mask"] pub fn msk1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Alarm B seconds mask"] pub fn set_msk1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Minute units in BCD format"] pub fn mnu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Minute units in BCD format"] pub fn set_mnu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Minute tens in BCD format"] pub fn mnt (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Minute tens in BCD format"] pub fn set_mnt (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alarm B minutes mask"] pub fn msk2 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Alarm B minutes mask"] pub fn set_msk2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Hour units in BCD format"] pub fn hu (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Hour units in BCD format"] pub fn set_hu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Hour tens in BCD format"] pub fn ht (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Hour tens in BCD format"] pub fn set_ht (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "AM/PM notation"] pub fn pm (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "AM/PM notation"] pub fn set_pm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Alarm B hours mask"] pub fn msk3 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Alarm B hours mask"] pub fn set_msk3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Date units or day in BCD\n              format"] pub fn du (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Date units or day in BCD\n              format"] pub fn set_du (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Date tens in BCD format"] pub fn dt (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Date tens in BCD format"] pub fn set_dt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Week day selection"] pub fn wdsel (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Week day selection"] pub fn set_wdsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Alarm B date mask"] pub fn msk4 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Alarm B date mask"] pub fn set_msk4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "write protection register"] pub struct WPR (u32) ; impl WPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Write protection key"] pub fn key (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Write protection key"] pub fn set_key (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "sub second register"] pub struct SSR (u32) ; impl SSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sub second value"] pub fn ss (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Sub second value"] pub fn set_ss (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "shift control register"] pub struct SHIFTR (u32) ; impl SHIFTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Subtract a fraction of a\n              second"] pub fn subfs (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Subtract a fraction of a\n              second"] pub fn set_subfs (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Add one second"] pub fn add1s (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Add one second"] pub fn set_add1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "time stamp time register"] pub struct TSTR (u32) ; impl TSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Second units in BCD format"] pub fn su (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Second units in BCD format"] pub fn set_su (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Second tens in BCD format"] pub fn st (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Second tens in BCD format"] pub fn set_st (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Minute units in BCD format"] pub fn mnu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Minute units in BCD format"] pub fn set_mnu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Minute tens in BCD format"] pub fn mnt (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Minute tens in BCD format"] pub fn set_mnt (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hour units in BCD format"] pub fn hu (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Hour units in BCD format"] pub fn set_hu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Hour tens in BCD format"] pub fn ht (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Hour tens in BCD format"] pub fn set_ht (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "AM/PM notation"] pub fn pm (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "AM/PM notation"] pub fn set_pm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "time stamp date register"] pub struct TSDR (u32) ; impl TSDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Date units in BCD format"] pub fn du (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Date units in BCD format"] pub fn set_du (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Date tens in BCD format"] pub fn dt (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Date tens in BCD format"] pub fn set_dt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Month units in BCD format"] pub fn mu (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Month units in BCD format"] pub fn set_mu (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Month tens in BCD format"] pub fn mt (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Month tens in BCD format"] pub fn set_mt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Week day units"] pub fn wdu (& self) -> u32 { (self . 0 >> 13u32) & 7u32 } # [doc = "Week day units"] pub fn set_wdu (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "timestamp sub second register"] pub struct TSSSR (u32) ; impl TSSSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sub second value"] pub fn ss (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Sub second value"] pub fn set_ss (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "calibration register"] pub struct CALR (u32) ; impl CALR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Calibration minus"] pub fn calm (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Calibration minus"] pub fn set_calm (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Use a 16-second calibration cycle\n              period"] pub fn calw16 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Use a 16-second calibration cycle\n              period"] pub fn set_calw16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Use an 8-second calibration cycle\n              period"] pub fn calw8 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Use an 8-second calibration cycle\n              period"] pub fn set_calw8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Increase frequency of RTC by 488.5\n              ppm"] pub fn calp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Increase frequency of RTC by 488.5\n              ppm"] pub fn set_calp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "tamper and alternate function configuration\n          register"] pub struct TAFCR (u32) ; impl TAFCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tamper 1 detection enable"] pub fn tamp1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Tamper 1 detection enable"] pub fn set_tamp1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Active level for tamper 1"] pub fn tamp1trg (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Active level for tamper 1"] pub fn set_tamp1trg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Tamper interrupt enable"] pub fn tampie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Tamper interrupt enable"] pub fn set_tampie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Tamper 2 detection enable"] pub fn tamp2e (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Tamper 2 detection enable"] pub fn set_tamp2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Active level for tamper 2"] pub fn tamp2trg (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Active level for tamper 2"] pub fn set_tamp2trg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Activate timestamp on tamper detection\n              event"] pub fn tampts (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Activate timestamp on tamper detection\n              event"] pub fn set_tampts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Tamper sampling frequency"] pub fn tampfreq (& self) -> u32 { (self . 0 >> 8u32) & 7u32 } # [doc = "Tamper sampling frequency"] pub fn set_tampfreq (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Tamper filter count"] pub fn tampflt (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Tamper filter count"] pub fn set_tampflt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Tamper precharge duration"] pub fn tampprch (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Tamper precharge duration"] pub fn set_tampprch (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "TAMPER pull-up disable"] pub fn tamppudis (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "TAMPER pull-up disable"] pub fn set_tamppudis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "TAMPER1 mapping"] pub fn tamp1insel (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "TAMPER1 mapping"] pub fn set_tamp1insel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "TIMESTAMP mapping"] pub fn tsinsel (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "TIMESTAMP mapping"] pub fn set_tsinsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "AFO_ALARM output type"] pub fn alarmouttype (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "AFO_ALARM output type"] pub fn set_alarmouttype (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "alarm A sub second register"] pub struct ALRMASSR (u32) ; impl ALRMASSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sub seconds value"] pub fn ss (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Sub seconds value"] pub fn set_ss (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Mask the most-significant bits starting\n              at this bit"] pub fn maskss (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Mask the most-significant bits starting\n              at this bit"] pub fn set_maskss (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "alarm B sub second register"] pub struct ALRMBSSR (u32) ; impl ALRMBSSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sub seconds value"] pub fn ss (& self) -> u32 { (self . 0 >> 0u32) & 32767u32 } # [doc = "Sub seconds value"] pub fn set_ss (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Mask the most-significant bits starting\n              at this bit"] pub fn maskss (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Mask the most-significant bits starting\n              at this bit"] pub fn set_maskss (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP0R (u32) ; impl BKP0R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP1R (u32) ; impl BKP1R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP2R (u32) ; impl BKP2R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP3R (u32) ; impl BKP3R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP4R (u32) ; impl BKP4R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP5R (u32) ; impl BKP5R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP6R (u32) ; impl BKP6R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP7R (u32) ; impl BKP7R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP8R (u32) ; impl BKP8R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP9R (u32) ; impl BKP9R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP10R (u32) ; impl BKP10R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP11R (u32) ; impl BKP11R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP12R (u32) ; impl BKP12R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP13R (u32) ; impl BKP13R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP14R (u32) ; impl BKP14R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP15R (u32) ; impl BKP15R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP16R (u32) ; impl BKP16R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP17R (u32) ; impl BKP17R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP18R (u32) ; impl BKP18R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "backup register"] pub struct BKP19R (u32) ; impl BKP19R { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "BKP"] pub fn bkp (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "BKP"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim9 { # [doc = "General purpose timers"] pub struct TIM9 ; impl TIM9 { pub const BASE_ADDR : u64 = 1073823744u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output Compare 1 fast\n              enable"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output Compare 1 fast\n              enable"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output Compare 1 preload\n              enable"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output Compare 1 preload\n              enable"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output Compare 1 mode"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output Compare 1 mode"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output Compare 2 fast\n              enable"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output Compare 2 fast\n              enable"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output Compare 2 preload\n              enable"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output Compare 2 preload\n              enable"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output Compare 2 mode"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Output Compare 2 mode"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "counter value"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "counter value"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Auto-reload value"] pub fn arr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Auto-reload value"] pub fn set_arr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 value"] pub fn ccr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 1 value"] pub fn set_ccr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 2 value"] pub fn ccr2 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 2 value"] pub fn set_ccr2 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim2 { # [doc = "General purpose timers"] pub struct TIM2 ; impl TIM2 { pub const BASE_ADDR : u64 = 1073741824u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC1S"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC1S"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC1FE"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC1FE"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC1PE"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC1PE"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC1M"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC1M"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC1CE"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC1CE"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC2S"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC2S"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC2FE"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC2FE"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC2PE"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC2PE"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC2M"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC2M"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC2CE"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC2CE"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC3S"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC3S"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC3FE"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC3FE"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC3PE"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC3PE"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC3M"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC3M"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC3CE"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC3CE"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC4S"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC4S"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC4FE"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC4FE"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC4PE"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC4PE"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC4M"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC4M"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC4CE"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC4CE"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn cc4np (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn set_cc4np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low counter value"] pub fn cnt_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low counter value"] pub fn set_cnt_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High counter value"] pub fn cnt_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High counter value"] pub fn set_cnt_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Auto-reload value"] pub fn arr_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Auto-reload value"] pub fn set_arr_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Auto-reload value"] pub fn arr_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Auto-reload value"] pub fn set_arr_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 1\n              value"] pub fn ccr1_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 1\n              value"] pub fn set_ccr1_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 1\n              value"] pub fn ccr1_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 1\n              value"] pub fn set_ccr1_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 2\n              value"] pub fn ccr2_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 2\n              value"] pub fn set_ccr2_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 2\n              value"] pub fn ccr2_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 2\n              value"] pub fn set_ccr2_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr3_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr3_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr3_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr3_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr4_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr4_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr4_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr4_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TIM5 option register"] pub struct OR (u32) ; impl OR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer Input 4 remap"] pub fn itr1_rmp (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Timer Input 4 remap"] pub fn set_itr1_rmp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim5 { # [doc = "General-purpose-timers"] pub struct TIM5 ; impl TIM5 { pub const BASE_ADDR : u64 = 1073744896u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC1S"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC1S"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC1FE"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC1FE"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC1PE"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC1PE"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC1M"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC1M"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC1CE"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC1CE"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC2S"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC2S"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC2FE"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC2FE"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC2PE"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC2PE"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC2M"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC2M"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC2CE"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC2CE"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC3S"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC3S"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC3FE"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC3FE"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC3PE"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC3PE"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC3M"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC3M"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC3CE"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC3CE"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC4S"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC4S"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC4FE"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC4FE"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC4PE"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC4PE"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC4M"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC4M"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC4CE"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC4CE"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn cc4np (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn set_cc4np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low counter value"] pub fn cnt_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low counter value"] pub fn set_cnt_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High counter value"] pub fn cnt_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High counter value"] pub fn set_cnt_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Auto-reload value"] pub fn arr_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Auto-reload value"] pub fn set_arr_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Auto-reload value"] pub fn arr_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Auto-reload value"] pub fn set_arr_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 1\n              value"] pub fn ccr1_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 1\n              value"] pub fn set_ccr1_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 1\n              value"] pub fn ccr1_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 1\n              value"] pub fn set_ccr1_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 2\n              value"] pub fn ccr2_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 2\n              value"] pub fn set_ccr2_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 2\n              value"] pub fn ccr2_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 2\n              value"] pub fn set_ccr2_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr3_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr3_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr3_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr3_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr4_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr4_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr4_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr4_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TIM5 option register"] pub struct OR (u32) ; impl OR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Timer Input 4 remap"] pub fn it4_rmp (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Timer Input 4 remap"] pub fn set_it4_rmp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2c2 { # [doc = "Inter-integrated circuit"] pub struct I2C2 ; impl I2C2 { pub const BASE_ADDR : u64 = 1073764352u64 ; } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral enable"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Peripheral enable"] pub fn set_pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SMBus mode"] pub fn smbus (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "SMBus mode"] pub fn set_smbus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SMBus type"] pub fn smbtype (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "SMBus type"] pub fn set_smbtype (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ARP enable"] pub fn enarp (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ARP enable"] pub fn set_enarp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PEC enable"] pub fn enpec (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "PEC enable"] pub fn set_enpec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "General call enable"] pub fn engc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "General call enable"] pub fn set_engc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn nostretch (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn set_nostretch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Start generation"] pub fn start (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Start generation"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stop generation"] pub fn stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stop generation"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge enable"] pub fn ack (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge enable"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn pos (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn set_pos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Packet error checking"] pub fn pec (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Packet error checking"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "SMBus alert"] pub fn alert (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_alert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Software reset"] pub fn swrst (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Software reset"] pub fn set_swrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral clock frequency"] pub fn freq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Peripheral clock frequency"] pub fn set_freq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Error interrupt enable"] pub fn iterren (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_iterren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Event interrupt enable"] pub fn itevten (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Event interrupt enable"] pub fn set_itevten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Buffer interrupt enable"] pub fn itbufen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer interrupt enable"] pub fn set_itbufen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "DMA requests enable"] pub fn dmaen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "DMA requests enable"] pub fn set_dmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "DMA last transfer"] pub fn last (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "DMA last transfer"] pub fn set_last (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 1"] pub struct OAR1 (u32) ; impl OAR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interface address"] pub fn add0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Interface address"] pub fn set_add0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add7 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add7 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Interface address"] pub fn add10 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Interface address"] pub fn set_add10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Addressing mode (slave\n              mode)"] pub fn addmode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Addressing mode (slave\n              mode)"] pub fn set_addmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 2"] pub struct OAR2 (u32) ; impl OAR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Dual addressing mode\n              enable"] pub fn endual (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Dual addressing mode\n              enable"] pub fn set_endual (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add2 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add2 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "8-bit data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "8-bit data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 1"] pub struct SR1 (u32) ; impl SR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start bit (Master mode)"] pub fn sb (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Address sent (master mode)/matched\n              (slave mode)"] pub fn addr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Byte transfer finished"] pub fn btf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "10-bit header sent (Master\n              mode)"] pub fn add10 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stop detection (slave\n              mode)"] pub fn stopf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Data register not empty\n              (receivers)"] pub fn rxne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Data register empty\n              (transmitters)"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Bus error"] pub fn berr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Bus error"] pub fn set_berr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Arbitration lost (master\n              mode)"] pub fn arlo (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Arbitration lost (master\n              mode)"] pub fn set_arlo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge failure"] pub fn af (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge failure"] pub fn set_af (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Overrun/Underrun"] pub fn ovr (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Overrun/Underrun"] pub fn set_ovr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "PEC Error in reception"] pub fn pecerr (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "PEC Error in reception"] pub fn set_pecerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Timeout or Tlow error"] pub fn timeout (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Timeout or Tlow error"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SMBus alert"] pub fn smbalert (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_smbalert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 2"] pub struct SR2 (u32) ; impl SR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master/slave"] pub fn msl (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Master/slave"] pub fn set_msl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Bus busy"] pub fn busy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Bus busy"] pub fn set_busy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transmitter/receiver"] pub fn tra (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transmitter/receiver"] pub fn set_tra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "General call address (Slave\n              mode)"] pub fn gencall (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "General call address (Slave\n              mode)"] pub fn set_gencall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn smbdefault (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn set_smbdefault (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "SMBus host header (Slave\n              mode)"] pub fn smbhost (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SMBus host header (Slave\n              mode)"] pub fn set_smbhost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Dual flag (Slave mode)"] pub fn dualf (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Dual flag (Slave mode)"] pub fn set_dualf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "acket error checking\n              register"] pub fn pec (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "acket error checking\n              register"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control register"] pub struct CCR (u32) ; impl CCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn ccr (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn set_ccr (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Fast mode duty cycle"] pub fn duty (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Fast mode duty cycle"] pub fn set_duty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "I2C master mode selection"] pub fn f_s (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "I2C master mode selection"] pub fn set_f_s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TRISE register"] pub struct TRISE (u32) ; impl TRISE { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn trise (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn set_trise (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod crc { # [doc = "Cryptographic processor"] pub struct CRC ; impl CRC { pub const BASE_ADDR : u64 = 1073885184u64 ; } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 4294967295u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data Register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data Register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Independent Data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Independent Data register"] pub fn idr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Independent Data register"] pub fn set_idr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Control regidter"] pub fn cr (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Control regidter"] pub fn set_cr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2s3ext { # [doc = "Serial peripheral interface"] pub struct I2S3ext ; impl I2S3ext { pub const BASE_ADDR : u64 = 1073758208u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim8 { # [doc = "Advanced-timers"] pub struct TIM8 ; impl TIM8 { pub const BASE_ADDR : u64 = 1073808384u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare preloaded\n              control"] pub fn ccpc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/compare preloaded\n              control"] pub fn set_ccpc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare control update\n              selection"] pub fn ccus (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare control update\n              selection"] pub fn set_ccus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Output Idle state 1"] pub fn ois1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Output Idle state 1"] pub fn set_ois1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output Idle state 1"] pub fn ois1n (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Output Idle state 1"] pub fn set_ois1n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Output Idle state 2"] pub fn ois2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output Idle state 2"] pub fn set_ois2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output Idle state 2"] pub fn ois2n (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output Idle state 2"] pub fn set_ois2n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output Idle state 3"] pub fn ois3 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Output Idle state 3"] pub fn set_ois3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output Idle state 3"] pub fn ois3n (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Output Idle state 3"] pub fn set_ois3n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output Idle state 4"] pub fn ois4 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output Idle state 4"] pub fn set_ois4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "COM interrupt enable"] pub fn comie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "COM interrupt enable"] pub fn set_comie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break interrupt enable"] pub fn bie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break interrupt enable"] pub fn set_bie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "COM DMA request enable"] pub fn comde (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "COM DMA request enable"] pub fn set_comde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "COM interrupt flag"] pub fn comif (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "COM interrupt flag"] pub fn set_comif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break interrupt flag"] pub fn bif (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break interrupt flag"] pub fn set_bif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare control update\n              generation"] pub fn comg (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare control update\n              generation"] pub fn set_comg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break generation"] pub fn bg (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break generation"] pub fn set_bg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output Compare 1 fast\n              enable"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output Compare 1 fast\n              enable"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output Compare 1 preload\n              enable"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output Compare 1 preload\n              enable"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output Compare 1 mode"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output Compare 1 mode"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Output Compare 1 clear\n              enable"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output Compare 1 clear\n              enable"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output Compare 2 fast\n              enable"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output Compare 2 fast\n              enable"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output Compare 2 preload\n              enable"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output Compare 2 preload\n              enable"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output Compare 2 mode"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Output Compare 2 mode"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output Compare 2 clear\n              enable"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Output Compare 2 clear\n              enable"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output compare 3 fast\n              enable"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output compare 3 fast\n              enable"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output compare 3 preload\n              enable"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output compare 3 preload\n              enable"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output compare 3 mode"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output compare 3 mode"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Output compare 3 clear\n              enable"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output compare 3 clear\n              enable"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output compare 4 fast\n              enable"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output compare 4 fast\n              enable"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output compare 4 preload\n              enable"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output compare 4 preload\n              enable"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output compare 4 mode"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Output compare 4 mode"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output compare 4 clear\n              enable"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Output compare 4 clear\n              enable"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 complementary output\n              enable"] pub fn cc1ne (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 1 complementary output\n              enable"] pub fn set_cc1ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 complementary output\n              enable"] pub fn cc2ne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Capture/Compare 2 complementary output\n              enable"] pub fn set_cc2ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 complementary output\n              enable"] pub fn cc3ne (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 3 complementary output\n              enable"] pub fn set_cc3ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "counter value"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "counter value"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Auto-reload value"] pub fn arr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Auto-reload value"] pub fn set_arr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "repetition counter register"] pub struct RCR (u32) ; impl RCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Repetition counter value"] pub fn rep (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Repetition counter value"] pub fn set_rep (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 value"] pub fn ccr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 1 value"] pub fn set_ccr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 2 value"] pub fn ccr2 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 2 value"] pub fn set_ccr2 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn ccr3 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare value"] pub fn set_ccr3 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn ccr4 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare value"] pub fn set_ccr4 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "break and dead-time register"] pub struct BDTR (u32) ; impl BDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Dead-time generator setup"] pub fn dtg (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Dead-time generator setup"] pub fn set_dtg (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Lock configuration"] pub fn lock (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Lock configuration"] pub fn set_lock (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Off-state selection for Idle\n              mode"] pub fn ossi (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Off-state selection for Idle\n              mode"] pub fn set_ossi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Off-state selection for Run\n              mode"] pub fn ossr (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Off-state selection for Run\n              mode"] pub fn set_ossr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Break enable"] pub fn bke (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Break enable"] pub fn set_bke (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Break polarity"] pub fn bkp (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Break polarity"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Automatic output enable"] pub fn aoe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Automatic output enable"] pub fn set_aoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Main output enable"] pub fn moe (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Main output enable"] pub fn set_moe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod rcc { # [doc = "Reset and clock control"] pub struct RCC ; impl RCC { pub const BASE_ADDR : u64 = 1073887232u64 ; } # [doc = "clock control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 131u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Internal high-speed clock\n              enable"] pub fn hsion (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Internal high-speed clock\n              enable"] pub fn set_hsion (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Internal high-speed clock ready\n              flag"] pub fn hsirdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Internal high-speed clock\n              trimming"] pub fn hsitrim (& self) -> u32 { (self . 0 >> 3u32) & 31u32 } # [doc = "Internal high-speed clock\n              trimming"] pub fn set_hsitrim (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Internal high-speed clock\n              calibration"] pub fn hsical (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "HSE clock enable"] pub fn hseon (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "HSE clock enable"] pub fn set_hseon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "HSE clock ready flag"] pub fn hserdy (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "HSE clock bypass"] pub fn hsebyp (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "HSE clock bypass"] pub fn set_hsebyp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Clock security system\n              enable"] pub fn csson (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Clock security system\n              enable"] pub fn set_csson (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Main PLL (PLL) enable"] pub fn pllon (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Main PLL (PLL) enable"] pub fn set_pllon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Main PLL (PLL) clock ready\n              flag"] pub fn pllrdy (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "PLLI2S enable"] pub fn plli2son (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "PLLI2S enable"] pub fn set_plli2son (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "PLLI2S clock ready flag"] pub fn plli2srdy (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PLL configuration register"] pub struct PLLCFGR (u32) ; impl PLLCFGR { pub const RESET_VALUE : u32 = 603992080u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn pllm5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Division factor for the main PLL (PLL)\n              and audio PLL (PLLI2S) input clock"] pub fn set_pllm5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln0 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln1 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln3 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln4 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln6 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln7 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn plln8 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Main PLL (PLL) multiplication factor for\n              VCO"] pub fn set_plln8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Main PLL (PLL) division factor for main\n              system clock"] pub fn pllp0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for main\n              system clock"] pub fn set_pllp0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Main PLL (PLL) division factor for main\n              system clock"] pub fn pllp1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for main\n              system clock"] pub fn set_pllp1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Main PLL(PLL) and audio PLL (PLLI2S)\n              entry clock source"] pub fn pllsrc (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Main PLL(PLL) and audio PLL (PLLI2S)\n              entry clock source"] pub fn set_pllsrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn pllq0 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn set_pllq0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn pllq1 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn set_pllq1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn pllq2 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn set_pllq2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn pllq3 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Main PLL (PLL) division factor for USB\n              OTG FS, SDIO and random number generator\n              clocks"] pub fn set_pllq3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "clock configuration register"] pub struct CFGR (u32) ; impl CFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "System clock switch"] pub fn sw0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "System clock switch"] pub fn set_sw0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "System clock switch"] pub fn sw1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "System clock switch"] pub fn set_sw1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "System clock switch status"] pub fn sws0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "System clock switch status"] pub fn sws1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "AHB prescaler"] pub fn hpre (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "AHB prescaler"] pub fn set_hpre (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "APB Low speed prescaler\n              (APB1)"] pub fn ppre1 (& self) -> u32 { (self . 0 >> 10u32) & 7u32 } # [doc = "APB Low speed prescaler\n              (APB1)"] pub fn set_ppre1 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "APB high-speed prescaler\n              (APB2)"] pub fn ppre2 (& self) -> u32 { (self . 0 >> 13u32) & 7u32 } # [doc = "APB high-speed prescaler\n              (APB2)"] pub fn set_ppre2 (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "HSE division factor for RTC\n              clock"] pub fn rtcpre (& self) -> u32 { (self . 0 >> 16u32) & 31u32 } # [doc = "HSE division factor for RTC\n              clock"] pub fn set_rtcpre (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Microcontroller clock output\n              1"] pub fn mco1 (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Microcontroller clock output\n              1"] pub fn set_mco1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "I2S clock selection"] pub fn i2ssrc (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "I2S clock selection"] pub fn set_i2ssrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "MCO1 prescaler"] pub fn mco1pre (& self) -> u32 { (self . 0 >> 24u32) & 7u32 } # [doc = "MCO1 prescaler"] pub fn set_mco1pre (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "MCO2 prescaler"] pub fn mco2pre (& self) -> u32 { (self . 0 >> 27u32) & 7u32 } # [doc = "MCO2 prescaler"] pub fn set_mco2pre (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Microcontroller clock output\n              2"] pub fn mco2 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Microcontroller clock output\n              2"] pub fn set_mco2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "clock interrupt register"] pub struct CIR (u32) ; impl CIR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "LSI ready interrupt flag"] pub fn lsirdyf (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "LSE ready interrupt flag"] pub fn lserdyf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HSI ready interrupt flag"] pub fn hsirdyf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "HSE ready interrupt flag"] pub fn hserdyf (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Main PLL (PLL) ready interrupt\n              flag"] pub fn pllrdyf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "PLLI2S ready interrupt\n              flag"] pub fn plli2srdyf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Clock security system interrupt\n              flag"] pub fn cssf (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "LSI ready interrupt enable"] pub fn lsirdyie (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "LSI ready interrupt enable"] pub fn set_lsirdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "LSE ready interrupt enable"] pub fn lserdyie (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "LSE ready interrupt enable"] pub fn set_lserdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "HSI ready interrupt enable"] pub fn hsirdyie (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "HSI ready interrupt enable"] pub fn set_hsirdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "HSE ready interrupt enable"] pub fn hserdyie (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "HSE ready interrupt enable"] pub fn set_hserdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Main PLL (PLL) ready interrupt\n              enable"] pub fn pllrdyie (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Main PLL (PLL) ready interrupt\n              enable"] pub fn set_pllrdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "PLLI2S ready interrupt\n              enable"] pub fn plli2srdyie (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "PLLI2S ready interrupt\n              enable"] pub fn set_plli2srdyie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "LSI ready interrupt clear"] pub fn lsirdyc (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "LSI ready interrupt clear"] pub fn set_lsirdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "LSE ready interrupt clear"] pub fn lserdyc (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "LSE ready interrupt clear"] pub fn set_lserdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "HSI ready interrupt clear"] pub fn hsirdyc (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "HSI ready interrupt clear"] pub fn set_hsirdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "HSE ready interrupt clear"] pub fn hserdyc (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "HSE ready interrupt clear"] pub fn set_hserdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Main PLL(PLL) ready interrupt\n              clear"] pub fn pllrdyc (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Main PLL(PLL) ready interrupt\n              clear"] pub fn set_pllrdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "PLLI2S ready interrupt\n              clear"] pub fn plli2srdyc (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "PLLI2S ready interrupt\n              clear"] pub fn set_plli2srdyc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Clock security system interrupt\n              clear"] pub fn cssc (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Clock security system interrupt\n              clear"] pub fn set_cssc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB1 peripheral reset register"] pub struct AHB1RSTR (u32) ; impl AHB1RSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IO port A reset"] pub fn gpioarst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "IO port A reset"] pub fn set_gpioarst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IO port B reset"] pub fn gpiobrst (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IO port B reset"] pub fn set_gpiobrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IO port C reset"] pub fn gpiocrst (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IO port C reset"] pub fn set_gpiocrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "IO port D reset"] pub fn gpiodrst (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IO port D reset"] pub fn set_gpiodrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IO port E reset"] pub fn gpioerst (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IO port E reset"] pub fn set_gpioerst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "IO port H reset"] pub fn gpiohrst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "IO port H reset"] pub fn set_gpiohrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CRC reset"] pub fn crcrst (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC reset"] pub fn set_crcrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "DMA2 reset"] pub fn dma1rst (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "DMA2 reset"] pub fn set_dma1rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "DMA2 reset"] pub fn dma2rst (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "DMA2 reset"] pub fn set_dma2rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB2 peripheral reset register"] pub struct AHB2RSTR (u32) ; impl AHB2RSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "USB OTG FS module reset"] pub fn otgfsrst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "USB OTG FS module reset"] pub fn set_otgfsrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB1 peripheral reset register"] pub struct APB1RSTR (u32) ; impl APB1RSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM2 reset"] pub fn tim2rst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM2 reset"] pub fn set_tim2rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "TIM3 reset"] pub fn tim3rst (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "TIM3 reset"] pub fn set_tim3rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TIM4 reset"] pub fn tim4rst (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "TIM4 reset"] pub fn set_tim4rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TIM5 reset"] pub fn tim5rst (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TIM5 reset"] pub fn set_tim5rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Window watchdog reset"] pub fn wwdgrst (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Window watchdog reset"] pub fn set_wwdgrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI 2 reset"] pub fn spi2rst (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "SPI 2 reset"] pub fn set_spi2rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SPI 3 reset"] pub fn spi3rst (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SPI 3 reset"] pub fn set_spi3rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "USART 2 reset"] pub fn uart2rst (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "USART 2 reset"] pub fn set_uart2rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "I2C 1 reset"] pub fn i2c1rst (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "I2C 1 reset"] pub fn set_i2c1rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "I2C 2 reset"] pub fn i2c2rst (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "I2C 2 reset"] pub fn set_i2c2rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "I2C3 reset"] pub fn i2c3rst (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "I2C3 reset"] pub fn set_i2c3rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Power interface reset"] pub fn pwrrst (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Power interface reset"] pub fn set_pwrrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB2 peripheral reset register"] pub struct APB2RSTR (u32) ; impl APB2RSTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM1 reset"] pub fn tim1rst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM1 reset"] pub fn set_tim1rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USART1 reset"] pub fn usart1rst (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "USART1 reset"] pub fn set_usart1rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "USART6 reset"] pub fn usart6rst (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "USART6 reset"] pub fn set_usart6rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "ADC interface reset (common to all\n              ADCs)"] pub fn adcrst (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "ADC interface reset (common to all\n              ADCs)"] pub fn set_adcrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "SDIO reset"] pub fn sdiorst (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "SDIO reset"] pub fn set_sdiorst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI 1 reset"] pub fn spi1rst (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "SPI 1 reset"] pub fn set_spi1rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "System configuration controller\n              reset"] pub fn syscfgrst (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "System configuration controller\n              reset"] pub fn set_syscfgrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "TIM9 reset"] pub fn tim9rst (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "TIM9 reset"] pub fn set_tim9rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "TIM10 reset"] pub fn tim10rst (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "TIM10 reset"] pub fn set_tim10rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "TIM11 reset"] pub fn tim11rst (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "TIM11 reset"] pub fn set_tim11rst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB1 peripheral clock register"] pub struct AHB1ENR (u32) ; impl AHB1ENR { pub const RESET_VALUE : u32 = 1048576u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IO port A clock enable"] pub fn gpioaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "IO port A clock enable"] pub fn set_gpioaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IO port B clock enable"] pub fn gpioben (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IO port B clock enable"] pub fn set_gpioben (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IO port C clock enable"] pub fn gpiocen (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IO port C clock enable"] pub fn set_gpiocen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "IO port D clock enable"] pub fn gpioden (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IO port D clock enable"] pub fn set_gpioden (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IO port E clock enable"] pub fn gpioeen (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IO port E clock enable"] pub fn set_gpioeen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "IO port H clock enable"] pub fn gpiohen (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "IO port H clock enable"] pub fn set_gpiohen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CRC clock enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC clock enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "DMA1 clock enable"] pub fn dma1en (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "DMA1 clock enable"] pub fn set_dma1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "DMA2 clock enable"] pub fn dma2en (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "DMA2 clock enable"] pub fn set_dma2en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB2 peripheral clock enable\n          register"] pub struct AHB2ENR (u32) ; impl AHB2ENR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "USB OTG FS clock enable"] pub fn otgfsen (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "USB OTG FS clock enable"] pub fn set_otgfsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB1 peripheral clock enable\n          register"] pub struct APB1ENR (u32) ; impl APB1ENR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM2 clock enable"] pub fn tim2en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM2 clock enable"] pub fn set_tim2en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "TIM3 clock enable"] pub fn tim3en (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "TIM3 clock enable"] pub fn set_tim3en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TIM4 clock enable"] pub fn tim4en (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "TIM4 clock enable"] pub fn set_tim4en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TIM5 clock enable"] pub fn tim5en (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TIM5 clock enable"] pub fn set_tim5en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Window watchdog clock\n              enable"] pub fn wwdgen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Window watchdog clock\n              enable"] pub fn set_wwdgen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI2 clock enable"] pub fn spi2en (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "SPI2 clock enable"] pub fn set_spi2en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SPI3 clock enable"] pub fn spi3en (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SPI3 clock enable"] pub fn set_spi3en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "USART 2 clock enable"] pub fn usart2en (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "USART 2 clock enable"] pub fn set_usart2en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "I2C1 clock enable"] pub fn i2c1en (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "I2C1 clock enable"] pub fn set_i2c1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "I2C2 clock enable"] pub fn i2c2en (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "I2C2 clock enable"] pub fn set_i2c2en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "I2C3 clock enable"] pub fn i2c3en (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "I2C3 clock enable"] pub fn set_i2c3en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Power interface clock\n              enable"] pub fn pwren (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Power interface clock\n              enable"] pub fn set_pwren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB2 peripheral clock enable\n          register"] pub struct APB2ENR (u32) ; impl APB2ENR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM1 clock enable"] pub fn tim1en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM1 clock enable"] pub fn set_tim1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USART1 clock enable"] pub fn usart1en (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "USART1 clock enable"] pub fn set_usart1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "USART6 clock enable"] pub fn usart6en (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "USART6 clock enable"] pub fn set_usart6en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "ADC1 clock enable"] pub fn adc1en (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "ADC1 clock enable"] pub fn set_adc1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "SDIO clock enable"] pub fn sdioen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "SDIO clock enable"] pub fn set_sdioen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI1 clock enable"] pub fn spi1en (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "SPI1 clock enable"] pub fn set_spi1en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "System configuration controller clock\n              enable"] pub fn syscfgen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "System configuration controller clock\n              enable"] pub fn set_syscfgen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "TIM9 clock enable"] pub fn tim9en (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "TIM9 clock enable"] pub fn set_tim9en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "TIM10 clock enable"] pub fn tim10en (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "TIM10 clock enable"] pub fn set_tim10en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "TIM11 clock enable"] pub fn tim11en (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "TIM11 clock enable"] pub fn set_tim11en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB1 peripheral clock enable in low power\n          mode register"] pub struct AHB1LPENR (u32) ; impl AHB1LPENR { pub const RESET_VALUE : u32 = 2120716799u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IO port A clock enable during sleep\n              mode"] pub fn gpioalpen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "IO port A clock enable during sleep\n              mode"] pub fn set_gpioalpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IO port B clock enable during Sleep\n              mode"] pub fn gpioblpen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IO port B clock enable during Sleep\n              mode"] pub fn set_gpioblpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IO port C clock enable during Sleep\n              mode"] pub fn gpioclpen (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IO port C clock enable during Sleep\n              mode"] pub fn set_gpioclpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "IO port D clock enable during Sleep\n              mode"] pub fn gpiodlpen (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IO port D clock enable during Sleep\n              mode"] pub fn set_gpiodlpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IO port E clock enable during Sleep\n              mode"] pub fn gpioelpen (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IO port E clock enable during Sleep\n              mode"] pub fn set_gpioelpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "IO port H clock enable during Sleep\n              mode"] pub fn gpiohlpen (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "IO port H clock enable during Sleep\n              mode"] pub fn set_gpiohlpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CRC clock enable during Sleep\n              mode"] pub fn crclpen (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC clock enable during Sleep\n              mode"] pub fn set_crclpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Flash interface clock enable during\n              Sleep mode"] pub fn flitflpen (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Flash interface clock enable during\n              Sleep mode"] pub fn set_flitflpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "SRAM 1interface clock enable during\n              Sleep mode"] pub fn sram1lpen (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "SRAM 1interface clock enable during\n              Sleep mode"] pub fn set_sram1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "DMA1 clock enable during Sleep\n              mode"] pub fn dma1lpen (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "DMA1 clock enable during Sleep\n              mode"] pub fn set_dma1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "DMA2 clock enable during Sleep\n              mode"] pub fn dma2lpen (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "DMA2 clock enable during Sleep\n              mode"] pub fn set_dma2lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "AHB2 peripheral clock enable in low power\n          mode register"] pub struct AHB2LPENR (u32) ; impl AHB2LPENR { pub const RESET_VALUE : u32 = 241u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "USB OTG FS clock enable during Sleep\n              mode"] pub fn otgfslpen (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "USB OTG FS clock enable during Sleep\n              mode"] pub fn set_otgfslpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB1 peripheral clock enable in low power\n          mode register"] pub struct APB1LPENR (u32) ; impl APB1LPENR { pub const RESET_VALUE : u32 = 922667519u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM2 clock enable during Sleep\n              mode"] pub fn tim2lpen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM2 clock enable during Sleep\n              mode"] pub fn set_tim2lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "TIM3 clock enable during Sleep\n              mode"] pub fn tim3lpen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "TIM3 clock enable during Sleep\n              mode"] pub fn set_tim3lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TIM4 clock enable during Sleep\n              mode"] pub fn tim4lpen (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "TIM4 clock enable during Sleep\n              mode"] pub fn set_tim4lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TIM5 clock enable during Sleep\n              mode"] pub fn tim5lpen (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TIM5 clock enable during Sleep\n              mode"] pub fn set_tim5lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Window watchdog clock enable during\n              Sleep mode"] pub fn wwdglpen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Window watchdog clock enable during\n              Sleep mode"] pub fn set_wwdglpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI2 clock enable during Sleep\n              mode"] pub fn spi2lpen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "SPI2 clock enable during Sleep\n              mode"] pub fn set_spi2lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SPI3 clock enable during Sleep\n              mode"] pub fn spi3lpen (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SPI3 clock enable during Sleep\n              mode"] pub fn set_spi3lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "USART2 clock enable during Sleep\n              mode"] pub fn usart2lpen (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "USART2 clock enable during Sleep\n              mode"] pub fn set_usart2lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "I2C1 clock enable during Sleep\n              mode"] pub fn i2c1lpen (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "I2C1 clock enable during Sleep\n              mode"] pub fn set_i2c1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "I2C2 clock enable during Sleep\n              mode"] pub fn i2c2lpen (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "I2C2 clock enable during Sleep\n              mode"] pub fn set_i2c2lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "I2C3 clock enable during Sleep\n              mode"] pub fn i2c3lpen (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "I2C3 clock enable during Sleep\n              mode"] pub fn set_i2c3lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Power interface clock enable during\n              Sleep mode"] pub fn pwrlpen (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Power interface clock enable during\n              Sleep mode"] pub fn set_pwrlpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "APB2 peripheral clock enabled in low power\n          mode register"] pub struct APB2LPENR (u32) ; impl APB2LPENR { pub const RESET_VALUE : u32 = 483123u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM1 clock enable during Sleep\n              mode"] pub fn tim1lpen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM1 clock enable during Sleep\n              mode"] pub fn set_tim1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USART1 clock enable during Sleep\n              mode"] pub fn usart1lpen (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "USART1 clock enable during Sleep\n              mode"] pub fn set_usart1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "USART6 clock enable during Sleep\n              mode"] pub fn usart6lpen (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "USART6 clock enable during Sleep\n              mode"] pub fn set_usart6lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "ADC1 clock enable during Sleep\n              mode"] pub fn adc1lpen (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "ADC1 clock enable during Sleep\n              mode"] pub fn set_adc1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "SDIO clock enable during Sleep\n              mode"] pub fn sdiolpen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "SDIO clock enable during Sleep\n              mode"] pub fn set_sdiolpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SPI 1 clock enable during Sleep\n              mode"] pub fn spi1lpen (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "SPI 1 clock enable during Sleep\n              mode"] pub fn set_spi1lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "System configuration controller clock\n              enable during Sleep mode"] pub fn syscfglpen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "System configuration controller clock\n              enable during Sleep mode"] pub fn set_syscfglpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "TIM9 clock enable during sleep\n              mode"] pub fn tim9lpen (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "TIM9 clock enable during sleep\n              mode"] pub fn set_tim9lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "TIM10 clock enable during Sleep\n              mode"] pub fn tim10lpen (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "TIM10 clock enable during Sleep\n              mode"] pub fn set_tim10lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "TIM11 clock enable during Sleep\n              mode"] pub fn tim11lpen (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "TIM11 clock enable during Sleep\n              mode"] pub fn set_tim11lpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Backup domain control register"] pub struct BDCR (u32) ; impl BDCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "External low-speed oscillator\n              enable"] pub fn lseon (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "External low-speed oscillator\n              enable"] pub fn set_lseon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "External low-speed oscillator\n              ready"] pub fn lserdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "External low-speed oscillator\n              bypass"] pub fn lsebyp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "External low-speed oscillator\n              bypass"] pub fn set_lsebyp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "RTC clock source selection"] pub fn rtcsel0 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "RTC clock source selection"] pub fn set_rtcsel0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "RTC clock source selection"] pub fn rtcsel1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "RTC clock source selection"] pub fn set_rtcsel1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "RTC clock enable"] pub fn rtcen (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "RTC clock enable"] pub fn set_rtcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Backup domain software\n              reset"] pub fn bdrst (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Backup domain software\n              reset"] pub fn set_bdrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "clock control & status\n          register"] pub struct CSR (u32) ; impl CSR { pub const RESET_VALUE : u32 = 234881024u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Internal low-speed oscillator\n              enable"] pub fn lsion (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Internal low-speed oscillator\n              enable"] pub fn set_lsion (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Internal low-speed oscillator\n              ready"] pub fn lsirdy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Remove reset flag"] pub fn rmvf (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Remove reset flag"] pub fn set_rmvf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "BOR reset flag"] pub fn borrstf (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "BOR reset flag"] pub fn set_borrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "PIN reset flag"] pub fn padrstf (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "PIN reset flag"] pub fn set_padrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "POR/PDR reset flag"] pub fn porrstf (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "POR/PDR reset flag"] pub fn set_porrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Software reset flag"] pub fn sftrstf (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Software reset flag"] pub fn set_sftrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Independent watchdog reset\n              flag"] pub fn wdgrstf (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Independent watchdog reset\n              flag"] pub fn set_wdgrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Window watchdog reset flag"] pub fn wwdgrstf (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Window watchdog reset flag"] pub fn set_wwdgrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Low-power reset flag"] pub fn lpwrrstf (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Low-power reset flag"] pub fn set_lpwrrstf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "spread spectrum clock generation\n          register"] pub struct SSCGR (u32) ; impl SSCGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Modulation period"] pub fn modper (& self) -> u32 { (self . 0 >> 0u32) & 8191u32 } # [doc = "Modulation period"] pub fn set_modper (& mut self , value : u32) { let value_masked = value & 8191u32 ; self . 0 &= ! (8191u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Incrementation step"] pub fn incstep (& self) -> u32 { (self . 0 >> 13u32) & 32767u32 } # [doc = "Incrementation step"] pub fn set_incstep (& mut self , value : u32) { let value_masked = value & 32767u32 ; self . 0 &= ! (32767u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Spread Select"] pub fn spreadsel (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Spread Select"] pub fn set_spreadsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Spread spectrum modulation\n              enable"] pub fn sscgen (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Spread spectrum modulation\n              enable"] pub fn set_sscgen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "PLLI2S configuration register"] pub struct PLLI2SCFGR (u32) ; impl PLLI2SCFGR { pub const RESET_VALUE : u32 = 536883200u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "PLLI2S multiplication factor for\n              VCO"] pub fn plli2snx (& self) -> u32 { (self . 0 >> 6u32) & 511u32 } # [doc = "PLLI2S multiplication factor for\n              VCO"] pub fn set_plli2snx (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "PLLI2S division factor for I2S\n              clocks"] pub fn plli2srx (& self) -> u32 { (self . 0 >> 28u32) & 7u32 } # [doc = "PLLI2S division factor for I2S\n              clocks"] pub fn set_plli2srx (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi4 { # [doc = "Serial peripheral interface"] pub struct SPI4 ; impl SPI4 { pub const BASE_ADDR : u64 = 1073820672u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2s2ext { # [doc = "Serial peripheral interface"] pub struct I2S2ext ; impl I2S2ext { pub const BASE_ADDR : u64 = 1073755136u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi1 { # [doc = "Serial peripheral interface"] pub struct SPI1 ; impl SPI1 { pub const BASE_ADDR : u64 = 1073819648u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod flash { # [doc = "FLASH"] pub struct FLASH ; impl FLASH { pub const BASE_ADDR : u64 = 1073888256u64 ; } # [doc = "Flash access control register"] pub struct ACR (u32) ; impl ACR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Latency"] pub fn latency (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Latency"] pub fn set_latency (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Prefetch enable"] pub fn prften (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Prefetch enable"] pub fn set_prften (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Instruction cache enable"] pub fn icen (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Instruction cache enable"] pub fn set_icen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data cache enable"] pub fn dcen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data cache enable"] pub fn set_dcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Instruction cache reset"] pub fn icrst (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Instruction cache reset"] pub fn set_icrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Data cache reset"] pub fn dcrst (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Data cache reset"] pub fn set_dcrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flash key register"] pub struct KEYR (u32) ; impl KEYR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FPEC key"] pub fn key (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "FPEC key"] pub fn set_key (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flash option key register"] pub struct OPTKEYR (u32) ; impl OPTKEYR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Option byte key"] pub fn optkey (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Option byte key"] pub fn set_optkey (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "End of operation"] pub fn eop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "End of operation"] pub fn set_eop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Operation error"] pub fn operr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Operation error"] pub fn set_operr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Write protection error"] pub fn wrperr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Write protection error"] pub fn set_wrperr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Programming alignment\n              error"] pub fn pgaerr (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Programming alignment\n              error"] pub fn set_pgaerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Programming parallelism\n              error"] pub fn pgperr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Programming parallelism\n              error"] pub fn set_pgperr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Programming sequence error"] pub fn pgserr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Programming sequence error"] pub fn set_pgserr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Busy"] pub fn bsy (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 2147483648u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Programming"] pub fn pg (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Programming"] pub fn set_pg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Sector Erase"] pub fn ser (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Sector Erase"] pub fn set_ser (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Mass Erase"] pub fn mer (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Mass Erase"] pub fn set_mer (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Sector number"] pub fn snb (& self) -> u32 { (self . 0 >> 3u32) & 15u32 } # [doc = "Sector number"] pub fn set_snb (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Program size"] pub fn psize (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Program size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Start"] pub fn strt (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Start"] pub fn set_strt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "End of operation interrupt\n              enable"] pub fn eopie (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "End of operation interrupt\n              enable"] pub fn set_eopie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Lock"] pub fn lock (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Lock"] pub fn set_lock (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Flash option control register"] pub struct OPTCR (u32) ; impl OPTCR { pub const RESET_VALUE : u32 = 20u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Option lock"] pub fn optlock (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Option lock"] pub fn set_optlock (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Option start"] pub fn optstrt (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Option start"] pub fn set_optstrt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "BOR reset Level"] pub fn bor_lev (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "BOR reset Level"] pub fn set_bor_lev (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "WDG_SW User option bytes"] pub fn wdg_sw (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "WDG_SW User option bytes"] pub fn set_wdg_sw (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "nRST_STOP User option\n              bytes"] pub fn nrst_stop (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "nRST_STOP User option\n              bytes"] pub fn set_nrst_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "nRST_STDBY User option\n              bytes"] pub fn nrst_stdby (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "nRST_STDBY User option\n              bytes"] pub fn set_nrst_stdby (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Read protect"] pub fn rdp (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Read protect"] pub fn set_rdp (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Not write protect"] pub fn nwrp (& self) -> u32 { (self . 0 >> 16u32) & 4095u32 } # [doc = "Not write protect"] pub fn set_nwrp (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod otg_fs_host { # [doc = "USB on the go full speed"] pub struct OTG_FS_HOST ; impl OTG_FS_HOST { pub const BASE_ADDR : u64 = 1342178304u64 ; } # [doc = "OTG_FS host configuration register\n          (OTG_FS_HCFG)"] pub struct FS_HCFG (u32) ; impl FS_HCFG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FS/LS PHY clock select"] pub fn fslspcs (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FS/LS PHY clock select"] pub fn set_fslspcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "FS- and LS-only support"] pub fn fslss (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Host frame interval\n          register"] pub struct HFIR (u32) ; impl HFIR { pub const RESET_VALUE : u32 = 60000u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Frame interval"] pub fn frivl (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Frame interval"] pub fn set_frivl (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host frame number/frame time\n          remaining register (OTG_FS_HFNUM)"] pub struct FS_HFNUM (u32) ; impl FS_HFNUM { pub const RESET_VALUE : u32 = 16383u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Frame number"] pub fn frnum (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Frame number"] pub fn set_frnum (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Frame time remaining"] pub fn ftrem (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Frame time remaining"] pub fn set_ftrem (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS_Host periodic transmit FIFO/queue\n          status register (OTG_FS_HPTXSTS)"] pub struct FS_HPTXSTS (u32) ; impl FS_HPTXSTS { pub const RESET_VALUE : u32 = 524544u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Periodic transmit data FIFO space\n              available"] pub fn ptxfsavl (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Periodic transmit data FIFO space\n              available"] pub fn set_ptxfsavl (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Periodic transmit request queue space\n              available"] pub fn ptxqsav (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Top of the periodic transmit request\n              queue"] pub fn ptxqtop (& self) -> u32 { (self . 0 >> 24u32) & 255u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Host all channels interrupt\n          register"] pub struct HAINT (u32) ; impl HAINT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel interrupts"] pub fn haint (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Channel interrupts"] pub fn set_haint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host all channels interrupt mask\n          register"] pub struct HAINTMSK (u32) ; impl HAINTMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel interrupt mask"] pub fn haintm (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Channel interrupt mask"] pub fn set_haintm (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host port control and status register\n          (OTG_FS_HPRT)"] pub struct FS_HPRT (u32) ; impl FS_HPRT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port connect status"] pub fn pcsts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port connect detected"] pub fn pcdet (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port connect detected"] pub fn set_pcdet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port enable"] pub fn pena (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port enable"] pub fn set_pena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port enable/disable change"] pub fn penchng (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port enable/disable change"] pub fn set_penchng (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port overcurrent active"] pub fn poca (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port overcurrent change"] pub fn pocchng (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port overcurrent change"] pub fn set_pocchng (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port resume"] pub fn pres (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port resume"] pub fn set_pres (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port suspend"] pub fn psusp (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port suspend"] pub fn set_psusp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port reset"] pub fn prst (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port reset"] pub fn set_prst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port line status"] pub fn plsts (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port power"] pub fn ppwr (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port power"] pub fn set_ppwr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port test control"] pub fn ptctl (& self) -> u32 { (self . 0 >> 13u32) & 15u32 } # [doc = "Port test control"] pub fn set_ptctl (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port speed"] pub fn pspd (& self) -> u32 { (self . 0 >> 17u32) & 3u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-0 characteristics\n          register (OTG_FS_HCCHAR0)"] pub struct FS_HCCHAR0 (u32) ; impl FS_HCCHAR0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-0 interrupt register\n          (OTG_FS_HCINT0)"] pub struct FS_HCINT0 (u32) ; impl FS_HCINT0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-0 mask register\n          (OTG_FS_HCINTMSK0)"] pub struct FS_HCINTMSK0 (u32) ; impl FS_HCINTMSK0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-0 transfer size\n          register"] pub struct FS_HCTSIZ0 (u32) ; impl FS_HCTSIZ0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-1 characteristics\n          register (OTG_FS_HCCHAR1)"] pub struct FS_HCCHAR1 (u32) ; impl FS_HCCHAR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-1 interrupt register\n          (OTG_FS_HCINT1)"] pub struct FS_HCINT1 (u32) ; impl FS_HCINT1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-1 mask register\n          (OTG_FS_HCINTMSK1)"] pub struct FS_HCINTMSK1 (u32) ; impl FS_HCINTMSK1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-1 transfer size\n          register"] pub struct FS_HCTSIZ1 (u32) ; impl FS_HCTSIZ1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-2 characteristics\n          register (OTG_FS_HCCHAR2)"] pub struct FS_HCCHAR2 (u32) ; impl FS_HCCHAR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-2 interrupt register\n          (OTG_FS_HCINT2)"] pub struct FS_HCINT2 (u32) ; impl FS_HCINT2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-2 mask register\n          (OTG_FS_HCINTMSK2)"] pub struct FS_HCINTMSK2 (u32) ; impl FS_HCINTMSK2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-2 transfer size\n          register"] pub struct FS_HCTSIZ2 (u32) ; impl FS_HCTSIZ2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-3 characteristics\n          register (OTG_FS_HCCHAR3)"] pub struct FS_HCCHAR3 (u32) ; impl FS_HCCHAR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-3 interrupt register\n          (OTG_FS_HCINT3)"] pub struct FS_HCINT3 (u32) ; impl FS_HCINT3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-3 mask register\n          (OTG_FS_HCINTMSK3)"] pub struct FS_HCINTMSK3 (u32) ; impl FS_HCINTMSK3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-3 transfer size\n          register"] pub struct FS_HCTSIZ3 (u32) ; impl FS_HCTSIZ3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-4 characteristics\n          register (OTG_FS_HCCHAR4)"] pub struct FS_HCCHAR4 (u32) ; impl FS_HCCHAR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-4 interrupt register\n          (OTG_FS_HCINT4)"] pub struct FS_HCINT4 (u32) ; impl FS_HCINT4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-4 mask register\n          (OTG_FS_HCINTMSK4)"] pub struct FS_HCINTMSK4 (u32) ; impl FS_HCINTMSK4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-x transfer size\n          register"] pub struct FS_HCTSIZ4 (u32) ; impl FS_HCTSIZ4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-5 characteristics\n          register (OTG_FS_HCCHAR5)"] pub struct FS_HCCHAR5 (u32) ; impl FS_HCCHAR5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-5 interrupt register\n          (OTG_FS_HCINT5)"] pub struct FS_HCINT5 (u32) ; impl FS_HCINT5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-5 mask register\n          (OTG_FS_HCINTMSK5)"] pub struct FS_HCINTMSK5 (u32) ; impl FS_HCINTMSK5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-5 transfer size\n          register"] pub struct FS_HCTSIZ5 (u32) ; impl FS_HCTSIZ5 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-6 characteristics\n          register (OTG_FS_HCCHAR6)"] pub struct FS_HCCHAR6 (u32) ; impl FS_HCCHAR6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-6 interrupt register\n          (OTG_FS_HCINT6)"] pub struct FS_HCINT6 (u32) ; impl FS_HCINT6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-6 mask register\n          (OTG_FS_HCINTMSK6)"] pub struct FS_HCINTMSK6 (u32) ; impl FS_HCINTMSK6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-6 transfer size\n          register"] pub struct FS_HCTSIZ6 (u32) ; impl FS_HCTSIZ6 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-7 characteristics\n          register (OTG_FS_HCCHAR7)"] pub struct FS_HCCHAR7 (u32) ; impl FS_HCCHAR7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 11u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Endpoint direction"] pub fn epdir (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Endpoint direction"] pub fn set_epdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Low-speed device"] pub fn lsdev (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Low-speed device"] pub fn set_lsdev (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Endpoint type"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Multicount"] pub fn mcnt (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Multicount"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 22u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Odd frame"] pub fn oddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Odd frame"] pub fn set_oddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Channel disable"] pub fn chdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Channel disable"] pub fn set_chdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Channel enable"] pub fn chena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Channel enable"] pub fn set_chena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-7 interrupt register\n          (OTG_FS_HCINT7)"] pub struct FS_HCINT7 (u32) ; impl FS_HCINT7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted"] pub fn chh (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted"] pub fn set_chh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received\n              interrupt"] pub fn stall (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received\n              interrupt"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received\n              interrupt"] pub fn nak (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received\n              interrupt"] pub fn set_nak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn ack (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transaction error"] pub fn txerr (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error"] pub fn set_txerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error"] pub fn bberr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error"] pub fn set_bberr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun"] pub fn frmor (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun"] pub fn set_frmor (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error"] pub fn dterr (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error"] pub fn set_dterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-7 mask register\n          (OTG_FS_HCINTMSK7)"] pub struct FS_HCINTMSK7 (u32) ; impl FS_HCINTMSK7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Channel halted mask"] pub fn chhm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel halted mask"] pub fn set_chhm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STALL response received interrupt\n              mask"] pub fn stallm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STALL response received interrupt\n              mask"] pub fn set_stallm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "NAK response received interrupt\n              mask"] pub fn nakm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "NAK response received interrupt\n              mask"] pub fn set_nakm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn ackm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "ACK response received/transmitted\n              interrupt mask"] pub fn set_ackm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "response received interrupt\n              mask"] pub fn nyet (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "response received interrupt\n              mask"] pub fn set_nyet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transaction error mask"] pub fn txerrm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Transaction error mask"] pub fn set_txerrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Babble error mask"] pub fn bberrm (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Babble error mask"] pub fn set_bberrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Frame overrun mask"] pub fn frmorm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Frame overrun mask"] pub fn set_frmorm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data toggle error mask"] pub fn dterrm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data toggle error mask"] pub fn set_dterrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS host channel-7 transfer size\n          register"] pub struct FS_HCTSIZ7 (u32) ; impl FS_HCTSIZ7 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod otg_fs_global { # [doc = "USB on the go full speed"] pub struct OTG_FS_GLOBAL ; impl OTG_FS_GLOBAL { pub const BASE_ADDR : u64 = 1342177280u64 ; } # [doc = "OTG_FS control and status register\n          (OTG_FS_GOTGCTL)"] pub struct FS_GOTGCTL (u32) ; impl FS_GOTGCTL { pub const RESET_VALUE : u32 = 2048u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Session request success"] pub fn srqscs (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Session request"] pub fn srq (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Session request"] pub fn set_srq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Host negotiation success"] pub fn hngscs (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "HNP request"] pub fn hnprq (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "HNP request"] pub fn set_hnprq (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Host set HNP enable"] pub fn hshnpen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Host set HNP enable"] pub fn set_hshnpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Device HNP enabled"] pub fn dhnpen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Device HNP enabled"] pub fn set_dhnpen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Connector ID status"] pub fn cidsts (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Long/short debounce time"] pub fn dbct (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "A-session valid"] pub fn asvld (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "B-session valid"] pub fn bsvld (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS interrupt register\n          (OTG_FS_GOTGINT)"] pub struct FS_GOTGINT (u32) ; impl FS_GOTGINT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Session end detected"] pub fn sedet (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Session end detected"] pub fn set_sedet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Session request success status\n              change"] pub fn srsschg (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Session request success status\n              change"] pub fn set_srsschg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Host negotiation success status\n              change"] pub fn hnsschg (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Host negotiation success status\n              change"] pub fn set_hnsschg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Host negotiation detected"] pub fn hngdet (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Host negotiation detected"] pub fn set_hngdet (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "A-device timeout change"] pub fn adtochg (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "A-device timeout change"] pub fn set_adtochg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Debounce done"] pub fn dbcdne (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Debounce done"] pub fn set_dbcdne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS AHB configuration register\n          (OTG_FS_GAHBCFG)"] pub struct FS_GAHBCFG (u32) ; impl FS_GAHBCFG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Global interrupt mask"] pub fn gint (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Global interrupt mask"] pub fn set_gint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "TxFIFO empty level"] pub fn txfelvl (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TxFIFO empty level"] pub fn set_txfelvl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Periodic TxFIFO empty\n              level"] pub fn ptxfelvl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Periodic TxFIFO empty\n              level"] pub fn set_ptxfelvl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS USB configuration register\n          (OTG_FS_GUSBCFG)"] pub struct FS_GUSBCFG (u32) ; impl FS_GUSBCFG { pub const RESET_VALUE : u32 = 2560u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FS timeout calibration"] pub fn tocal (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "FS timeout calibration"] pub fn set_tocal (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Full Speed serial transceiver\n              select"] pub fn physel (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Full Speed serial transceiver\n              select"] pub fn set_physel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "SRP-capable"] pub fn srpcap (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "SRP-capable"] pub fn set_srpcap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "HNP-capable"] pub fn hnpcap (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "HNP-capable"] pub fn set_hnpcap (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "USB turnaround time"] pub fn trdt (& self) -> u32 { (self . 0 >> 10u32) & 15u32 } # [doc = "USB turnaround time"] pub fn set_trdt (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Force host mode"] pub fn fhmod (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Force host mode"] pub fn set_fhmod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Force device mode"] pub fn fdmod (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Force device mode"] pub fn set_fdmod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Corrupt Tx packet"] pub fn ctxpkt (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Corrupt Tx packet"] pub fn set_ctxpkt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS reset register\n          (OTG_FS_GRSTCTL)"] pub struct FS_GRSTCTL (u32) ; impl FS_GRSTCTL { pub const RESET_VALUE : u32 = 536870912u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Core soft reset"] pub fn csrst (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Core soft reset"] pub fn set_csrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "HCLK soft reset"] pub fn hsrst (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "HCLK soft reset"] pub fn set_hsrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Host frame counter reset"] pub fn fcrst (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Host frame counter reset"] pub fn set_fcrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "RxFIFO flush"] pub fn rxfflsh (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "RxFIFO flush"] pub fn set_rxfflsh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TxFIFO flush"] pub fn txfflsh (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "TxFIFO flush"] pub fn set_txfflsh (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "TxFIFO number"] pub fn txfnum (& self) -> u32 { (self . 0 >> 6u32) & 31u32 } # [doc = "TxFIFO number"] pub fn set_txfnum (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "AHB master idle"] pub fn ahbidl (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS core interrupt register\n          (OTG_FS_GINTSTS)"] pub struct FS_GINTSTS (u32) ; impl FS_GINTSTS { pub const RESET_VALUE : u32 = 67108896u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Current mode of operation"] pub fn cmod (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Mode mismatch interrupt"] pub fn mmis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Mode mismatch interrupt"] pub fn set_mmis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "OTG interrupt"] pub fn otgint (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Start of frame"] pub fn sof (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Start of frame"] pub fn set_sof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "RxFIFO non-empty"] pub fn rxflvl (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Non-periodic TxFIFO empty"] pub fn nptxfe (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Global IN non-periodic NAK\n              effective"] pub fn ginakeff (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Global OUT NAK effective"] pub fn goutnakeff (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Early suspend"] pub fn esusp (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Early suspend"] pub fn set_esusp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "USB suspend"] pub fn usbsusp (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "USB suspend"] pub fn set_usbsusp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "USB reset"] pub fn usbrst (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "USB reset"] pub fn set_usbrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enumeration done"] pub fn enumdne (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enumeration done"] pub fn set_enumdne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Isochronous OUT packet dropped\n              interrupt"] pub fn isoodrp (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Isochronous OUT packet dropped\n              interrupt"] pub fn set_isoodrp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "End of periodic frame\n              interrupt"] pub fn eopf (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "End of periodic frame\n              interrupt"] pub fn set_eopf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "IN endpoint interrupt"] pub fn iepint (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "OUT endpoint interrupt"] pub fn oepint (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Incomplete isochronous IN\n              transfer"] pub fn iisoixfr (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Incomplete isochronous IN\n              transfer"] pub fn set_iisoixfr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Incomplete periodic transfer(Host\n              mode)/Incomplete isochronous OUT transfer(Device\n              mode)"] pub fn ipxfr_incompisoout (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Incomplete periodic transfer(Host\n              mode)/Incomplete isochronous OUT transfer(Device\n              mode)"] pub fn set_ipxfr_incompisoout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Host port interrupt"] pub fn hprtint (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Host channels interrupt"] pub fn hcint (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Periodic TxFIFO empty"] pub fn ptxfe (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Connector ID status change"] pub fn cidschg (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Connector ID status change"] pub fn set_cidschg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Disconnect detected\n              interrupt"] pub fn discint (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Disconnect detected\n              interrupt"] pub fn set_discint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Session request/new session detected\n              interrupt"] pub fn srqint (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Session request/new session detected\n              interrupt"] pub fn set_srqint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Resume/remote wakeup detected\n              interrupt"] pub fn wkupint (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Resume/remote wakeup detected\n              interrupt"] pub fn set_wkupint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS interrupt mask register\n          (OTG_FS_GINTMSK)"] pub struct FS_GINTMSK (u32) ; impl FS_GINTMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Mode mismatch interrupt\n              mask"] pub fn mmism (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Mode mismatch interrupt\n              mask"] pub fn set_mmism (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "OTG interrupt mask"] pub fn otgint (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OTG interrupt mask"] pub fn set_otgint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Start of frame mask"] pub fn sofm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Start of frame mask"] pub fn set_sofm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Receive FIFO non-empty\n              mask"] pub fn rxflvlm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Receive FIFO non-empty\n              mask"] pub fn set_rxflvlm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Non-periodic TxFIFO empty\n              mask"] pub fn nptxfem (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Non-periodic TxFIFO empty\n              mask"] pub fn set_nptxfem (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Global non-periodic IN NAK effective\n              mask"] pub fn ginakeffm (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Global non-periodic IN NAK effective\n              mask"] pub fn set_ginakeffm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Global OUT NAK effective\n              mask"] pub fn gonakeffm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Global OUT NAK effective\n              mask"] pub fn set_gonakeffm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Early suspend mask"] pub fn esuspm (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Early suspend mask"] pub fn set_esuspm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "USB suspend mask"] pub fn usbsuspm (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "USB suspend mask"] pub fn set_usbsuspm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "USB reset mask"] pub fn usbrst (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "USB reset mask"] pub fn set_usbrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Enumeration done mask"] pub fn enumdnem (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Enumeration done mask"] pub fn set_enumdnem (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Isochronous OUT packet dropped interrupt\n              mask"] pub fn isoodrpm (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Isochronous OUT packet dropped interrupt\n              mask"] pub fn set_isoodrpm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "End of periodic frame interrupt\n              mask"] pub fn eopfm (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "End of periodic frame interrupt\n              mask"] pub fn set_eopfm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Endpoint mismatch interrupt\n              mask"] pub fn epmism (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Endpoint mismatch interrupt\n              mask"] pub fn set_epmism (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "IN endpoints interrupt\n              mask"] pub fn iepint (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "IN endpoints interrupt\n              mask"] pub fn set_iepint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "OUT endpoints interrupt\n              mask"] pub fn oepint (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "OUT endpoints interrupt\n              mask"] pub fn set_oepint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Incomplete isochronous IN transfer\n              mask"] pub fn iisoixfrm (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Incomplete isochronous IN transfer\n              mask"] pub fn set_iisoixfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Incomplete periodic transfer mask(Host\n              mode)/Incomplete isochronous OUT transfer mask(Device\n              mode)"] pub fn ipxfrm_iisooxfrm (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Incomplete periodic transfer mask(Host\n              mode)/Incomplete isochronous OUT transfer mask(Device\n              mode)"] pub fn set_ipxfrm_iisooxfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Host port interrupt mask"] pub fn prtim (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Host channels interrupt\n              mask"] pub fn hcim (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Host channels interrupt\n              mask"] pub fn set_hcim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Periodic TxFIFO empty mask"] pub fn ptxfem (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Periodic TxFIFO empty mask"] pub fn set_ptxfem (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Connector ID status change\n              mask"] pub fn cidschgm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Connector ID status change\n              mask"] pub fn set_cidschgm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Disconnect detected interrupt\n              mask"] pub fn discint (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Disconnect detected interrupt\n              mask"] pub fn set_discint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Session request/new session detected\n              interrupt mask"] pub fn srqim (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Session request/new session detected\n              interrupt mask"] pub fn set_srqim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Resume/remote wakeup detected interrupt\n              mask"] pub fn wuim (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Resume/remote wakeup detected interrupt\n              mask"] pub fn set_wuim (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Receive status debug read(Device\n          mode)"] pub struct FS_GRXSTSR_Device (u32) ; impl FS_GRXSTSR_Device { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Byte count"] pub fn bcnt (& self) -> u32 { (self . 0 >> 4u32) & 2047u32 } # [doc = "Byte count"] pub fn set_bcnt (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 15u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Packet status"] pub fn pktsts (& self) -> u32 { (self . 0 >> 17u32) & 15u32 } # [doc = "Packet status"] pub fn set_pktsts (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Frame number"] pub fn frmnum (& self) -> u32 { (self . 0 >> 21u32) & 15u32 } # [doc = "Frame number"] pub fn set_frmnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Receive status debug read(Host\n          mode)"] pub struct FS_GRXSTSR_Host (u32) ; impl FS_GRXSTSR_Host { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Endpoint number"] pub fn epnum (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Endpoint number"] pub fn set_epnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Byte count"] pub fn bcnt (& self) -> u32 { (self . 0 >> 4u32) & 2047u32 } # [doc = "Byte count"] pub fn set_bcnt (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Data PID"] pub fn dpid (& self) -> u32 { (self . 0 >> 15u32) & 3u32 } # [doc = "Data PID"] pub fn set_dpid (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Packet status"] pub fn pktsts (& self) -> u32 { (self . 0 >> 17u32) & 15u32 } # [doc = "Packet status"] pub fn set_pktsts (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Frame number"] pub fn frmnum (& self) -> u32 { (self . 0 >> 21u32) & 15u32 } # [doc = "Frame number"] pub fn set_frmnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Receive FIFO size register\n          (OTG_FS_GRXFSIZ)"] pub struct FS_GRXFSIZ (u32) ; impl FS_GRXFSIZ { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "RxFIFO depth"] pub fn rxfd (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "RxFIFO depth"] pub fn set_rxfd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS non-periodic transmit FIFO size\n          register (Device mode)"] pub struct FS_GNPTXFSIZ_Device (u32) ; impl FS_GNPTXFSIZ_Device { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Endpoint 0 transmit RAM start\n              address"] pub fn tx0fsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Endpoint 0 transmit RAM start\n              address"] pub fn set_tx0fsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint 0 TxFIFO depth"] pub fn tx0fd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Endpoint 0 TxFIFO depth"] pub fn set_tx0fd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS non-periodic transmit FIFO size\n          register (Host mode)"] pub struct FS_GNPTXFSIZ_Host (u32) ; impl FS_GNPTXFSIZ_Host { pub const RESET_VALUE : u32 = 512u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Non-periodic transmit RAM start\n              address"] pub fn nptxfsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Non-periodic transmit RAM start\n              address"] pub fn set_nptxfsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Non-periodic TxFIFO depth"] pub fn nptxfd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Non-periodic TxFIFO depth"] pub fn set_nptxfd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS non-periodic transmit FIFO/queue\n          status register (OTG_FS_GNPTXSTS)"] pub struct FS_GNPTXSTS (u32) ; impl FS_GNPTXSTS { pub const RESET_VALUE : u32 = 524800u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Non-periodic TxFIFO space\n              available"] pub fn nptxfsav (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Non-periodic TxFIFO space\n              available"] pub fn set_nptxfsav (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Non-periodic transmit request queue\n              space available"] pub fn nptqxsav (& self) -> u32 { (self . 0 >> 16u32) & 255u32 } # [doc = "Non-periodic transmit request queue\n              space available"] pub fn set_nptqxsav (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Top of the non-periodic transmit request\n              queue"] pub fn nptxqtop (& self) -> u32 { (self . 0 >> 24u32) & 127u32 } # [doc = "Top of the non-periodic transmit request\n              queue"] pub fn set_nptxqtop (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS general core configuration register\n          (OTG_FS_GCCFG)"] pub struct FS_GCCFG (u32) ; impl FS_GCCFG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Power down"] pub fn pwrdwn (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Power down"] pub fn set_pwrdwn (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Enable the VBUS sensing\n              device"] pub fn vbusasen (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Enable the VBUS sensing\n              device"] pub fn set_vbusasen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Enable the VBUS sensing\n              device"] pub fn vbusbsen (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Enable the VBUS sensing\n              device"] pub fn set_vbusbsen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "SOF output enable"] pub fn sofouten (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "SOF output enable"] pub fn set_sofouten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "core ID register"] pub struct FS_CID (u32) ; impl FS_CID { pub const RESET_VALUE : u32 = 4096u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Product ID field"] pub fn product_id (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Product ID field"] pub fn set_product_id (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS Host periodic transmit FIFO size\n          register (OTG_FS_HPTXFSIZ)"] pub struct FS_HPTXFSIZ (u32) ; impl FS_HPTXFSIZ { pub const RESET_VALUE : u32 = 33555968u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Host periodic TxFIFO start\n              address"] pub fn ptxsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Host periodic TxFIFO start\n              address"] pub fn set_ptxsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Host periodic TxFIFO depth"] pub fn ptxfsiz (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "Host periodic TxFIFO depth"] pub fn set_ptxfsiz (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO size\n          register (OTG_FS_DIEPTXF2)"] pub struct FS_DIEPTXF1 (u32) ; impl FS_DIEPTXF1 { pub const RESET_VALUE : u32 = 33555456u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint FIFO2 transmit RAM start\n              address"] pub fn ineptxsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint FIFO2 transmit RAM start\n              address"] pub fn set_ineptxsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IN endpoint TxFIFO depth"] pub fn ineptxfd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "IN endpoint TxFIFO depth"] pub fn set_ineptxfd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO size\n          register (OTG_FS_DIEPTXF3)"] pub struct FS_DIEPTXF2 (u32) ; impl FS_DIEPTXF2 { pub const RESET_VALUE : u32 = 33555456u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint FIFO3 transmit RAM start\n              address"] pub fn ineptxsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint FIFO3 transmit RAM start\n              address"] pub fn set_ineptxsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IN endpoint TxFIFO depth"] pub fn ineptxfd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "IN endpoint TxFIFO depth"] pub fn set_ineptxfd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO size\n          register (OTG_FS_DIEPTXF4)"] pub struct FS_DIEPTXF3 (u32) ; impl FS_DIEPTXF3 { pub const RESET_VALUE : u32 = 33555456u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint FIFO4 transmit RAM start\n              address"] pub fn ineptxsa (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint FIFO4 transmit RAM start\n              address"] pub fn set_ineptxsa (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IN endpoint TxFIFO depth"] pub fn ineptxfd (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "IN endpoint TxFIFO depth"] pub fn set_ineptxfd (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2c1 { # [doc = "Inter-integrated circuit"] pub struct I2C1 ; impl I2C1 { pub const BASE_ADDR : u64 = 1073763328u64 ; } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral enable"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Peripheral enable"] pub fn set_pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SMBus mode"] pub fn smbus (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "SMBus mode"] pub fn set_smbus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SMBus type"] pub fn smbtype (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "SMBus type"] pub fn set_smbtype (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ARP enable"] pub fn enarp (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ARP enable"] pub fn set_enarp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PEC enable"] pub fn enpec (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "PEC enable"] pub fn set_enpec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "General call enable"] pub fn engc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "General call enable"] pub fn set_engc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn nostretch (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn set_nostretch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Start generation"] pub fn start (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Start generation"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stop generation"] pub fn stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stop generation"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge enable"] pub fn ack (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge enable"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn pos (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn set_pos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Packet error checking"] pub fn pec (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Packet error checking"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "SMBus alert"] pub fn alert (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_alert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Software reset"] pub fn swrst (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Software reset"] pub fn set_swrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral clock frequency"] pub fn freq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Peripheral clock frequency"] pub fn set_freq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Error interrupt enable"] pub fn iterren (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_iterren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Event interrupt enable"] pub fn itevten (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Event interrupt enable"] pub fn set_itevten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Buffer interrupt enable"] pub fn itbufen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer interrupt enable"] pub fn set_itbufen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "DMA requests enable"] pub fn dmaen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "DMA requests enable"] pub fn set_dmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "DMA last transfer"] pub fn last (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "DMA last transfer"] pub fn set_last (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 1"] pub struct OAR1 (u32) ; impl OAR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interface address"] pub fn add0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Interface address"] pub fn set_add0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add7 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add7 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Interface address"] pub fn add10 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Interface address"] pub fn set_add10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Addressing mode (slave\n              mode)"] pub fn addmode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Addressing mode (slave\n              mode)"] pub fn set_addmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 2"] pub struct OAR2 (u32) ; impl OAR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Dual addressing mode\n              enable"] pub fn endual (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Dual addressing mode\n              enable"] pub fn set_endual (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add2 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add2 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "8-bit data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "8-bit data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 1"] pub struct SR1 (u32) ; impl SR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start bit (Master mode)"] pub fn sb (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Address sent (master mode)/matched\n              (slave mode)"] pub fn addr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Byte transfer finished"] pub fn btf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "10-bit header sent (Master\n              mode)"] pub fn add10 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stop detection (slave\n              mode)"] pub fn stopf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Data register not empty\n              (receivers)"] pub fn rxne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Data register empty\n              (transmitters)"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Bus error"] pub fn berr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Bus error"] pub fn set_berr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Arbitration lost (master\n              mode)"] pub fn arlo (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Arbitration lost (master\n              mode)"] pub fn set_arlo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge failure"] pub fn af (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge failure"] pub fn set_af (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Overrun/Underrun"] pub fn ovr (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Overrun/Underrun"] pub fn set_ovr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "PEC Error in reception"] pub fn pecerr (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "PEC Error in reception"] pub fn set_pecerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Timeout or Tlow error"] pub fn timeout (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Timeout or Tlow error"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SMBus alert"] pub fn smbalert (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_smbalert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 2"] pub struct SR2 (u32) ; impl SR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master/slave"] pub fn msl (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Master/slave"] pub fn set_msl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Bus busy"] pub fn busy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Bus busy"] pub fn set_busy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transmitter/receiver"] pub fn tra (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transmitter/receiver"] pub fn set_tra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "General call address (Slave\n              mode)"] pub fn gencall (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "General call address (Slave\n              mode)"] pub fn set_gencall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn smbdefault (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn set_smbdefault (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "SMBus host header (Slave\n              mode)"] pub fn smbhost (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SMBus host header (Slave\n              mode)"] pub fn set_smbhost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Dual flag (Slave mode)"] pub fn dualf (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Dual flag (Slave mode)"] pub fn set_dualf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "acket error checking\n              register"] pub fn pec (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "acket error checking\n              register"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control register"] pub struct CCR (u32) ; impl CCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn ccr (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn set_ccr (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Fast mode duty cycle"] pub fn duty (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Fast mode duty cycle"] pub fn set_duty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "I2C master mode selection"] pub fn f_s (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "I2C master mode selection"] pub fn set_f_s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TRISE register"] pub struct TRISE (u32) ; impl TRISE { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn trise (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn set_trise (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim3 { # [doc = "General purpose timers"] pub struct TIM3 ; impl TIM3 { pub const BASE_ADDR : u64 = 1073742848u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC1S"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC1S"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC1FE"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC1FE"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC1PE"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC1PE"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC1M"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC1M"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC1CE"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC1CE"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC2S"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC2S"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC2FE"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC2FE"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC2PE"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC2PE"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC2M"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC2M"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC2CE"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC2CE"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC3S"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC3S"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC3FE"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC3FE"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC3PE"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC3PE"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC3M"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC3M"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC3CE"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC3CE"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC4S"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC4S"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC4FE"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC4FE"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC4PE"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC4PE"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC4M"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC4M"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC4CE"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC4CE"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn cc4np (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn set_cc4np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low counter value"] pub fn cnt_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low counter value"] pub fn set_cnt_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High counter value"] pub fn cnt_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High counter value"] pub fn set_cnt_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Auto-reload value"] pub fn arr_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Auto-reload value"] pub fn set_arr_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Auto-reload value"] pub fn arr_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Auto-reload value"] pub fn set_arr_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 1\n              value"] pub fn ccr1_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 1\n              value"] pub fn set_ccr1_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 1\n              value"] pub fn ccr1_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 1\n              value"] pub fn set_ccr1_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 2\n              value"] pub fn ccr2_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 2\n              value"] pub fn set_ccr2_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 2\n              value"] pub fn ccr2_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 2\n              value"] pub fn set_ccr2_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr3_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr3_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr3_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr3_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr4_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr4_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr4_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr4_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod spi2 { # [doc = "Serial peripheral interface"] pub struct SPI2 ; impl SPI2 { pub const BASE_ADDR : u64 = 1073756160u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Master selection"] pub fn mstr (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Master selection"] pub fn set_mstr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Baud rate control"] pub fn br (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "Baud rate control"] pub fn set_br (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "SPI enable"] pub fn spe (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SPI enable"] pub fn set_spe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Frame format"] pub fn lsbfirst (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Frame format"] pub fn set_lsbfirst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Internal slave select"] pub fn ssi (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Internal slave select"] pub fn set_ssi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software slave management"] pub fn ssm (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software slave management"] pub fn set_ssm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Receive only"] pub fn rxonly (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Receive only"] pub fn set_rxonly (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data frame format"] pub fn dff (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data frame format"] pub fn set_dff (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "CRC transfer next"] pub fn crcnext (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "CRC transfer next"] pub fn set_crcnext (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Hardware CRC calculation\n              enable"] pub fn crcen (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Hardware CRC calculation\n              enable"] pub fn set_crcen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output enable in bidirectional\n              mode"] pub fn bidioe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output enable in bidirectional\n              mode"] pub fn set_bidioe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Bidirectional data mode\n              enable"] pub fn bidimode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Bidirectional data mode\n              enable"] pub fn set_bidimode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx buffer DMA enable"] pub fn rxdmaen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rx buffer DMA enable"] pub fn set_rxdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Tx buffer DMA enable"] pub fn txdmaen (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Tx buffer DMA enable"] pub fn set_txdmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SS output enable"] pub fn ssoe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "SS output enable"] pub fn set_ssoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Frame format"] pub fn frf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Frame format"] pub fn set_frf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Error interrupt enable"] pub fn errie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_errie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "RX buffer not empty interrupt\n              enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Tx buffer empty interrupt\n              enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive buffer not empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transmit buffer empty"] pub fn txe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Channel side"] pub fn chside (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Underrun flag"] pub fn udr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "CRC error flag"] pub fn crcerr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "CRC error flag"] pub fn set_crcerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Mode fault"] pub fn modf (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag"] pub fn ovr (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Busy flag"] pub fn bsy (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI frame format error"] pub fn tifrfe (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "CRC polynomial register"] pub struct CRCPR (u32) ; impl CRCPR { pub const RESET_VALUE : u32 = 7u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CRC polynomial register"] pub fn crcpoly (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "CRC polynomial register"] pub fn set_crcpoly (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "RX CRC register"] pub struct RXCRCR (u32) ; impl RXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rx CRC register"] pub fn rxcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Rx CRC register"] pub fn set_rxcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TX CRC register"] pub struct TXCRCR (u32) ; impl TXCRCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Tx CRC register"] pub fn txcrc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Tx CRC register"] pub fn set_txcrc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S configuration register"] pub struct I2SCFGR (u32) ; impl I2SCFGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn chlen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Channel length (number of bits per audio\n              channel)"] pub fn set_chlen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data length to be\n              transferred"] pub fn datlen (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Data length to be\n              transferred"] pub fn set_datlen (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Steady state clock\n              polarity"] pub fn ckpol (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Steady state clock\n              polarity"] pub fn set_ckpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "I2S standard selection"] pub fn i2sstd (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "I2S standard selection"] pub fn set_i2sstd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PCM frame synchronization"] pub fn pcmsync (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "PCM frame synchronization"] pub fn set_pcmsync (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "I2S configuration mode"] pub fn i2scfg (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "I2S configuration mode"] pub fn set_i2scfg (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "I2S Enable"] pub fn i2se (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "I2S Enable"] pub fn set_i2se (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "I2S mode selection"] pub fn i2smod (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "I2S mode selection"] pub fn set_i2smod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "I2S prescaler register"] pub struct I2SPR (u32) ; impl I2SPR { pub const RESET_VALUE : u32 = 10u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "I2S Linear prescaler"] pub fn i2sdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "I2S Linear prescaler"] pub fn set_i2sdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Odd factor for the\n              prescaler"] pub fn odd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Odd factor for the\n              prescaler"] pub fn set_odd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Master clock output enable"] pub fn mckoe (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Master clock output enable"] pub fn set_mckoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpioa { # [doc = "General-purpose I/Os"] pub struct GPIOA ; impl GPIOA { pub const BASE_ADDR : u64 = 1073872896u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 2818572288u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 1677721600u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpioe { # [doc = "General-purpose I/Os"] pub struct GPIOE ; impl GPIOE { pub const BASE_ADDR : u64 = 1073876992u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod dbg { # [doc = "Debug support"] pub struct DBG ; impl DBG { pub const BASE_ADDR : u64 = 3758366720u64 ; } # [doc = "IDCODE"] pub struct DBGMCU_IDCODE (u32) ; impl DBGMCU_IDCODE { pub const RESET_VALUE : u32 = 268461073u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DEV_ID"] pub fn dev_id (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "DEV_ID"] pub fn set_dev_id (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "REV_ID"] pub fn rev_id (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "REV_ID"] pub fn set_rev_id (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control Register"] pub struct DBGMCU_CR (u32) ; impl DBGMCU_CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DBG_SLEEP"] pub fn dbg_sleep (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DBG_SLEEP"] pub fn set_dbg_sleep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DBG_STOP"] pub fn dbg_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "DBG_STOP"] pub fn set_dbg_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "DBG_STANDBY"] pub fn dbg_standby (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "DBG_STANDBY"] pub fn set_dbg_standby (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "TRACE_IOEN"] pub fn trace_ioen (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "TRACE_IOEN"] pub fn set_trace_ioen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "TRACE_MODE"] pub fn trace_mode (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "TRACE_MODE"] pub fn set_trace_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Debug MCU APB1 Freeze registe"] pub struct DBGMCU_APB1_FZ (u32) ; impl DBGMCU_APB1_FZ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DBG_TIM2_STOP"] pub fn dbg_tim2_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DBG_TIM2_STOP"] pub fn set_dbg_tim2_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DBG_TIM3 _STOP"] pub fn dbg_tim3_stop (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "DBG_TIM3 _STOP"] pub fn set_dbg_tim3_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "DBG_TIM4_STOP"] pub fn dbg_tim4_stop (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "DBG_TIM4_STOP"] pub fn set_dbg_tim4_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "DBG_TIM5_STOP"] pub fn dbg_tim5_stop (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "DBG_TIM5_STOP"] pub fn set_dbg_tim5_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "RTC stopped when Core is\n              halted"] pub fn dbg_rtc_stop (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "RTC stopped when Core is\n              halted"] pub fn set_dbg_rtc_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "DBG_WWDG_STOP"] pub fn dbg_wwdg_stop (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "DBG_WWDG_STOP"] pub fn set_dbg_wwdg_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "DBG_IWDEG_STOP"] pub fn dbg_iwdeg_stop (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "DBG_IWDEG_STOP"] pub fn set_dbg_iwdeg_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "DBG_J2C1_SMBUS_TIMEOUT"] pub fn dbg_i2c1_smbus_timeout (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "DBG_J2C1_SMBUS_TIMEOUT"] pub fn set_dbg_i2c1_smbus_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "DBG_J2C2_SMBUS_TIMEOUT"] pub fn dbg_i2c2_smbus_timeout (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "DBG_J2C2_SMBUS_TIMEOUT"] pub fn set_dbg_i2c2_smbus_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "DBG_J2C3SMBUS_TIMEOUT"] pub fn dbg_i2c3smbus_timeout (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "DBG_J2C3SMBUS_TIMEOUT"] pub fn set_dbg_i2c3smbus_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Debug MCU APB2 Freeze registe"] pub struct DBGMCU_APB2_FZ (u32) ; impl DBGMCU_APB2_FZ { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "TIM1 counter stopped when core is\n              halted"] pub fn dbg_tim1_stop (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "TIM1 counter stopped when core is\n              halted"] pub fn set_dbg_tim1_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "TIM9 counter stopped when core is\n              halted"] pub fn dbg_tim9_stop (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "TIM9 counter stopped when core is\n              halted"] pub fn set_dbg_tim9_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "TIM10 counter stopped when core is\n              halted"] pub fn dbg_tim10_stop (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "TIM10 counter stopped when core is\n              halted"] pub fn set_dbg_tim10_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "TIM11 counter stopped when core is\n              halted"] pub fn dbg_tim11_stop (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "TIM11 counter stopped when core is\n              halted"] pub fn set_dbg_tim11_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod i2c3 { # [doc = "Inter-integrated circuit"] pub struct I2C3 ; impl I2C3 { pub const BASE_ADDR : u64 = 1073765376u64 ; } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral enable"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Peripheral enable"] pub fn set_pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "SMBus mode"] pub fn smbus (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "SMBus mode"] pub fn set_smbus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SMBus type"] pub fn smbtype (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "SMBus type"] pub fn set_smbtype (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ARP enable"] pub fn enarp (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ARP enable"] pub fn set_enarp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PEC enable"] pub fn enpec (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "PEC enable"] pub fn set_enpec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "General call enable"] pub fn engc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "General call enable"] pub fn set_engc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn nostretch (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Clock stretching disable (Slave\n              mode)"] pub fn set_nostretch (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Start generation"] pub fn start (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Start generation"] pub fn set_start (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stop generation"] pub fn stop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stop generation"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge enable"] pub fn ack (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge enable"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn pos (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Acknowledge/PEC Position (for data\n              reception)"] pub fn set_pos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Packet error checking"] pub fn pec (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Packet error checking"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "SMBus alert"] pub fn alert (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_alert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Software reset"] pub fn swrst (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Software reset"] pub fn set_swrst (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral clock frequency"] pub fn freq (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Peripheral clock frequency"] pub fn set_freq (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Error interrupt enable"] pub fn iterren (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_iterren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Event interrupt enable"] pub fn itevten (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Event interrupt enable"] pub fn set_itevten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Buffer interrupt enable"] pub fn itbufen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Buffer interrupt enable"] pub fn set_itbufen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "DMA requests enable"] pub fn dmaen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "DMA requests enable"] pub fn set_dmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "DMA last transfer"] pub fn last (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "DMA last transfer"] pub fn set_last (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 1"] pub struct OAR1 (u32) ; impl OAR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interface address"] pub fn add0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Interface address"] pub fn set_add0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add7 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add7 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Interface address"] pub fn add10 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Interface address"] pub fn set_add10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Addressing mode (slave\n              mode)"] pub fn addmode (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Addressing mode (slave\n              mode)"] pub fn set_addmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Own address register 2"] pub struct OAR2 (u32) ; impl OAR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Dual addressing mode\n              enable"] pub fn endual (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Dual addressing mode\n              enable"] pub fn set_endual (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interface address"] pub fn add2 (& self) -> u32 { (self . 0 >> 1u32) & 127u32 } # [doc = "Interface address"] pub fn set_add2 (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "8-bit data register"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "8-bit data register"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 1"] pub struct SR1 (u32) ; impl SR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Start bit (Master mode)"] pub fn sb (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Address sent (master mode)/matched\n              (slave mode)"] pub fn addr (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Byte transfer finished"] pub fn btf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "10-bit header sent (Master\n              mode)"] pub fn add10 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stop detection (slave\n              mode)"] pub fn stopf (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Data register not empty\n              (receivers)"] pub fn rxne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Data register empty\n              (transmitters)"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Bus error"] pub fn berr (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Bus error"] pub fn set_berr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Arbitration lost (master\n              mode)"] pub fn arlo (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Arbitration lost (master\n              mode)"] pub fn set_arlo (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Acknowledge failure"] pub fn af (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Acknowledge failure"] pub fn set_af (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Overrun/Underrun"] pub fn ovr (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Overrun/Underrun"] pub fn set_ovr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "PEC Error in reception"] pub fn pecerr (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "PEC Error in reception"] pub fn set_pecerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Timeout or Tlow error"] pub fn timeout (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Timeout or Tlow error"] pub fn set_timeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "SMBus alert"] pub fn smbalert (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "SMBus alert"] pub fn set_smbalert (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register 2"] pub struct SR2 (u32) ; impl SR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Master/slave"] pub fn msl (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Master/slave"] pub fn set_msl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Bus busy"] pub fn busy (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Bus busy"] pub fn set_busy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transmitter/receiver"] pub fn tra (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transmitter/receiver"] pub fn set_tra (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "General call address (Slave\n              mode)"] pub fn gencall (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "General call address (Slave\n              mode)"] pub fn set_gencall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn smbdefault (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "SMBus device default address (Slave\n              mode)"] pub fn set_smbdefault (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "SMBus host header (Slave\n              mode)"] pub fn smbhost (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "SMBus host header (Slave\n              mode)"] pub fn set_smbhost (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Dual flag (Slave mode)"] pub fn dualf (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Dual flag (Slave mode)"] pub fn set_dualf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "acket error checking\n              register"] pub fn pec (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "acket error checking\n              register"] pub fn set_pec (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Clock control register"] pub struct CCR (u32) ; impl CCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn ccr (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Clock control register in Fast/Standard\n              mode (Master mode)"] pub fn set_ccr (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Fast mode duty cycle"] pub fn duty (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Fast mode duty cycle"] pub fn set_duty (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "I2C master mode selection"] pub fn f_s (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "I2C master mode selection"] pub fn set_f_s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "TRISE register"] pub struct TRISE (u32) ; impl TRISE { pub const RESET_VALUE : u32 = 2u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn trise (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Maximum rise time in Fast/Standard mode\n              (Master mode)"] pub fn set_trise (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod usart6 { # [doc = "Universal synchronous asynchronous receiver\n      transmitter"] pub struct USART6 ; impl USART6 { pub const BASE_ADDR : u64 = 1073812480u64 ; } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 12582912u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Parity error"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Framing error"] pub fn fe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Noise detected flag"] pub fn nf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Overrun error"] pub fn ore (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IDLE line detected"] pub fn idle (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn set_rxne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete"] pub fn tc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete"] pub fn set_tc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transmit data register\n              empty"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn lbd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn set_lbd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS flag"] pub fn cts (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS flag"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data value"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Data value"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate register"] pub struct BRR (u32) ; impl BRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "fraction of USARTDIV"] pub fn div_fraction (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "fraction of USARTDIV"] pub fn set_div_fraction (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "mantissa of USARTDIV"] pub fn div_mantissa (& self) -> u32 { (self . 0 >> 4u32) & 4095u32 } # [doc = "mantissa of USARTDIV"] pub fn set_div_mantissa (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Send break"] pub fn sbk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Send break"] pub fn set_sbk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receiver wakeup"] pub fn rwu (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receiver wakeup"] pub fn set_rwu (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receiver enable"] pub fn re (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receiver enable"] pub fn set_re (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Transmitter enable"] pub fn te (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Transmitter enable"] pub fn set_te (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IDLE interrupt enable"] pub fn idleie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IDLE interrupt enable"] pub fn set_idleie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "RXNE interrupt enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "RXNE interrupt enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXE interrupt enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TXE interrupt enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "PE interrupt enable"] pub fn peie (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "PE interrupt enable"] pub fn set_peie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Parity selection"] pub fn ps (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Parity selection"] pub fn set_ps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Parity control enable"] pub fn pce (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Parity control enable"] pub fn set_pce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Wakeup method"] pub fn wake (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Wakeup method"] pub fn set_wake (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Word length"] pub fn m (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Word length"] pub fn set_m (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "USART enable"] pub fn ue (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "USART enable"] pub fn set_ue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Oversampling mode"] pub fn over8 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Oversampling mode"] pub fn set_over8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address of the USART node"] pub fn add (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Address of the USART node"] pub fn set_add (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "lin break detection length"] pub fn lbdl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "lin break detection length"] pub fn set_lbdl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "LIN break detection interrupt\n              enable"] pub fn lbdie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "LIN break detection interrupt\n              enable"] pub fn set_lbdie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Last bit clock pulse"] pub fn lbcl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Last bit clock pulse"] pub fn set_lbcl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Clock enable"] pub fn clken (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Clock enable"] pub fn set_clken (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "STOP bits"] pub fn stop (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "STOP bits"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "LIN mode enable"] pub fn linen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "LIN mode enable"] pub fn set_linen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 3"] pub struct CR3 (u32) ; impl CR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Error interrupt enable"] pub fn eie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_eie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IrDA mode enable"] pub fn iren (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IrDA mode enable"] pub fn set_iren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IrDA low-power"] pub fn irlp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IrDA low-power"] pub fn set_irlp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half-duplex selection"] pub fn hdsel (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half-duplex selection"] pub fn set_hdsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Smartcard NACK enable"] pub fn nack (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Smartcard NACK enable"] pub fn set_nack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Smartcard mode enable"] pub fn scen (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Smartcard mode enable"] pub fn set_scen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "DMA enable receiver"] pub fn dmar (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "DMA enable receiver"] pub fn set_dmar (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "DMA enable transmitter"] pub fn dmat (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "DMA enable transmitter"] pub fn set_dmat (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "RTS enable"] pub fn rtse (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "RTS enable"] pub fn set_rtse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS enable"] pub fn ctse (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS enable"] pub fn set_ctse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "CTS interrupt enable"] pub fn ctsie (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "CTS interrupt enable"] pub fn set_ctsie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "One sample bit method\n              enable"] pub fn onebit (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "One sample bit method\n              enable"] pub fn set_onebit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Guard time and prescaler\n          register"] pub struct GTPR (u32) ; impl GTPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Guard time value"] pub fn gt (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Guard time value"] pub fn set_gt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod adc_common { # [doc = "ADC common registers"] pub struct ADC_Common ; impl ADC_Common { pub const BASE_ADDR : u64 = 1073816320u64 ; } # [doc = "ADC Common status register"] pub struct CSR (u32) ; impl CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog watchdog flag of ADC\n              1"] pub fn awd1 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Analog watchdog flag of ADC\n              1"] pub fn set_awd1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "End of conversion of ADC 1"] pub fn eoc1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "End of conversion of ADC 1"] pub fn set_eoc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Injected channel end of conversion of\n              ADC 1"] pub fn jeoc1 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Injected channel end of conversion of\n              ADC 1"] pub fn set_jeoc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Injected channel Start flag of ADC\n              1"] pub fn jstrt1 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Injected channel Start flag of ADC\n              1"] pub fn set_jstrt1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Regular channel Start flag of ADC\n              1"] pub fn strt1 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Regular channel Start flag of ADC\n              1"] pub fn set_strt1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Overrun flag of ADC 1"] pub fn ovr1 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun flag of ADC 1"] pub fn set_ovr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Analog watchdog flag of ADC\n              2"] pub fn awd2 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Analog watchdog flag of ADC\n              2"] pub fn set_awd2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "End of conversion of ADC 2"] pub fn eoc2 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "End of conversion of ADC 2"] pub fn set_eoc2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Injected channel end of conversion of\n              ADC 2"] pub fn jeoc2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Injected channel end of conversion of\n              ADC 2"] pub fn set_jeoc2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Injected channel Start flag of ADC\n              2"] pub fn jstrt2 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Injected channel Start flag of ADC\n              2"] pub fn set_jstrt2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Regular channel Start flag of ADC\n              2"] pub fn strt2 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Regular channel Start flag of ADC\n              2"] pub fn set_strt2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Overrun flag of ADC 2"] pub fn ovr2 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Overrun flag of ADC 2"] pub fn set_ovr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Analog watchdog flag of ADC\n              3"] pub fn awd3 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Analog watchdog flag of ADC\n              3"] pub fn set_awd3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "End of conversion of ADC 3"] pub fn eoc3 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "End of conversion of ADC 3"] pub fn set_eoc3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Injected channel end of conversion of\n              ADC 3"] pub fn jeoc3 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Injected channel end of conversion of\n              ADC 3"] pub fn set_jeoc3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Injected channel Start flag of ADC\n              3"] pub fn jstrt3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Injected channel Start flag of ADC\n              3"] pub fn set_jstrt3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Regular channel Start flag of ADC\n              3"] pub fn strt3 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Regular channel Start flag of ADC\n              3"] pub fn set_strt3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Overrun flag of ADC3"] pub fn ovr3 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Overrun flag of ADC3"] pub fn set_ovr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "ADC common control register"] pub struct CCR (u32) ; impl CCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Delay between 2 sampling\n              phases"] pub fn delay (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Delay between 2 sampling\n              phases"] pub fn set_delay (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "DMA disable selection for multi-ADC\n              mode"] pub fn dds (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "DMA disable selection for multi-ADC\n              mode"] pub fn set_dds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Direct memory access mode for multi ADC\n              mode"] pub fn dma (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Direct memory access mode for multi ADC\n              mode"] pub fn set_dma (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "ADC prescaler"] pub fn adcpre (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "ADC prescaler"] pub fn set_adcpre (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "VBAT enable"] pub fn vbate (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "VBAT enable"] pub fn set_vbate (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Temperature sensor and VREFINT\n              enable"] pub fn tsvrefe (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Temperature sensor and VREFINT\n              enable"] pub fn set_tsvrefe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod dma1 { # [doc = "DMA controller"] pub struct DMA1 ; impl DMA1 { pub const BASE_ADDR : u64 = 1073897472u64 ; } # [doc = "low interrupt status register"] pub struct LISR (u32) ; impl LISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif1 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif1 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif2 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif2 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif2 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif3 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif3 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif3 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif3 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif3 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "high interrupt status register"] pub struct HISR (u32) ; impl HISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif4 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif4 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif4 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif5 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif5 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif5 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif5 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif6 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif6 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif6 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif6 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif6 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif7 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif7 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif7 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif7 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif7 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "low interrupt flag clear\n          register"] pub struct LIFCR (u32) ; impl LIFCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif1 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif1 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif2 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif2 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif2 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif3 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif3 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif3 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif3 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif3 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "high interrupt flag clear\n          register"] pub struct HIFCR (u32) ; impl HIFCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif4 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif4 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif4 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif5 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif5 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif5 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif5 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif6 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif6 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif6 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif6 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif6 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif7 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif7 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif7 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif7 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif7 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S0CR (u32) ; impl S0CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S0NDTR (u32) ; impl S0NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S0PAR (u32) ; impl S0PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S0M0AR (u32) ; impl S0M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S0M1AR (u32) ; impl S0M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S0FCR (u32) ; impl S0FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S1CR (u32) ; impl S1CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S1NDTR (u32) ; impl S1NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S1PAR (u32) ; impl S1PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S1M0AR (u32) ; impl S1M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S1M1AR (u32) ; impl S1M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S1FCR (u32) ; impl S1FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S2CR (u32) ; impl S2CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S2NDTR (u32) ; impl S2NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S2PAR (u32) ; impl S2PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S2M0AR (u32) ; impl S2M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S2M1AR (u32) ; impl S2M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S2FCR (u32) ; impl S2FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S3CR (u32) ; impl S3CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S3NDTR (u32) ; impl S3NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S3PAR (u32) ; impl S3PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S3M0AR (u32) ; impl S3M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S3M1AR (u32) ; impl S3M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S3FCR (u32) ; impl S3FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S4CR (u32) ; impl S4CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S4NDTR (u32) ; impl S4NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S4PAR (u32) ; impl S4PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S4M0AR (u32) ; impl S4M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S4M1AR (u32) ; impl S4M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S4FCR (u32) ; impl S4FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S5CR (u32) ; impl S5CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S5NDTR (u32) ; impl S5NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S5PAR (u32) ; impl S5PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S5M0AR (u32) ; impl S5M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S5M1AR (u32) ; impl S5M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S5FCR (u32) ; impl S5FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S6CR (u32) ; impl S6CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S6NDTR (u32) ; impl S6NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S6PAR (u32) ; impl S6PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S6M0AR (u32) ; impl S6M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S6M1AR (u32) ; impl S6M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S6FCR (u32) ; impl S6FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S7CR (u32) ; impl S7CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S7NDTR (u32) ; impl S7NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S7PAR (u32) ; impl S7PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S7M0AR (u32) ; impl S7M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S7M1AR (u32) ; impl S7M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S7FCR (u32) ; impl S7FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim11 { # [doc = "General-purpose-timers"] pub struct TIM11 ; impl TIM11 { pub const BASE_ADDR : u64 = 1073825792u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output Compare 1 fast\n              enable"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output Compare 1 fast\n              enable"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output Compare 1 preload\n              enable"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output Compare 1 preload\n              enable"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output Compare 1 mode"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output Compare 1 mode"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "counter value"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "counter value"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Auto-reload value"] pub fn arr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Auto-reload value"] pub fn set_arr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 value"] pub fn ccr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 1 value"] pub fn set_ccr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "option register"] pub struct OR (u32) ; impl OR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Input 1 remapping\n              capability"] pub fn rmp (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Input 1 remapping\n              capability"] pub fn set_rmp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod pwr { # [doc = "Power control"] pub struct PWR ; impl PWR { pub const BASE_ADDR : u64 = 1073770496u64 ; } # [doc = "power control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low-power deep sleep"] pub fn lpds (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Low-power deep sleep"] pub fn set_lpds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Power down deepsleep"] pub fn pdds (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Power down deepsleep"] pub fn set_pdds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Clear wakeup flag"] pub fn cwuf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Clear wakeup flag"] pub fn set_cwuf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Clear standby flag"] pub fn csbf (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Clear standby flag"] pub fn set_csbf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Power voltage detector\n              enable"] pub fn pvde (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Power voltage detector\n              enable"] pub fn set_pvde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "PVD level selection"] pub fn pls (& self) -> u32 { (self . 0 >> 5u32) & 7u32 } # [doc = "PVD level selection"] pub fn set_pls (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Disable backup domain write\n              protection"] pub fn dbp (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Disable backup domain write\n              protection"] pub fn set_dbp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Flash power down in Stop\n              mode"] pub fn fpds (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Flash power down in Stop\n              mode"] pub fn set_fpds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "ADCDC1"] pub fn adcdc1 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "ADCDC1"] pub fn set_adcdc1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Regulator voltage scaling output\n              selection"] pub fn vos (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Regulator voltage scaling output\n              selection"] pub fn set_vos (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "power control/status register"] pub struct CSR (u32) ; impl CSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Wakeup flag"] pub fn wuf (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Standby flag"] pub fn sbf (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "PVD output"] pub fn pvdo (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Backup regulator ready"] pub fn brr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Enable WKUP pin"] pub fn ewup (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Enable WKUP pin"] pub fn set_ewup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Backup regulator enable"] pub fn bre (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Backup regulator enable"] pub fn set_bre (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Regulator voltage scaling output\n              selection ready bit"] pub fn vosrdy (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Regulator voltage scaling output\n              selection ready bit"] pub fn set_vosrdy (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpiob { # [doc = "General-purpose I/Os"] pub struct GPIOB ; impl GPIOB { pub const BASE_ADDR : u64 = 1073873920u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 640u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 192u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 256u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod adc1 { # [doc = "Analog-to-digital converter"] pub struct ADC1 ; impl ADC1 { pub const BASE_ADDR : u64 = 1073815552u64 ; } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog watchdog flag"] pub fn awd (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Analog watchdog flag"] pub fn set_awd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Regular channel end of\n              conversion"] pub fn eoc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Regular channel end of\n              conversion"] pub fn set_eoc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Injected channel end of\n              conversion"] pub fn jeoc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Injected channel end of\n              conversion"] pub fn set_jeoc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Injected channel start\n              flag"] pub fn jstrt (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Injected channel start\n              flag"] pub fn set_jstrt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Regular channel start flag"] pub fn strt (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Regular channel start flag"] pub fn set_strt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Overrun"] pub fn ovr (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Overrun"] pub fn set_ovr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog watchdog channel select\n              bits"] pub fn awdch (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "Analog watchdog channel select\n              bits"] pub fn set_awdch (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interrupt enable for EOC"] pub fn eocie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Interrupt enable for EOC"] pub fn set_eocie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Analog watchdog interrupt\n              enable"] pub fn awdie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Analog watchdog interrupt\n              enable"] pub fn set_awdie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Interrupt enable for injected\n              channels"] pub fn jeocie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Interrupt enable for injected\n              channels"] pub fn set_jeocie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Scan mode"] pub fn scan (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Scan mode"] pub fn set_scan (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Enable the watchdog on a single channel\n              in scan mode"] pub fn awdsgl (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Enable the watchdog on a single channel\n              in scan mode"] pub fn set_awdsgl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Automatic injected group\n              conversion"] pub fn jauto (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Automatic injected group\n              conversion"] pub fn set_jauto (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Discontinuous mode on regular\n              channels"] pub fn discen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Discontinuous mode on regular\n              channels"] pub fn set_discen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Discontinuous mode on injected\n              channels"] pub fn jdiscen (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Discontinuous mode on injected\n              channels"] pub fn set_jdiscen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Discontinuous mode channel\n              count"] pub fn discnum (& self) -> u32 { (self . 0 >> 13u32) & 7u32 } # [doc = "Discontinuous mode channel\n              count"] pub fn set_discnum (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Analog watchdog enable on injected\n              channels"] pub fn jawden (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Analog watchdog enable on injected\n              channels"] pub fn set_jawden (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Analog watchdog enable on regular\n              channels"] pub fn awden (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Analog watchdog enable on regular\n              channels"] pub fn set_awden (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Resolution"] pub fn res (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Resolution"] pub fn set_res (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Overrun interrupt enable"] pub fn ovrie (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Overrun interrupt enable"] pub fn set_ovrie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "A/D Converter ON / OFF"] pub fn adon (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "A/D Converter ON / OFF"] pub fn set_adon (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Continuous conversion"] pub fn cont (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Continuous conversion"] pub fn set_cont (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Direct memory access mode (for single\n              ADC mode)"] pub fn dma (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Direct memory access mode (for single\n              ADC mode)"] pub fn set_dma (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "DMA disable selection (for single ADC\n              mode)"] pub fn dds (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "DMA disable selection (for single ADC\n              mode)"] pub fn set_dds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "End of conversion\n              selection"] pub fn eocs (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "End of conversion\n              selection"] pub fn set_eocs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Data alignment"] pub fn align (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Data alignment"] pub fn set_align (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "External event select for injected\n              group"] pub fn jextsel (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "External event select for injected\n              group"] pub fn set_jextsel (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "External trigger enable for injected\n              channels"] pub fn jexten (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "External trigger enable for injected\n              channels"] pub fn set_jexten (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Start conversion of injected\n              channels"] pub fn jswstart (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Start conversion of injected\n              channels"] pub fn set_jswstart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "External event select for regular\n              group"] pub fn extsel (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "External event select for regular\n              group"] pub fn set_extsel (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "External trigger enable for regular\n              channels"] pub fn exten (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "External trigger enable for regular\n              channels"] pub fn set_exten (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Start conversion of regular\n              channels"] pub fn swstart (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Start conversion of regular\n              channels"] pub fn set_swstart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "sample time register 1"] pub struct SMPR1 (u32) ; impl SMPR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sample time bits"] pub fn smpx_x (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Sample time bits"] pub fn set_smpx_x (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "sample time register 2"] pub struct SMPR2 (u32) ; impl SMPR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Sample time bits"] pub fn smpx_x (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Sample time bits"] pub fn set_smpx_x (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected channel data offset register\n          x"] pub struct JOFR1 (u32) ; impl JOFR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data offset for injected channel\n              x"] pub fn joffset1 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Data offset for injected channel\n              x"] pub fn set_joffset1 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected channel data offset register\n          x"] pub struct JOFR2 (u32) ; impl JOFR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data offset for injected channel\n              x"] pub fn joffset2 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Data offset for injected channel\n              x"] pub fn set_joffset2 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected channel data offset register\n          x"] pub struct JOFR3 (u32) ; impl JOFR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data offset for injected channel\n              x"] pub fn joffset3 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Data offset for injected channel\n              x"] pub fn set_joffset3 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected channel data offset register\n          x"] pub struct JOFR4 (u32) ; impl JOFR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data offset for injected channel\n              x"] pub fn joffset4 (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Data offset for injected channel\n              x"] pub fn set_joffset4 (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "watchdog higher threshold\n          register"] pub struct HTR (u32) ; impl HTR { pub const RESET_VALUE : u32 = 4095u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog watchdog higher\n              threshold"] pub fn ht (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Analog watchdog higher\n              threshold"] pub fn set_ht (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "watchdog lower threshold\n          register"] pub struct LTR (u32) ; impl LTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Analog watchdog lower\n              threshold"] pub fn lt (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Analog watchdog lower\n              threshold"] pub fn set_lt (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "regular sequence register 1"] pub struct SQR1 (u32) ; impl SQR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "13th conversion in regular\n              sequence"] pub fn sq13 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "13th conversion in regular\n              sequence"] pub fn set_sq13 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "14th conversion in regular\n              sequence"] pub fn sq14 (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "14th conversion in regular\n              sequence"] pub fn set_sq14 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "15th conversion in regular\n              sequence"] pub fn sq15 (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "15th conversion in regular\n              sequence"] pub fn set_sq15 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "16th conversion in regular\n              sequence"] pub fn sq16 (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "16th conversion in regular\n              sequence"] pub fn set_sq16 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Regular channel sequence\n              length"] pub fn l (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Regular channel sequence\n              length"] pub fn set_l (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "regular sequence register 2"] pub struct SQR2 (u32) ; impl SQR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "7th conversion in regular\n              sequence"] pub fn sq7 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "7th conversion in regular\n              sequence"] pub fn set_sq7 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "8th conversion in regular\n              sequence"] pub fn sq8 (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "8th conversion in regular\n              sequence"] pub fn set_sq8 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "9th conversion in regular\n              sequence"] pub fn sq9 (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "9th conversion in regular\n              sequence"] pub fn set_sq9 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "10th conversion in regular\n              sequence"] pub fn sq10 (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "10th conversion in regular\n              sequence"] pub fn set_sq10 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "11th conversion in regular\n              sequence"] pub fn sq11 (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "11th conversion in regular\n              sequence"] pub fn set_sq11 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "12th conversion in regular\n              sequence"] pub fn sq12 (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "12th conversion in regular\n              sequence"] pub fn set_sq12 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "regular sequence register 3"] pub struct SQR3 (u32) ; impl SQR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "1st conversion in regular\n              sequence"] pub fn sq1 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "1st conversion in regular\n              sequence"] pub fn set_sq1 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "2nd conversion in regular\n              sequence"] pub fn sq2 (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "2nd conversion in regular\n              sequence"] pub fn set_sq2 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "3rd conversion in regular\n              sequence"] pub fn sq3 (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "3rd conversion in regular\n              sequence"] pub fn set_sq3 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "4th conversion in regular\n              sequence"] pub fn sq4 (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "4th conversion in regular\n              sequence"] pub fn set_sq4 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "5th conversion in regular\n              sequence"] pub fn sq5 (& self) -> u32 { (self . 0 >> 20u32) & 31u32 } # [doc = "5th conversion in regular\n              sequence"] pub fn set_sq5 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "6th conversion in regular\n              sequence"] pub fn sq6 (& self) -> u32 { (self . 0 >> 25u32) & 31u32 } # [doc = "6th conversion in regular\n              sequence"] pub fn set_sq6 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected sequence register"] pub struct JSQR (u32) ; impl JSQR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "1st conversion in injected\n              sequence"] pub fn jsq1 (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "1st conversion in injected\n              sequence"] pub fn set_jsq1 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "2nd conversion in injected\n              sequence"] pub fn jsq2 (& self) -> u32 { (self . 0 >> 5u32) & 31u32 } # [doc = "2nd conversion in injected\n              sequence"] pub fn set_jsq2 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "3rd conversion in injected\n              sequence"] pub fn jsq3 (& self) -> u32 { (self . 0 >> 10u32) & 31u32 } # [doc = "3rd conversion in injected\n              sequence"] pub fn set_jsq3 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "4th conversion in injected\n              sequence"] pub fn jsq4 (& self) -> u32 { (self . 0 >> 15u32) & 31u32 } # [doc = "4th conversion in injected\n              sequence"] pub fn set_jsq4 (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Injected sequence length"] pub fn jl (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Injected sequence length"] pub fn set_jl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected data register x"] pub struct JDR1 (u32) ; impl JDR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Injected data"] pub fn jdata (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Injected data"] pub fn set_jdata (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected data register x"] pub struct JDR2 (u32) ; impl JDR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Injected data"] pub fn jdata (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Injected data"] pub fn set_jdata (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected data register x"] pub struct JDR3 (u32) ; impl JDR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Injected data"] pub fn jdata (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Injected data"] pub fn set_jdata (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "injected data register x"] pub struct JDR4 (u32) ; impl JDR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Injected data"] pub fn jdata (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Injected data"] pub fn set_jdata (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "regular data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Regular data"] pub fn data (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Regular data"] pub fn set_data (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpioc { # [doc = "General-purpose I/Os"] pub struct GPIOC ; impl GPIOC { pub const BASE_ADDR : u64 = 1073874944u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod otg_fs_device { # [doc = "USB on the go full speed"] pub struct OTG_FS_DEVICE ; impl OTG_FS_DEVICE { pub const BASE_ADDR : u64 = 1342179328u64 ; } # [doc = "OTG_FS device configuration register\n          (OTG_FS_DCFG)"] pub struct FS_DCFG (u32) ; impl FS_DCFG { pub const RESET_VALUE : u32 = 35651584u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device speed"] pub fn dspd (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Device speed"] pub fn set_dspd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Non-zero-length status OUT\n              handshake"] pub fn nzlsohsk (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Non-zero-length status OUT\n              handshake"] pub fn set_nzlsohsk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Device address"] pub fn dad (& self) -> u32 { (self . 0 >> 4u32) & 127u32 } # [doc = "Device address"] pub fn set_dad (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Periodic frame interval"] pub fn pfivl (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Periodic frame interval"] pub fn set_pfivl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device control register\n          (OTG_FS_DCTL)"] pub struct FS_DCTL (u32) ; impl FS_DCTL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Remote wakeup signaling"] pub fn rwusig (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Remote wakeup signaling"] pub fn set_rwusig (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Soft disconnect"] pub fn sdis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Soft disconnect"] pub fn set_sdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Global IN NAK status"] pub fn ginsts (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Global OUT NAK status"] pub fn gonsts (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Test control"] pub fn tctl (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Test control"] pub fn set_tctl (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Set global IN NAK"] pub fn sginak (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Set global IN NAK"] pub fn set_sginak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clear global IN NAK"] pub fn cginak (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Clear global IN NAK"] pub fn set_cginak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Set global OUT NAK"] pub fn sgonak (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Set global OUT NAK"] pub fn set_sgonak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Clear global OUT NAK"] pub fn cgonak (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Clear global OUT NAK"] pub fn set_cgonak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Power-on programming done"] pub fn poprgdne (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Power-on programming done"] pub fn set_poprgdne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device status register\n          (OTG_FS_DSTS)"] pub struct FS_DSTS (u32) ; impl FS_DSTS { pub const RESET_VALUE : u32 = 16u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Suspend status"] pub fn suspsts (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Suspend status"] pub fn set_suspsts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Enumerated speed"] pub fn enumspd (& self) -> u32 { (self . 0 >> 1u32) & 3u32 } # [doc = "Enumerated speed"] pub fn set_enumspd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Erratic error"] pub fn eerr (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Erratic error"] pub fn set_eerr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Frame number of the received\n              SOF"] pub fn fnsof (& self) -> u32 { (self . 0 >> 8u32) & 16383u32 } # [doc = "Frame number of the received\n              SOF"] pub fn set_fnsof (& mut self , value : u32) { let value_masked = value & 16383u32 ; self . 0 &= ! (16383u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint common interrupt\n          mask register (OTG_FS_DIEPMSK)"] pub struct FS_DIEPMSK (u32) ; impl FS_DIEPMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed interrupt\n              mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed interrupt\n              mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint disabled interrupt\n              mask"] pub fn epdm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Endpoint disabled interrupt\n              mask"] pub fn set_epdm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Timeout condition mask (Non-isochronous\n              endpoints)"] pub fn tom (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Timeout condition mask (Non-isochronous\n              endpoints)"] pub fn set_tom (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IN token received when TxFIFO empty\n              mask"] pub fn ittxfemsk (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IN token received when TxFIFO empty\n              mask"] pub fn set_ittxfemsk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "IN token received with EP mismatch\n              mask"] pub fn inepnmm (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "IN token received with EP mismatch\n              mask"] pub fn set_inepnmm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "IN endpoint NAK effective\n              mask"] pub fn inepnem (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "IN endpoint NAK effective\n              mask"] pub fn set_inepnem (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device OUT endpoint common interrupt\n          mask register (OTG_FS_DOEPMSK)"] pub struct FS_DOEPMSK (u32) ; impl FS_DOEPMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer completed interrupt\n              mask"] pub fn xfrcm (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Transfer completed interrupt\n              mask"] pub fn set_xfrcm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Endpoint disabled interrupt\n              mask"] pub fn epdm (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Endpoint disabled interrupt\n              mask"] pub fn set_epdm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "SETUP phase done mask"] pub fn stupm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "SETUP phase done mask"] pub fn set_stupm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OUT token received when endpoint\n              disabled mask"] pub fn otepdm (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "OUT token received when endpoint\n              disabled mask"] pub fn set_otepdm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device all endpoints interrupt\n          register (OTG_FS_DAINT)"] pub struct FS_DAINT (u32) ; impl FS_DAINT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint interrupt bits"] pub fn iepint (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint interrupt bits"] pub fn set_iepint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OUT endpoint interrupt\n              bits"] pub fn oepint (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "OUT endpoint interrupt\n              bits"] pub fn set_oepint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS all endpoints interrupt mask register\n          (OTG_FS_DAINTMSK)"] pub struct FS_DAINTMSK (u32) ; impl FS_DAINTMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN EP interrupt mask bits"] pub fn iepm (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN EP interrupt mask bits"] pub fn set_iepm (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OUT endpoint interrupt\n              bits"] pub fn oepint (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "OUT endpoint interrupt\n              bits"] pub fn set_oepint (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device VBUS discharge time\n          register"] pub struct DVBUSDIS (u32) ; impl DVBUSDIS { pub const RESET_VALUE : u32 = 6103u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device VBUS discharge time"] pub fn vbusdt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Device VBUS discharge time"] pub fn set_vbusdt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device VBUS pulsing time\n          register"] pub struct DVBUSPULSE (u32) ; impl DVBUSPULSE { pub const RESET_VALUE : u32 = 1464u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Device VBUS pulsing time"] pub fn dvbusp (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Device VBUS pulsing time"] pub fn set_dvbusp (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint FIFO empty\n          interrupt mask register"] pub struct DIEPEMPMSK (u32) ; impl DIEPEMPMSK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN EP Tx FIFO empty interrupt mask\n              bits"] pub fn ineptxfem (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN EP Tx FIFO empty interrupt mask\n              bits"] pub fn set_ineptxfem (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device control IN endpoint 0 control\n          register (OTG_FS_DIEPCTL0)"] pub struct FS_DIEPCTL0 (u32) ; impl FS_DIEPCTL0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Maximum packet size"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Maximum packet size"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USB active endpoint"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "NAK status"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Endpoint type"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "STALL handshake"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "STALL handshake"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "TxFIFO number"] pub fn txfnum (& self) -> u32 { (self . 0 >> 22u32) & 15u32 } # [doc = "TxFIFO number"] pub fn set_txfnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Clear NAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Clear NAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Set NAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Set NAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Endpoint disable"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Endpoint enable"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-x interrupt\n          register"] pub struct DIEPINT0 (u32) ; impl DIEPINT0 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TOC"] pub fn toc (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TOC"] pub fn set_toc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ITTXFE"] pub fn ittxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ITTXFE"] pub fn set_ittxfe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "INEPNE"] pub fn inepne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "INEPNE"] pub fn set_inepne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXFE"] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-0 transfer size\n          register"] pub struct DIEPTSIZ0 (u32) ; impl DIEPTSIZ0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 3u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO\n          status register"] pub struct DTXFSTS0 (u32) ; impl DTXFSTS0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn ineptfsav (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn set_ineptfsav (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG device endpoint-1 control\n          register"] pub struct DIEPCTL1 (u32) ; impl DIEPCTL1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "TXFNUM"] pub fn txfnum (& self) -> u32 { (self . 0 >> 22u32) & 15u32 } # [doc = "TXFNUM"] pub fn set_txfnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM/SD1PID"] pub fn soddfrm_sd1pid (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM/SD1PID"] pub fn set_soddfrm_sd1pid (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-1 interrupt\n          register"] pub struct DIEPINT1 (u32) ; impl DIEPINT1 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TOC"] pub fn toc (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TOC"] pub fn set_toc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ITTXFE"] pub fn ittxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ITTXFE"] pub fn set_ittxfe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "INEPNE"] pub fn inepne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "INEPNE"] pub fn set_inepne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXFE"] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-1 transfer size\n          register"] pub struct DIEPTSIZ1 (u32) ; impl DIEPTSIZ1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Multi count"] pub fn mcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Multi count"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO\n          status register"] pub struct DTXFSTS1 (u32) ; impl DTXFSTS1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn ineptfsav (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn set_ineptfsav (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG device endpoint-2 control\n          register"] pub struct DIEPCTL2 (u32) ; impl DIEPCTL2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "TXFNUM"] pub fn txfnum (& self) -> u32 { (self . 0 >> 22u32) & 15u32 } # [doc = "TXFNUM"] pub fn set_txfnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM"] pub fn soddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM"] pub fn set_soddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-2 interrupt\n          register"] pub struct DIEPINT2 (u32) ; impl DIEPINT2 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TOC"] pub fn toc (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TOC"] pub fn set_toc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ITTXFE"] pub fn ittxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ITTXFE"] pub fn set_ittxfe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "INEPNE"] pub fn inepne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "INEPNE"] pub fn set_inepne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXFE"] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-2 transfer size\n          register"] pub struct DIEPTSIZ2 (u32) ; impl DIEPTSIZ2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Multi count"] pub fn mcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Multi count"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO\n          status register"] pub struct DTXFSTS2 (u32) ; impl DTXFSTS2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn ineptfsav (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn set_ineptfsav (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG device endpoint-3 control\n          register"] pub struct DIEPCTL3 (u32) ; impl DIEPCTL3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "TXFNUM"] pub fn txfnum (& self) -> u32 { (self . 0 >> 22u32) & 15u32 } # [doc = "TXFNUM"] pub fn set_txfnum (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM"] pub fn soddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM"] pub fn set_soddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-3 interrupt\n          register"] pub struct DIEPINT3 (u32) ; impl DIEPINT3 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "TOC"] pub fn toc (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "TOC"] pub fn set_toc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "ITTXFE"] pub fn ittxfe (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "ITTXFE"] pub fn set_ittxfe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "INEPNE"] pub fn inepne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "INEPNE"] pub fn set_inepne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXFE"] pub fn txfe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-3 transfer size\n          register"] pub struct DIEPTSIZ3 (u32) ; impl DIEPTSIZ3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Multi count"] pub fn mcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Multi count"] pub fn set_mcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "OTG_FS device IN endpoint transmit FIFO\n          status register"] pub struct DTXFSTS3 (u32) ; impl DTXFSTS3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn ineptfsav (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "IN endpoint TxFIFO space\n              available"] pub fn set_ineptfsav (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-0 control\n          register"] pub struct DOEPCTL0 (u32) ; impl DOEPCTL0 { pub const RESET_VALUE : u32 = 32768u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "SNPM"] pub fn snpm (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "SNPM"] pub fn set_snpm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-0 interrupt\n          register"] pub struct DOEPINT0 (u32) ; impl DOEPINT0 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STUP"] pub fn stup (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STUP"] pub fn set_stup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OTEPDIS"] pub fn otepdis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "OTEPDIS"] pub fn set_otepdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "B2BSTUP"] pub fn b2bstup (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "B2BSTUP"] pub fn set_b2bstup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device OUT endpoint-0 transfer size\n          register"] pub struct DOEPTSIZ0 (u32) ; impl DOEPTSIZ0 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "SETUP packet count"] pub fn stupcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "SETUP packet count"] pub fn set_stupcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-1 control\n          register"] pub struct DOEPCTL1 (u32) ; impl DOEPCTL1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "SNPM"] pub fn snpm (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "SNPM"] pub fn set_snpm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM"] pub fn soddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM"] pub fn set_soddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-1 interrupt\n          register"] pub struct DOEPINT1 (u32) ; impl DOEPINT1 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STUP"] pub fn stup (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STUP"] pub fn set_stup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OTEPDIS"] pub fn otepdis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "OTEPDIS"] pub fn set_otepdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "B2BSTUP"] pub fn b2bstup (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "B2BSTUP"] pub fn set_b2bstup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device OUT endpoint-1 transfer size\n          register"] pub struct DOEPTSIZ1 (u32) ; impl DOEPTSIZ1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Received data PID/SETUP packet\n              count"] pub fn rxdpid_stupcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Received data PID/SETUP packet\n              count"] pub fn set_rxdpid_stupcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-2 control\n          register"] pub struct DOEPCTL2 (u32) ; impl DOEPCTL2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "SNPM"] pub fn snpm (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "SNPM"] pub fn set_snpm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM"] pub fn soddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM"] pub fn set_soddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-2 interrupt\n          register"] pub struct DOEPINT2 (u32) ; impl DOEPINT2 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STUP"] pub fn stup (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STUP"] pub fn set_stup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OTEPDIS"] pub fn otepdis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "OTEPDIS"] pub fn set_otepdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "B2BSTUP"] pub fn b2bstup (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "B2BSTUP"] pub fn set_b2bstup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device OUT endpoint-2 transfer size\n          register"] pub struct DOEPTSIZ2 (u32) ; impl DOEPTSIZ2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Received data PID/SETUP packet\n              count"] pub fn rxdpid_stupcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Received data PID/SETUP packet\n              count"] pub fn set_rxdpid_stupcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-3 control\n          register"] pub struct DOEPCTL3 (u32) ; impl DOEPCTL3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MPSIZ"] pub fn mpsiz (& self) -> u32 { (self . 0 >> 0u32) & 2047u32 } # [doc = "MPSIZ"] pub fn set_mpsiz (& mut self , value : u32) { let value_masked = value & 2047u32 ; self . 0 &= ! (2047u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "USBAEP"] pub fn usbaep (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "USBAEP"] pub fn set_usbaep (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "EONUM/DPID"] pub fn eonum_dpid (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "NAKSTS"] pub fn naksts (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "EPTYP"] pub fn eptyp (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "EPTYP"] pub fn set_eptyp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "SNPM"] pub fn snpm (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "SNPM"] pub fn set_snpm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stall"] pub fn stall (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stall"] pub fn set_stall (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "CNAK"] pub fn cnak (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "CNAK"] pub fn set_cnak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "SNAK"] pub fn snak (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "SNAK"] pub fn set_snak (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "SD0PID/SEVNFRM"] pub fn sd0pid_sevnfrm (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "SD0PID/SEVNFRM"] pub fn set_sd0pid_sevnfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "SODDFRM"] pub fn soddfrm (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "SODDFRM"] pub fn set_soddfrm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "EPDIS"] pub fn epdis (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "EPDIS"] pub fn set_epdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "EPENA"] pub fn epena (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "EPENA"] pub fn set_epena (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device endpoint-3 interrupt\n          register"] pub struct DOEPINT3 (u32) ; impl DOEPINT3 { pub const RESET_VALUE : u32 = 128u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "XFRC"] pub fn xfrc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "XFRC"] pub fn set_xfrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EPDISD"] pub fn epdisd (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "EPDISD"] pub fn set_epdisd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "STUP"] pub fn stup (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "STUP"] pub fn set_stup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OTEPDIS"] pub fn otepdis (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "OTEPDIS"] pub fn set_otepdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "B2BSTUP"] pub fn b2bstup (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "B2BSTUP"] pub fn set_b2bstup (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "device OUT endpoint-3 transfer size\n          register"] pub struct DOEPTSIZ3 (u32) ; impl DOEPTSIZ3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Transfer size"] pub fn xfrsiz (& self) -> u32 { (self . 0 >> 0u32) & 524287u32 } # [doc = "Transfer size"] pub fn set_xfrsiz (& mut self , value : u32) { let value_masked = value & 524287u32 ; self . 0 &= ! (524287u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Packet count"] pub fn pktcnt (& self) -> u32 { (self . 0 >> 19u32) & 1023u32 } # [doc = "Packet count"] pub fn set_pktcnt (& mut self , value : u32) { let value_masked = value & 1023u32 ; self . 0 &= ! (1023u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Received data PID/SETUP packet\n              count"] pub fn rxdpid_stupcnt (& self) -> u32 { (self . 0 >> 29u32) & 3u32 } # [doc = "Received data PID/SETUP packet\n              count"] pub fn set_rxdpid_stupcnt (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod sdio { # [doc = "Secure digital input/output\n      interface"] pub struct SDIO ; impl SDIO { pub const BASE_ADDR : u64 = 1073818624u64 ; } # [doc = "power control register"] pub struct POWER (u32) ; impl POWER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "PWRCTRL"] pub fn pwrctrl (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "PWRCTRL"] pub fn set_pwrctrl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "SDI clock control register"] pub struct CLKCR (u32) ; impl CLKCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Clock divide factor"] pub fn clkdiv (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Clock divide factor"] pub fn set_clkdiv (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Clock enable bit"] pub fn clken (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Clock enable bit"] pub fn set_clken (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Power saving configuration\n              bit"] pub fn pwrsav (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Power saving configuration\n              bit"] pub fn set_pwrsav (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Clock divider bypass enable\n              bit"] pub fn bypass (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Clock divider bypass enable\n              bit"] pub fn set_bypass (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Wide bus mode enable bit"] pub fn widbus (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Wide bus mode enable bit"] pub fn set_widbus (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "SDIO_CK dephasing selection\n              bit"] pub fn negedge (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "SDIO_CK dephasing selection\n              bit"] pub fn set_negedge (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "HW Flow Control enable"] pub fn hwfc_en (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "HW Flow Control enable"] pub fn set_hwfc_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "argument register"] pub struct ARG (u32) ; impl ARG { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Command argument"] pub fn cmdarg (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Command argument"] pub fn set_cmdarg (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "command register"] pub struct CMD (u32) ; impl CMD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Command index"] pub fn cmdindex (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Command index"] pub fn set_cmdindex (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Wait for response bits"] pub fn waitresp (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Wait for response bits"] pub fn set_waitresp (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "CPSM waits for interrupt\n              request"] pub fn waitint (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "CPSM waits for interrupt\n              request"] pub fn set_waitint (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CPSM Waits for ends of data transfer\n              (CmdPend internal signal)."] pub fn waitpend (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CPSM Waits for ends of data transfer\n              (CmdPend internal signal)."] pub fn set_waitpend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Command path state machine (CPSM) Enable\n              bit"] pub fn cpsmen (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Command path state machine (CPSM) Enable\n              bit"] pub fn set_cpsmen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "SD I/O suspend command"] pub fn sdiosuspend (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "SD I/O suspend command"] pub fn set_sdiosuspend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Enable CMD completion"] pub fn encmdcompl (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Enable CMD completion"] pub fn set_encmdcompl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "not Interrupt Enable"] pub fn nien (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "not Interrupt Enable"] pub fn set_nien (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "CE-ATA command"] pub fn ce_atacmd (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "CE-ATA command"] pub fn set_ce_atacmd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "command response register"] pub struct RESPCMD (u32) ; impl RESPCMD { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Response command index"] pub fn respcmd (& self) -> u32 { (self . 0 >> 0u32) & 63u32 } # [doc = "Response command index"] pub fn set_respcmd (& mut self , value : u32) { let value_masked = value & 63u32 ; self . 0 &= ! (63u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "response 1..4 register"] pub struct RESP1 (u32) ; impl RESP1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Card Status"] pub fn cardstatus1 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Card Status"] pub fn set_cardstatus1 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "response 1..4 register"] pub struct RESP2 (u32) ; impl RESP2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Card Status"] pub fn cardstatus2 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Card Status"] pub fn set_cardstatus2 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "response 1..4 register"] pub struct RESP3 (u32) ; impl RESP3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Card Status"] pub fn cardstatus3 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Card Status"] pub fn set_cardstatus3 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "response 1..4 register"] pub struct RESP4 (u32) ; impl RESP4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Card Status"] pub fn cardstatus4 (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Card Status"] pub fn set_cardstatus4 (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data timer register"] pub struct DTIMER (u32) ; impl DTIMER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data timeout period"] pub fn datatime (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Data timeout period"] pub fn set_datatime (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data length register"] pub struct DLEN (u32) ; impl DLEN { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data length value"] pub fn datalength (& self) -> u32 { (self . 0 >> 0u32) & 33554431u32 } # [doc = "Data length value"] pub fn set_datalength (& mut self , value : u32) { let value_masked = value & 33554431u32 ; self . 0 &= ! (33554431u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data control register"] pub struct DCTRL (u32) ; impl DCTRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DTEN"] pub fn dten (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "DTEN"] pub fn set_dten (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data transfer direction\n              selection"] pub fn dtdir (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Data transfer direction\n              selection"] pub fn set_dtdir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Data transfer mode selection 1: Stream\n              or SDIO multibyte data transfer."] pub fn dtmode (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Data transfer mode selection 1: Stream\n              or SDIO multibyte data transfer."] pub fn set_dtmode (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "DMA enable bit"] pub fn dmaen (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "DMA enable bit"] pub fn set_dmaen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Data block size"] pub fn dblocksize (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Data block size"] pub fn set_dblocksize (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Read wait start"] pub fn rwstart (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Read wait start"] pub fn set_rwstart (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Read wait stop"] pub fn rwstop (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Read wait stop"] pub fn set_rwstop (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Read wait mode"] pub fn rwmod (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Read wait mode"] pub fn set_rwmod (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "SD I/O enable functions"] pub fn sdioen (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "SD I/O enable functions"] pub fn set_sdioen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data counter register"] pub struct DCOUNT (u32) ; impl DCOUNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data count value"] pub fn datacount (& self) -> u32 { (self . 0 >> 0u32) & 33554431u32 } # [doc = "Data count value"] pub fn set_datacount (& mut self , value : u32) { let value_masked = value & 33554431u32 ; self . 0 &= ! (33554431u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct STA (u32) ; impl STA { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Command response received (CRC check\n              failed)"] pub fn ccrcfail (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Command response received (CRC check\n              failed)"] pub fn set_ccrcfail (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data block sent/received (CRC check\n              failed)"] pub fn dcrcfail (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Data block sent/received (CRC check\n              failed)"] pub fn set_dcrcfail (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Command response timeout"] pub fn ctimeout (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Command response timeout"] pub fn set_ctimeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Data timeout"] pub fn dtimeout (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Data timeout"] pub fn set_dtimeout (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transmit FIFO underrun\n              error"] pub fn txunderr (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transmit FIFO underrun\n              error"] pub fn set_txunderr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Received FIFO overrun\n              error"] pub fn rxoverr (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Received FIFO overrun\n              error"] pub fn set_rxoverr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Command response received (CRC check\n              passed)"] pub fn cmdrend (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Command response received (CRC check\n              passed)"] pub fn set_cmdrend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Command sent (no response\n              required)"] pub fn cmdsent (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Command sent (no response\n              required)"] pub fn set_cmdsent (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Data end (data counter, SDIDCOUNT, is\n              zero)"] pub fn dataend (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Data end (data counter, SDIDCOUNT, is\n              zero)"] pub fn set_dataend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Start bit not detected on all data\n              signals in wide bus mode"] pub fn stbiterr (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Start bit not detected on all data\n              signals in wide bus mode"] pub fn set_stbiterr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data block sent/received (CRC check\n              passed)"] pub fn dbckend (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data block sent/received (CRC check\n              passed)"] pub fn set_dbckend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Command transfer in\n              progress"] pub fn cmdact (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Command transfer in\n              progress"] pub fn set_cmdact (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Data transmit in progress"] pub fn txact (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Data transmit in progress"] pub fn set_txact (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Data receive in progress"] pub fn rxact (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Data receive in progress"] pub fn set_rxact (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Transmit FIFO half empty: at least 8\n              words can be written into the FIFO"] pub fn txfifohe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Transmit FIFO half empty: at least 8\n              words can be written into the FIFO"] pub fn set_txfifohe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Receive FIFO half full: there are at\n              least 8 words in the FIFO"] pub fn rxfifohf (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Receive FIFO half full: there are at\n              least 8 words in the FIFO"] pub fn set_rxfifohf (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Transmit FIFO full"] pub fn txfifof (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Transmit FIFO full"] pub fn set_txfifof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Receive FIFO full"] pub fn rxfifof (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Receive FIFO full"] pub fn set_rxfifof (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Transmit FIFO empty"] pub fn txfifoe (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Transmit FIFO empty"] pub fn set_txfifoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Receive FIFO empty"] pub fn rxfifoe (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Receive FIFO empty"] pub fn set_rxfifoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data available in transmit\n              FIFO"] pub fn txdavl (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Data available in transmit\n              FIFO"] pub fn set_txdavl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Data available in receive\n              FIFO"] pub fn rxdavl (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Data available in receive\n              FIFO"] pub fn set_rxdavl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "SDIO interrupt received"] pub fn sdioit (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "SDIO interrupt received"] pub fn set_sdioit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CE-ATA command completion signal\n              received for CMD61"] pub fn ceataend (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "CE-ATA command completion signal\n              received for CMD61"] pub fn set_ceataend (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "interrupt clear register"] pub struct ICR (u32) ; impl ICR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CCRCFAIL flag clear bit"] pub fn ccrcfailc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "CCRCFAIL flag clear bit"] pub fn set_ccrcfailc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DCRCFAIL flag clear bit"] pub fn dcrcfailc (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "DCRCFAIL flag clear bit"] pub fn set_dcrcfailc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "CTIMEOUT flag clear bit"] pub fn ctimeoutc (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "CTIMEOUT flag clear bit"] pub fn set_ctimeoutc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "DTIMEOUT flag clear bit"] pub fn dtimeoutc (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "DTIMEOUT flag clear bit"] pub fn set_dtimeoutc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "TXUNDERR flag clear bit"] pub fn txunderrc (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "TXUNDERR flag clear bit"] pub fn set_txunderrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "RXOVERR flag clear bit"] pub fn rxoverrc (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "RXOVERR flag clear bit"] pub fn set_rxoverrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "CMDREND flag clear bit"] pub fn cmdrendc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "CMDREND flag clear bit"] pub fn set_cmdrendc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "CMDSENT flag clear bit"] pub fn cmdsentc (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "CMDSENT flag clear bit"] pub fn set_cmdsentc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "DATAEND flag clear bit"] pub fn dataendc (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "DATAEND flag clear bit"] pub fn set_dataendc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "STBITERR flag clear bit"] pub fn stbiterrc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "STBITERR flag clear bit"] pub fn set_stbiterrc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "DBCKEND flag clear bit"] pub fn dbckendc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "DBCKEND flag clear bit"] pub fn set_dbckendc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "SDIOIT flag clear bit"] pub fn sdioitc (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "SDIOIT flag clear bit"] pub fn set_sdioitc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CEATAEND flag clear bit"] pub fn ceataendc (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "CEATAEND flag clear bit"] pub fn set_ceataendc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "mask register"] pub struct MASK (u32) ; impl MASK { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Command CRC fail interrupt\n              enable"] pub fn ccrcfailie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Command CRC fail interrupt\n              enable"] pub fn set_ccrcfailie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Data CRC fail interrupt\n              enable"] pub fn dcrcfailie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Data CRC fail interrupt\n              enable"] pub fn set_dcrcfailie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Command timeout interrupt\n              enable"] pub fn ctimeoutie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Command timeout interrupt\n              enable"] pub fn set_ctimeoutie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Data timeout interrupt\n              enable"] pub fn dtimeoutie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Data timeout interrupt\n              enable"] pub fn set_dtimeoutie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Tx FIFO underrun error interrupt\n              enable"] pub fn txunderrie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Tx FIFO underrun error interrupt\n              enable"] pub fn set_txunderrie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Rx FIFO overrun error interrupt\n              enable"] pub fn rxoverrie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Rx FIFO overrun error interrupt\n              enable"] pub fn set_rxoverrie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Command response received interrupt\n              enable"] pub fn cmdrendie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Command response received interrupt\n              enable"] pub fn set_cmdrendie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Command sent interrupt\n              enable"] pub fn cmdsentie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Command sent interrupt\n              enable"] pub fn set_cmdsentie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Data end interrupt enable"] pub fn dataendie (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Data end interrupt enable"] pub fn set_dataendie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Start bit error interrupt\n              enable"] pub fn stbiterrie (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Start bit error interrupt\n              enable"] pub fn set_stbiterrie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Data block end interrupt\n              enable"] pub fn dbckendie (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Data block end interrupt\n              enable"] pub fn set_dbckendie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Command acting interrupt\n              enable"] pub fn cmdactie (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Command acting interrupt\n              enable"] pub fn set_cmdactie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Data transmit acting interrupt\n              enable"] pub fn txactie (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Data transmit acting interrupt\n              enable"] pub fn set_txactie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Data receive acting interrupt\n              enable"] pub fn rxactie (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Data receive acting interrupt\n              enable"] pub fn set_rxactie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Tx FIFO half empty interrupt\n              enable"] pub fn txfifoheie (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Tx FIFO half empty interrupt\n              enable"] pub fn set_txfifoheie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Rx FIFO half full interrupt\n              enable"] pub fn rxfifohfie (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Rx FIFO half full interrupt\n              enable"] pub fn set_rxfifohfie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Tx FIFO full interrupt\n              enable"] pub fn txfifofie (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Tx FIFO full interrupt\n              enable"] pub fn set_txfifofie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Rx FIFO full interrupt\n              enable"] pub fn rxfifofie (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Rx FIFO full interrupt\n              enable"] pub fn set_rxfifofie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Tx FIFO empty interrupt\n              enable"] pub fn txfifoeie (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Tx FIFO empty interrupt\n              enable"] pub fn set_txfifoeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Rx FIFO empty interrupt\n              enable"] pub fn rxfifoeie (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Rx FIFO empty interrupt\n              enable"] pub fn set_rxfifoeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Data available in Tx FIFO interrupt\n              enable"] pub fn txdavlie (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Data available in Tx FIFO interrupt\n              enable"] pub fn set_txdavlie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Data available in Rx FIFO interrupt\n              enable"] pub fn rxdavlie (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Data available in Rx FIFO interrupt\n              enable"] pub fn set_rxdavlie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "SDIO mode interrupt received interrupt\n              enable"] pub fn sdioitie (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "SDIO mode interrupt received interrupt\n              enable"] pub fn set_sdioitie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "CE-ATA command completion signal\n              received interrupt enable"] pub fn ceataendie (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "CE-ATA command completion signal\n              received interrupt enable"] pub fn set_ceataendie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "FIFO counter register"] pub struct FIFOCNT (u32) ; impl FIFOCNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Remaining number of words to be written\n              to or read from the FIFO."] pub fn fifocount (& self) -> u32 { (self . 0 >> 0u32) & 16777215u32 } # [doc = "Remaining number of words to be written\n              to or read from the FIFO."] pub fn set_fifocount (& mut self , value : u32) { let value_masked = value & 16777215u32 ; self . 0 &= ! (16777215u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "data FIFO register"] pub struct FIFO (u32) ; impl FIFO { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Receive and transmit FIFO\n              data"] pub fn fifodata (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Receive and transmit FIFO\n              data"] pub fn set_fifodata (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod iwdg { # [doc = "Independent watchdog"] pub struct IWDG ; impl IWDG { pub const BASE_ADDR : u64 = 1073754112u64 ; } # [doc = "Key register"] pub struct KR (u32) ; impl KR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Key value"] pub fn key (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Key value"] pub fn set_key (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Prescaler register"] pub struct PR (u32) ; impl PR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler divider"] pub fn pr (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Prescaler divider"] pub fn set_pr (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Reload register"] pub struct RLR (u32) ; impl RLR { pub const RESET_VALUE : u32 = 4095u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Watchdog counter reload\n              value"] pub fn rl (& self) -> u32 { (self . 0 >> 0u32) & 4095u32 } # [doc = "Watchdog counter reload\n              value"] pub fn set_rl (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Watchdog prescaler value\n              update"] pub fn pvu (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Watchdog prescaler value\n              update"] pub fn set_pvu (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Watchdog counter reload value\n              update"] pub fn rvu (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Watchdog counter reload value\n              update"] pub fn set_rvu (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod wwdg { # [doc = "Window watchdog"] pub struct WWDG ; impl WWDG { pub const BASE_ADDR : u64 = 1073753088u64 ; } # [doc = "Control register"] pub struct CR (u32) ; impl CR { pub const RESET_VALUE : u32 = 127u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "7-bit counter (MSB to LSB)"] pub fn t (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "7-bit counter (MSB to LSB)"] pub fn set_t (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Activation bit"] pub fn wdga (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Activation bit"] pub fn set_wdga (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Configuration register"] pub struct CFR (u32) ; impl CFR { pub const RESET_VALUE : u32 = 127u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "7-bit window value"] pub fn w (& self) -> u32 { (self . 0 >> 0u32) & 127u32 } # [doc = "7-bit window value"] pub fn set_w (& mut self , value : u32) { let value_masked = value & 127u32 ; self . 0 &= ! (127u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Timer base"] pub fn wdgtb0 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Timer base"] pub fn set_wdgtb0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Timer base"] pub fn wdgtb1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Timer base"] pub fn set_wdgtb1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Early wakeup interrupt"] pub fn ewi (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Early wakeup interrupt"] pub fn set_ewi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Early wakeup interrupt\n              flag"] pub fn ewif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Early wakeup interrupt\n              flag"] pub fn set_ewif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod dma2 { # [doc = "DMA controller"] pub struct DMA2 ; impl DMA2 { pub const BASE_ADDR : u64 = 1073898496u64 ; } # [doc = "low interrupt status register"] pub struct LISR (u32) ; impl LISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif1 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif1 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif2 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif2 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif2 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn feif3 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=3..0)"] pub fn set_feif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn dmeif3 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=3..0)"] pub fn set_dmeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn teif3 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=3..0)"] pub fn set_teif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn htif3 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=3..0)"] pub fn set_htif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn tcif3 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x = 3..0)"] pub fn set_tcif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "high interrupt status register"] pub struct HISR (u32) ; impl HISR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif4 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif4 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif4 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif5 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif5 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif5 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif5 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif6 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif6 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif6 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif6 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif6 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn feif7 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x FIFO error interrupt flag\n              (x=7..4)"] pub fn set_feif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn dmeif7 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x direct mode error interrupt\n              flag (x=7..4)"] pub fn set_dmeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn teif7 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x transfer error interrupt flag\n              (x=7..4)"] pub fn set_teif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn htif7 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x half transfer interrupt flag\n              (x=7..4)"] pub fn set_htif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn tcif7 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x transfer complete interrupt\n              flag (x=7..4)"] pub fn set_tcif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "low interrupt flag clear\n          register"] pub struct LIFCR (u32) ; impl LIFCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif0 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif0 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif0 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif0 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif1 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif1 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif1 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif1 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif2 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif2 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif2 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn cfeif3 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 3..0)"] pub fn set_cfeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn cdmeif3 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 3..0)"] pub fn set_cdmeif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn cteif3 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 3..0)"] pub fn set_cteif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn chtif3 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 3..0)"] pub fn set_chtif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn ctcif3 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 3..0)"] pub fn set_ctcif3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "high interrupt flag clear\n          register"] pub struct HIFCR (u32) ; impl HIFCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif4 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif4 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif4 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif4 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif5 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif5 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif5 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif5 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif5 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif6 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif6 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif6 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif6 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif6 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn cfeif7 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Stream x clear FIFO error interrupt flag\n              (x = 7..4)"] pub fn set_cfeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn cdmeif7 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Stream x clear direct mode error\n              interrupt flag (x = 7..4)"] pub fn set_cdmeif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn cteif7 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Stream x clear transfer error interrupt\n              flag (x = 7..4)"] pub fn set_cteif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn chtif7 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Stream x clear half transfer interrupt\n              flag (x = 7..4)"] pub fn set_chtif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn ctcif7 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Stream x clear transfer complete\n              interrupt flag (x = 7..4)"] pub fn set_ctcif7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S0CR (u32) ; impl S0CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S0NDTR (u32) ; impl S0NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S0PAR (u32) ; impl S0PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S0M0AR (u32) ; impl S0M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S0M1AR (u32) ; impl S0M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S0FCR (u32) ; impl S0FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S1CR (u32) ; impl S1CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S1NDTR (u32) ; impl S1NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S1PAR (u32) ; impl S1PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S1M0AR (u32) ; impl S1M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S1M1AR (u32) ; impl S1M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S1FCR (u32) ; impl S1FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S2CR (u32) ; impl S2CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S2NDTR (u32) ; impl S2NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S2PAR (u32) ; impl S2PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S2M0AR (u32) ; impl S2M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S2M1AR (u32) ; impl S2M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S2FCR (u32) ; impl S2FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S3CR (u32) ; impl S3CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S3NDTR (u32) ; impl S3NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S3PAR (u32) ; impl S3PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S3M0AR (u32) ; impl S3M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S3M1AR (u32) ; impl S3M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S3FCR (u32) ; impl S3FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S4CR (u32) ; impl S4CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S4NDTR (u32) ; impl S4NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S4PAR (u32) ; impl S4PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S4M0AR (u32) ; impl S4M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S4M1AR (u32) ; impl S4M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S4FCR (u32) ; impl S4FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S5CR (u32) ; impl S5CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S5NDTR (u32) ; impl S5NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S5PAR (u32) ; impl S5PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S5M0AR (u32) ; impl S5M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S5M1AR (u32) ; impl S5M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S5FCR (u32) ; impl S5FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S6CR (u32) ; impl S6CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S6NDTR (u32) ; impl S6NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S6PAR (u32) ; impl S6PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S6M0AR (u32) ; impl S6M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S6M1AR (u32) ; impl S6M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S6FCR (u32) ; impl S6FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x configuration\n          register"] pub struct S7CR (u32) ; impl S7CR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn en (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stream enable / flag stream ready when\n              read low"] pub fn set_en (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode error interrupt\n              enable"] pub fn dmeie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Direct mode error interrupt\n              enable"] pub fn set_dmeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Transfer error interrupt\n              enable"] pub fn teie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Transfer error interrupt\n              enable"] pub fn set_teie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half transfer interrupt\n              enable"] pub fn htie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half transfer interrupt\n              enable"] pub fn set_htie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Transfer complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Transfer complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Peripheral flow controller"] pub fn pfctrl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Peripheral flow controller"] pub fn set_pfctrl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Data transfer direction"] pub fn dir (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Data transfer direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Circular mode"] pub fn circ (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Circular mode"] pub fn set_circ (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Peripheral increment mode"] pub fn pinc (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Peripheral increment mode"] pub fn set_pinc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Memory increment mode"] pub fn minc (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Memory increment mode"] pub fn set_minc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Peripheral data size"] pub fn psize (& self) -> u32 { (self . 0 >> 11u32) & 3u32 } # [doc = "Peripheral data size"] pub fn set_psize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Memory data size"] pub fn msize (& self) -> u32 { (self . 0 >> 13u32) & 3u32 } # [doc = "Memory data size"] pub fn set_msize (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Peripheral increment offset\n              size"] pub fn pincos (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Peripheral increment offset\n              size"] pub fn set_pincos (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Priority level"] pub fn pl (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Priority level"] pub fn set_pl (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Double buffer mode"] pub fn dbm (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Double buffer mode"] pub fn set_dbm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Current target (only in double buffer\n              mode)"] pub fn ct (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Current target (only in double buffer\n              mode)"] pub fn set_ct (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "ACK"] pub fn ack (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "ACK"] pub fn set_ack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Peripheral burst transfer\n              configuration"] pub fn pburst (& self) -> u32 { (self . 0 >> 21u32) & 3u32 } # [doc = "Peripheral burst transfer\n              configuration"] pub fn set_pburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Memory burst transfer\n              configuration"] pub fn mburst (& self) -> u32 { (self . 0 >> 23u32) & 3u32 } # [doc = "Memory burst transfer\n              configuration"] pub fn set_mburst (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Channel selection"] pub fn chsel (& self) -> u32 { (self . 0 >> 25u32) & 7u32 } # [doc = "Channel selection"] pub fn set_chsel (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x number of data\n          register"] pub struct S7NDTR (u32) ; impl S7NDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Number of data items to\n              transfer"] pub fn ndt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Number of data items to\n              transfer"] pub fn set_ndt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x peripheral address\n          register"] pub struct S7PAR (u32) ; impl S7PAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Peripheral address"] pub fn pa (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Peripheral address"] pub fn set_pa (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 0 address\n          register"] pub struct S7M0AR (u32) ; impl S7M0AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 0 address"] pub fn m0a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 0 address"] pub fn set_m0a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x memory 1 address\n          register"] pub struct S7M1AR (u32) ; impl S7M1AR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn m1a (& self) -> u32 { (self . 0 >> 0u32) & 4294967295u32 } # [doc = "Memory 1 address (used in case of Double\n              buffer mode)"] pub fn set_m1a (& mut self , value : u32) { let value_masked = value & 4294967295u32 ; self . 0 &= ! (4294967295u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "stream x FIFO control register"] pub struct S7FCR (u32) ; impl S7FCR { pub const RESET_VALUE : u32 = 33u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "FIFO threshold selection"] pub fn fth (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "FIFO threshold selection"] pub fn set_fth (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Direct mode disable"] pub fn dmdis (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Direct mode disable"] pub fn set_dmdis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "FIFO status"] pub fn fs (& self) -> u32 { (self . 0 >> 3u32) & 7u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn feie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "FIFO error interrupt\n              enable"] pub fn set_feie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod usart2 { # [doc = "Universal synchronous asynchronous receiver\n      transmitter"] pub struct USART2 ; impl USART2 { pub const BASE_ADDR : u64 = 1073759232u64 ; } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 12582912u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Parity error"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Framing error"] pub fn fe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Noise detected flag"] pub fn nf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Overrun error"] pub fn ore (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IDLE line detected"] pub fn idle (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn set_rxne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete"] pub fn tc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete"] pub fn set_tc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transmit data register\n              empty"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn lbd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn set_lbd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS flag"] pub fn cts (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS flag"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data value"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Data value"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate register"] pub struct BRR (u32) ; impl BRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "fraction of USARTDIV"] pub fn div_fraction (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "fraction of USARTDIV"] pub fn set_div_fraction (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "mantissa of USARTDIV"] pub fn div_mantissa (& self) -> u32 { (self . 0 >> 4u32) & 4095u32 } # [doc = "mantissa of USARTDIV"] pub fn set_div_mantissa (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Send break"] pub fn sbk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Send break"] pub fn set_sbk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receiver wakeup"] pub fn rwu (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receiver wakeup"] pub fn set_rwu (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receiver enable"] pub fn re (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receiver enable"] pub fn set_re (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Transmitter enable"] pub fn te (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Transmitter enable"] pub fn set_te (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IDLE interrupt enable"] pub fn idleie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IDLE interrupt enable"] pub fn set_idleie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "RXNE interrupt enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "RXNE interrupt enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXE interrupt enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TXE interrupt enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "PE interrupt enable"] pub fn peie (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "PE interrupt enable"] pub fn set_peie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Parity selection"] pub fn ps (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Parity selection"] pub fn set_ps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Parity control enable"] pub fn pce (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Parity control enable"] pub fn set_pce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Wakeup method"] pub fn wake (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Wakeup method"] pub fn set_wake (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Word length"] pub fn m (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Word length"] pub fn set_m (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "USART enable"] pub fn ue (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "USART enable"] pub fn set_ue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Oversampling mode"] pub fn over8 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Oversampling mode"] pub fn set_over8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address of the USART node"] pub fn add (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Address of the USART node"] pub fn set_add (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "lin break detection length"] pub fn lbdl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "lin break detection length"] pub fn set_lbdl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "LIN break detection interrupt\n              enable"] pub fn lbdie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "LIN break detection interrupt\n              enable"] pub fn set_lbdie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Last bit clock pulse"] pub fn lbcl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Last bit clock pulse"] pub fn set_lbcl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Clock enable"] pub fn clken (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Clock enable"] pub fn set_clken (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "STOP bits"] pub fn stop (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "STOP bits"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "LIN mode enable"] pub fn linen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "LIN mode enable"] pub fn set_linen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 3"] pub struct CR3 (u32) ; impl CR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Error interrupt enable"] pub fn eie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_eie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IrDA mode enable"] pub fn iren (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IrDA mode enable"] pub fn set_iren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IrDA low-power"] pub fn irlp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IrDA low-power"] pub fn set_irlp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half-duplex selection"] pub fn hdsel (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half-duplex selection"] pub fn set_hdsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Smartcard NACK enable"] pub fn nack (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Smartcard NACK enable"] pub fn set_nack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Smartcard mode enable"] pub fn scen (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Smartcard mode enable"] pub fn set_scen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "DMA enable receiver"] pub fn dmar (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "DMA enable receiver"] pub fn set_dmar (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "DMA enable transmitter"] pub fn dmat (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "DMA enable transmitter"] pub fn set_dmat (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "RTS enable"] pub fn rtse (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "RTS enable"] pub fn set_rtse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS enable"] pub fn ctse (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS enable"] pub fn set_ctse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "CTS interrupt enable"] pub fn ctsie (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "CTS interrupt enable"] pub fn set_ctsie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "One sample bit method\n              enable"] pub fn onebit (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "One sample bit method\n              enable"] pub fn set_onebit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Guard time and prescaler\n          register"] pub struct GTPR (u32) ; impl GTPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Guard time value"] pub fn gt (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Guard time value"] pub fn set_gt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod usart1 { # [doc = "Universal synchronous asynchronous receiver\n      transmitter"] pub struct USART1 ; impl USART1 { pub const BASE_ADDR : u64 = 1073811456u64 ; } # [doc = "Status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 12582912u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Parity error"] pub fn pe (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Framing error"] pub fn fe (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Noise detected flag"] pub fn nf (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Overrun error"] pub fn ore (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "IDLE line detected"] pub fn idle (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn rxne (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Read data register not\n              empty"] pub fn set_rxne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete"] pub fn tc (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete"] pub fn set_tc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Transmit data register\n              empty"] pub fn txe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn lbd (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "LIN break detection flag"] pub fn set_lbd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS flag"] pub fn cts (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS flag"] pub fn set_cts (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Data register"] pub struct DR (u32) ; impl DR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Data value"] pub fn dr (& self) -> u32 { (self . 0 >> 0u32) & 511u32 } # [doc = "Data value"] pub fn set_dr (& mut self , value : u32) { let value_masked = value & 511u32 ; self . 0 &= ! (511u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Baud rate register"] pub struct BRR (u32) ; impl BRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "fraction of USARTDIV"] pub fn div_fraction (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "fraction of USARTDIV"] pub fn set_div_fraction (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "mantissa of USARTDIV"] pub fn div_mantissa (& self) -> u32 { (self . 0 >> 4u32) & 4095u32 } # [doc = "mantissa of USARTDIV"] pub fn set_div_mantissa (& mut self , value : u32) { let value_masked = value & 4095u32 ; self . 0 &= ! (4095u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Send break"] pub fn sbk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Send break"] pub fn set_sbk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Receiver wakeup"] pub fn rwu (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Receiver wakeup"] pub fn set_rwu (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Receiver enable"] pub fn re (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Receiver enable"] pub fn set_re (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Transmitter enable"] pub fn te (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Transmitter enable"] pub fn set_te (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "IDLE interrupt enable"] pub fn idleie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "IDLE interrupt enable"] pub fn set_idleie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "RXNE interrupt enable"] pub fn rxneie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "RXNE interrupt enable"] pub fn set_rxneie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Transmission complete interrupt\n              enable"] pub fn tcie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Transmission complete interrupt\n              enable"] pub fn set_tcie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "TXE interrupt enable"] pub fn txeie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TXE interrupt enable"] pub fn set_txeie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "PE interrupt enable"] pub fn peie (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "PE interrupt enable"] pub fn set_peie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Parity selection"] pub fn ps (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Parity selection"] pub fn set_ps (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Parity control enable"] pub fn pce (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Parity control enable"] pub fn set_pce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Wakeup method"] pub fn wake (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Wakeup method"] pub fn set_wake (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Word length"] pub fn m (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Word length"] pub fn set_m (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "USART enable"] pub fn ue (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "USART enable"] pub fn set_ue (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Oversampling mode"] pub fn over8 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Oversampling mode"] pub fn set_over8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Address of the USART node"] pub fn add (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Address of the USART node"] pub fn set_add (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "lin break detection length"] pub fn lbdl (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "lin break detection length"] pub fn set_lbdl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "LIN break detection interrupt\n              enable"] pub fn lbdie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "LIN break detection interrupt\n              enable"] pub fn set_lbdie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Last bit clock pulse"] pub fn lbcl (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Last bit clock pulse"] pub fn set_lbcl (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Clock phase"] pub fn cpha (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Clock phase"] pub fn set_cpha (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Clock polarity"] pub fn cpol (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Clock polarity"] pub fn set_cpol (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Clock enable"] pub fn clken (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Clock enable"] pub fn set_clken (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "STOP bits"] pub fn stop (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "STOP bits"] pub fn set_stop (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "LIN mode enable"] pub fn linen (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "LIN mode enable"] pub fn set_linen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Control register 3"] pub struct CR3 (u32) ; impl CR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Error interrupt enable"] pub fn eie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Error interrupt enable"] pub fn set_eie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "IrDA mode enable"] pub fn iren (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "IrDA mode enable"] pub fn set_iren (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "IrDA low-power"] pub fn irlp (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "IrDA low-power"] pub fn set_irlp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Half-duplex selection"] pub fn hdsel (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Half-duplex selection"] pub fn set_hdsel (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Smartcard NACK enable"] pub fn nack (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Smartcard NACK enable"] pub fn set_nack (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Smartcard mode enable"] pub fn scen (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Smartcard mode enable"] pub fn set_scen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "DMA enable receiver"] pub fn dmar (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "DMA enable receiver"] pub fn set_dmar (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "DMA enable transmitter"] pub fn dmat (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "DMA enable transmitter"] pub fn set_dmat (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "RTS enable"] pub fn rtse (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "RTS enable"] pub fn set_rtse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "CTS enable"] pub fn ctse (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "CTS enable"] pub fn set_ctse (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "CTS interrupt enable"] pub fn ctsie (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "CTS interrupt enable"] pub fn set_ctsie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "One sample bit method\n              enable"] pub fn onebit (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "One sample bit method\n              enable"] pub fn set_onebit (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Guard time and prescaler\n          register"] pub struct GTPR (u32) ; impl GTPR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Guard time value"] pub fn gt (& self) -> u32 { (self . 0 >> 8u32) & 255u32 } # [doc = "Guard time value"] pub fn set_gt (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod otg_fs_pwrclk { # [doc = "USB on the go full speed"] pub struct OTG_FS_PWRCLK ; impl OTG_FS_PWRCLK { pub const BASE_ADDR : u64 = 1342180864u64 ; } # [doc = "OTG_FS power and clock gating control\n          register"] pub struct FS_PCGCCTL (u32) ; impl FS_PCGCCTL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Stop PHY clock"] pub fn stppclk (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Stop PHY clock"] pub fn set_stppclk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Gate HCLK"] pub fn gatehclk (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Gate HCLK"] pub fn set_gatehclk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "PHY Suspended"] pub fn physusp (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "PHY Suspended"] pub fn set_physusp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim10 { # [doc = "General-purpose-timers"] pub struct TIM10 ; impl TIM10 { pub const BASE_ADDR : u64 = 1073824768u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output Compare 1 fast\n              enable"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output Compare 1 fast\n              enable"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output Compare 1 preload\n              enable"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output Compare 1 preload\n              enable"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output Compare 1 mode"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output Compare 1 mode"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "counter value"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "counter value"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Auto-reload value"] pub fn arr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Auto-reload value"] pub fn set_arr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 value"] pub fn ccr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 1 value"] pub fn set_ccr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpiod { # [doc = "General-purpose I/Os"] pub struct GPIOD ; impl GPIOD { pub const BASE_ADDR : u64 = 1073875968u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod gpioh { # [doc = "General-purpose I/Os"] pub struct GPIOH ; impl GPIOH { pub const BASE_ADDR : u64 = 1073880064u64 ; } # [doc = "GPIO port mode register"] pub struct MODER (u32) ; impl MODER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn moder15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_moder15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output type register"] pub struct OTYPER (u32) ; impl OTYPER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ot15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ot15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output speed\n          register"] pub struct OSPEEDR (u32) ; impl OSPEEDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn ospeedr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_ospeedr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port pull-up/pull-down\n          register"] pub struct PUPDR (u32) ; impl PUPDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr0 (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr0 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr1 (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr1 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr2 (& self) -> u32 { (self . 0 >> 4u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr2 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr3 (& self) -> u32 { (self . 0 >> 6u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr3 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr4 (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr4 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr5 (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr5 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr6 (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr6 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr7 (& self) -> u32 { (self . 0 >> 14u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr7 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr8 (& self) -> u32 { (self . 0 >> 16u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr8 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr9 (& self) -> u32 { (self . 0 >> 18u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr9 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr10 (& self) -> u32 { (self . 0 >> 20u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr10 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr11 (& self) -> u32 { (self . 0 >> 22u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr11 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr12 (& self) -> u32 { (self . 0 >> 24u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr12 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr13 (& self) -> u32 { (self . 0 >> 26u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr13 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr14 (& self) -> u32 { (self . 0 >> 28u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr14 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn pupdr15 (& self) -> u32 { (self . 0 >> 30u32) & 3u32 } # [doc = "Port x configuration bits (y =\n              0..15)"] pub fn set_pupdr15 (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port input data register"] pub struct IDR (u32) ; impl IDR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port input data (y =\n              0..15)"] pub fn idr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port input data (y =\n              0..15)"] pub fn set_idr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port output data register"] pub struct ODR (u32) ; impl ODR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port output data (y =\n              0..15)"] pub fn odr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port output data (y =\n              0..15)"] pub fn set_odr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port bit set/reset\n          register"] pub struct BSRR (u32) ; impl BSRR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn bs15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_bs15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn br0 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x set bit y (y=\n              0..15)"] pub fn set_br0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br1 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br2 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br3 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br4 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br5 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br6 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br7 (& self) -> u32 { (self . 0 >> 23u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 23u32) ; self . 0 |= value_masked << 23u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br8 (& self) -> u32 { (self . 0 >> 24u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br9 (& self) -> u32 { (self . 0 >> 25u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 25u32) ; self . 0 |= value_masked << 25u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br10 (& self) -> u32 { (self . 0 >> 26u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 26u32) ; self . 0 |= value_masked << 26u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br11 (& self) -> u32 { (self . 0 >> 27u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 27u32) ; self . 0 |= value_masked << 27u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br12 (& self) -> u32 { (self . 0 >> 28u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br13 (& self) -> u32 { (self . 0 >> 29u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 29u32) ; self . 0 |= value_masked << 29u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br14 (& self) -> u32 { (self . 0 >> 30u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 30u32) ; self . 0 |= value_masked << 30u32 ; } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn br15 (& self) -> u32 { (self . 0 >> 31u32) & 1u32 } # [doc = "Port x reset bit y (y =\n              0..15)"] pub fn set_br15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 31u32) ; self . 0 |= value_masked << 31u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO port configuration lock\n          register"] pub struct LCKR (u32) ; impl LCKR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lck15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lck15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn lckk (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Port x lock bit y (y=\n              0..15)"] pub fn set_lckk (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function low\n          register"] pub struct AFRL (u32) ; impl AFRL { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl4 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl5 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl6 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn afrl7 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 0..7)"] pub fn set_afrl7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "GPIO alternate function high\n          register"] pub struct AFRH (u32) ; impl AFRH { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh12 (& self) -> u32 { (self . 0 >> 16u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh13 (& self) -> u32 { (self . 0 >> 20u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh14 (& self) -> u32 { (self . 0 >> 24u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 24u32) ; self . 0 |= value_masked << 24u32 ; } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn afrh15 (& self) -> u32 { (self . 0 >> 28u32) & 15u32 } # [doc = "Alternate function selection for port x\n              bit y (y = 8..15)"] pub fn set_afrh15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 28u32) ; self . 0 |= value_masked << 28u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim1 { # [doc = "Advanced-timers"] pub struct TIM1 ; impl TIM1 { pub const BASE_ADDR : u64 = 1073807360u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare preloaded\n              control"] pub fn ccpc (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/compare preloaded\n              control"] pub fn set_ccpc (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare control update\n              selection"] pub fn ccus (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare control update\n              selection"] pub fn set_ccus (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Output Idle state 1"] pub fn ois1 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Output Idle state 1"] pub fn set_ois1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output Idle state 1"] pub fn ois1n (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Output Idle state 1"] pub fn set_ois1n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Output Idle state 2"] pub fn ois2 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output Idle state 2"] pub fn set_ois2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output Idle state 2"] pub fn ois2n (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output Idle state 2"] pub fn set_ois2n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output Idle state 3"] pub fn ois3 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Output Idle state 3"] pub fn set_ois3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output Idle state 3"] pub fn ois3n (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Output Idle state 3"] pub fn set_ois3n (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Output Idle state 4"] pub fn ois4 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Output Idle state 4"] pub fn set_ois4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "COM interrupt enable"] pub fn comie (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "COM interrupt enable"] pub fn set_comie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break interrupt enable"] pub fn bie (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break interrupt enable"] pub fn set_bie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "COM DMA request enable"] pub fn comde (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "COM DMA request enable"] pub fn set_comde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "COM interrupt flag"] pub fn comif (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "COM interrupt flag"] pub fn set_comif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break interrupt flag"] pub fn bif (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break interrupt flag"] pub fn set_bif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare control update\n              generation"] pub fn comg (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare control update\n              generation"] pub fn set_comg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Break generation"] pub fn bg (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Break generation"] pub fn set_bg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output Compare 1 fast\n              enable"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output Compare 1 fast\n              enable"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output Compare 1 preload\n              enable"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output Compare 1 preload\n              enable"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output Compare 1 mode"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output Compare 1 mode"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Output Compare 1 clear\n              enable"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output Compare 1 clear\n              enable"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output Compare 2 fast\n              enable"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output Compare 2 fast\n              enable"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output Compare 2 preload\n              enable"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output Compare 2 preload\n              enable"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output Compare 2 mode"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Output Compare 2 mode"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output Compare 2 clear\n              enable"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Output Compare 2 clear\n              enable"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Output compare 3 fast\n              enable"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Output compare 3 fast\n              enable"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Output compare 3 preload\n              enable"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Output compare 3 preload\n              enable"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Output compare 3 mode"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Output compare 3 mode"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Output compare 3 clear\n              enable"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Output compare 3 clear\n              enable"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Output compare 4 fast\n              enable"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Output compare 4 fast\n              enable"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Output compare 4 preload\n              enable"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Output compare 4 preload\n              enable"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Output compare 4 mode"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "Output compare 4 mode"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Output compare 4 clear\n              enable"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Output compare 4 clear\n              enable"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 complementary output\n              enable"] pub fn cc1ne (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 1 complementary output\n              enable"] pub fn set_cc1ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 complementary output\n              enable"] pub fn cc2ne (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Capture/Compare 2 complementary output\n              enable"] pub fn set_cc2ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 complementary output\n              enable"] pub fn cc3ne (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 3 complementary output\n              enable"] pub fn set_cc3ne (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "counter value"] pub fn cnt (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "counter value"] pub fn set_cnt (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Auto-reload value"] pub fn arr (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Auto-reload value"] pub fn set_arr (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "repetition counter register"] pub struct RCR (u32) ; impl RCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Repetition counter value"] pub fn rep (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Repetition counter value"] pub fn set_rep (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 value"] pub fn ccr1 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 1 value"] pub fn set_ccr1 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 2 value"] pub fn ccr2 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare 2 value"] pub fn set_ccr2 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn ccr3 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare value"] pub fn set_ccr3 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare value"] pub fn ccr4 (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Capture/Compare value"] pub fn set_ccr4 (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "break and dead-time register"] pub struct BDTR (u32) ; impl BDTR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Dead-time generator setup"] pub fn dtg (& self) -> u32 { (self . 0 >> 0u32) & 255u32 } # [doc = "Dead-time generator setup"] pub fn set_dtg (& mut self , value : u32) { let value_masked = value & 255u32 ; self . 0 &= ! (255u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Lock configuration"] pub fn lock (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Lock configuration"] pub fn set_lock (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Off-state selection for Idle\n              mode"] pub fn ossi (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Off-state selection for Idle\n              mode"] pub fn set_ossi (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Off-state selection for Run\n              mode"] pub fn ossr (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Off-state selection for Run\n              mode"] pub fn set_ossr (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Break enable"] pub fn bke (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Break enable"] pub fn set_bke (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Break polarity"] pub fn bkp (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Break polarity"] pub fn set_bkp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Automatic output enable"] pub fn aoe (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Automatic output enable"] pub fn set_aoe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Main output enable"] pub fn moe (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Main output enable"] pub fn set_moe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod exti { # [doc = "External interrupt/event\n      controller"] pub struct EXTI ; impl EXTI { pub const BASE_ADDR : u64 = 1073822720u64 ; } # [doc = "Interrupt mask register\n          (EXTI_IMR)"] pub struct IMR (u32) ; impl IMR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Interrupt Mask on line 0"] pub fn mr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Interrupt Mask on line 0"] pub fn set_mr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Interrupt Mask on line 1"] pub fn mr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Interrupt Mask on line 1"] pub fn set_mr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Interrupt Mask on line 2"] pub fn mr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Interrupt Mask on line 2"] pub fn set_mr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Interrupt Mask on line 3"] pub fn mr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Interrupt Mask on line 3"] pub fn set_mr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Interrupt Mask on line 4"] pub fn mr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Interrupt Mask on line 4"] pub fn set_mr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Interrupt Mask on line 5"] pub fn mr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Interrupt Mask on line 5"] pub fn set_mr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Interrupt Mask on line 6"] pub fn mr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Interrupt Mask on line 6"] pub fn set_mr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Interrupt Mask on line 7"] pub fn mr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Interrupt Mask on line 7"] pub fn set_mr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Interrupt Mask on line 8"] pub fn mr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Interrupt Mask on line 8"] pub fn set_mr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Interrupt Mask on line 9"] pub fn mr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Interrupt Mask on line 9"] pub fn set_mr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Interrupt Mask on line 10"] pub fn mr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Interrupt Mask on line 10"] pub fn set_mr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Interrupt Mask on line 11"] pub fn mr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Interrupt Mask on line 11"] pub fn set_mr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Interrupt Mask on line 12"] pub fn mr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Interrupt Mask on line 12"] pub fn set_mr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Interrupt Mask on line 13"] pub fn mr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Interrupt Mask on line 13"] pub fn set_mr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Interrupt Mask on line 14"] pub fn mr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Interrupt Mask on line 14"] pub fn set_mr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Interrupt Mask on line 15"] pub fn mr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Interrupt Mask on line 15"] pub fn set_mr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Interrupt Mask on line 16"] pub fn mr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Interrupt Mask on line 16"] pub fn set_mr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Interrupt Mask on line 17"] pub fn mr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Interrupt Mask on line 17"] pub fn set_mr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Interrupt Mask on line 18"] pub fn mr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Interrupt Mask on line 18"] pub fn set_mr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Interrupt Mask on line 19"] pub fn mr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Interrupt Mask on line 19"] pub fn set_mr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Interrupt Mask on line 20"] pub fn mr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Interrupt Mask on line 20"] pub fn set_mr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Interrupt Mask on line 21"] pub fn mr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Interrupt Mask on line 21"] pub fn set_mr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Interrupt Mask on line 22"] pub fn mr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Interrupt Mask on line 22"] pub fn set_mr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Event mask register (EXTI_EMR)"] pub struct EMR (u32) ; impl EMR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Event Mask on line 0"] pub fn mr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Event Mask on line 0"] pub fn set_mr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Event Mask on line 1"] pub fn mr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Event Mask on line 1"] pub fn set_mr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Event Mask on line 2"] pub fn mr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Event Mask on line 2"] pub fn set_mr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Event Mask on line 3"] pub fn mr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Event Mask on line 3"] pub fn set_mr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Event Mask on line 4"] pub fn mr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Event Mask on line 4"] pub fn set_mr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Event Mask on line 5"] pub fn mr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Event Mask on line 5"] pub fn set_mr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Event Mask on line 6"] pub fn mr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Event Mask on line 6"] pub fn set_mr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Event Mask on line 7"] pub fn mr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Event Mask on line 7"] pub fn set_mr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Event Mask on line 8"] pub fn mr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Event Mask on line 8"] pub fn set_mr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Event Mask on line 9"] pub fn mr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Event Mask on line 9"] pub fn set_mr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Event Mask on line 10"] pub fn mr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Event Mask on line 10"] pub fn set_mr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Event Mask on line 11"] pub fn mr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Event Mask on line 11"] pub fn set_mr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Event Mask on line 12"] pub fn mr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Event Mask on line 12"] pub fn set_mr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Event Mask on line 13"] pub fn mr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Event Mask on line 13"] pub fn set_mr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Event Mask on line 14"] pub fn mr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Event Mask on line 14"] pub fn set_mr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Event Mask on line 15"] pub fn mr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Event Mask on line 15"] pub fn set_mr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Event Mask on line 16"] pub fn mr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Event Mask on line 16"] pub fn set_mr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Event Mask on line 17"] pub fn mr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Event Mask on line 17"] pub fn set_mr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Event Mask on line 18"] pub fn mr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Event Mask on line 18"] pub fn set_mr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Event Mask on line 19"] pub fn mr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Event Mask on line 19"] pub fn set_mr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Event Mask on line 20"] pub fn mr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Event Mask on line 20"] pub fn set_mr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Event Mask on line 21"] pub fn mr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Event Mask on line 21"] pub fn set_mr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Event Mask on line 22"] pub fn mr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Event Mask on line 22"] pub fn set_mr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Rising Trigger selection register\n          (EXTI_RTSR)"] pub struct RTSR (u32) ; impl RTSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Rising trigger event configuration of\n              line 0"] pub fn tr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 0"] pub fn set_tr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Rising trigger event configuration of\n              line 1"] pub fn tr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 1"] pub fn set_tr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Rising trigger event configuration of\n              line 2"] pub fn tr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 2"] pub fn set_tr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Rising trigger event configuration of\n              line 3"] pub fn tr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 3"] pub fn set_tr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Rising trigger event configuration of\n              line 4"] pub fn tr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 4"] pub fn set_tr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Rising trigger event configuration of\n              line 5"] pub fn tr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 5"] pub fn set_tr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Rising trigger event configuration of\n              line 6"] pub fn tr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 6"] pub fn set_tr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Rising trigger event configuration of\n              line 7"] pub fn tr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 7"] pub fn set_tr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Rising trigger event configuration of\n              line 8"] pub fn tr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 8"] pub fn set_tr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Rising trigger event configuration of\n              line 9"] pub fn tr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 9"] pub fn set_tr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Rising trigger event configuration of\n              line 10"] pub fn tr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 10"] pub fn set_tr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Rising trigger event configuration of\n              line 11"] pub fn tr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 11"] pub fn set_tr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Rising trigger event configuration of\n              line 12"] pub fn tr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 12"] pub fn set_tr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Rising trigger event configuration of\n              line 13"] pub fn tr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 13"] pub fn set_tr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Rising trigger event configuration of\n              line 14"] pub fn tr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 14"] pub fn set_tr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Rising trigger event configuration of\n              line 15"] pub fn tr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 15"] pub fn set_tr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Rising trigger event configuration of\n              line 16"] pub fn tr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 16"] pub fn set_tr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Rising trigger event configuration of\n              line 17"] pub fn tr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 17"] pub fn set_tr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Rising trigger event configuration of\n              line 18"] pub fn tr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 18"] pub fn set_tr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Rising trigger event configuration of\n              line 19"] pub fn tr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 19"] pub fn set_tr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Rising trigger event configuration of\n              line 20"] pub fn tr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 20"] pub fn set_tr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Rising trigger event configuration of\n              line 21"] pub fn tr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 21"] pub fn set_tr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Rising trigger event configuration of\n              line 22"] pub fn tr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Rising trigger event configuration of\n              line 22"] pub fn set_tr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Falling Trigger selection register\n          (EXTI_FTSR)"] pub struct FTSR (u32) ; impl FTSR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Falling trigger event configuration of\n              line 0"] pub fn tr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 0"] pub fn set_tr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Falling trigger event configuration of\n              line 1"] pub fn tr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 1"] pub fn set_tr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Falling trigger event configuration of\n              line 2"] pub fn tr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 2"] pub fn set_tr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Falling trigger event configuration of\n              line 3"] pub fn tr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 3"] pub fn set_tr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Falling trigger event configuration of\n              line 4"] pub fn tr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 4"] pub fn set_tr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Falling trigger event configuration of\n              line 5"] pub fn tr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 5"] pub fn set_tr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Falling trigger event configuration of\n              line 6"] pub fn tr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 6"] pub fn set_tr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Falling trigger event configuration of\n              line 7"] pub fn tr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 7"] pub fn set_tr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Falling trigger event configuration of\n              line 8"] pub fn tr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 8"] pub fn set_tr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Falling trigger event configuration of\n              line 9"] pub fn tr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 9"] pub fn set_tr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Falling trigger event configuration of\n              line 10"] pub fn tr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 10"] pub fn set_tr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Falling trigger event configuration of\n              line 11"] pub fn tr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 11"] pub fn set_tr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Falling trigger event configuration of\n              line 12"] pub fn tr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 12"] pub fn set_tr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Falling trigger event configuration of\n              line 13"] pub fn tr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 13"] pub fn set_tr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Falling trigger event configuration of\n              line 14"] pub fn tr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 14"] pub fn set_tr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Falling trigger event configuration of\n              line 15"] pub fn tr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 15"] pub fn set_tr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Falling trigger event configuration of\n              line 16"] pub fn tr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 16"] pub fn set_tr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Falling trigger event configuration of\n              line 17"] pub fn tr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 17"] pub fn set_tr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Falling trigger event configuration of\n              line 18"] pub fn tr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 18"] pub fn set_tr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Falling trigger event configuration of\n              line 19"] pub fn tr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 19"] pub fn set_tr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Falling trigger event configuration of\n              line 20"] pub fn tr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 20"] pub fn set_tr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Falling trigger event configuration of\n              line 21"] pub fn tr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 21"] pub fn set_tr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Falling trigger event configuration of\n              line 22"] pub fn tr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Falling trigger event configuration of\n              line 22"] pub fn set_tr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Software interrupt event register\n          (EXTI_SWIER)"] pub struct SWIER (u32) ; impl SWIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Software Interrupt on line\n              0"] pub fn swier0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Software Interrupt on line\n              0"] pub fn set_swier0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Software Interrupt on line\n              1"] pub fn swier1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Software Interrupt on line\n              1"] pub fn set_swier1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Software Interrupt on line\n              2"] pub fn swier2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Software Interrupt on line\n              2"] pub fn set_swier2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Software Interrupt on line\n              3"] pub fn swier3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Software Interrupt on line\n              3"] pub fn set_swier3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Software Interrupt on line\n              4"] pub fn swier4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Software Interrupt on line\n              4"] pub fn set_swier4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Software Interrupt on line\n              5"] pub fn swier5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Software Interrupt on line\n              5"] pub fn set_swier5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Software Interrupt on line\n              6"] pub fn swier6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Software Interrupt on line\n              6"] pub fn set_swier6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Software Interrupt on line\n              7"] pub fn swier7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Software Interrupt on line\n              7"] pub fn set_swier7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Software Interrupt on line\n              8"] pub fn swier8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Software Interrupt on line\n              8"] pub fn set_swier8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Software Interrupt on line\n              9"] pub fn swier9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Software Interrupt on line\n              9"] pub fn set_swier9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Software Interrupt on line\n              10"] pub fn swier10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Software Interrupt on line\n              10"] pub fn set_swier10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Software Interrupt on line\n              11"] pub fn swier11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Software Interrupt on line\n              11"] pub fn set_swier11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Software Interrupt on line\n              12"] pub fn swier12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Software Interrupt on line\n              12"] pub fn set_swier12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Software Interrupt on line\n              13"] pub fn swier13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Software Interrupt on line\n              13"] pub fn set_swier13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Software Interrupt on line\n              14"] pub fn swier14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Software Interrupt on line\n              14"] pub fn set_swier14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Software Interrupt on line\n              15"] pub fn swier15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Software Interrupt on line\n              15"] pub fn set_swier15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Software Interrupt on line\n              16"] pub fn swier16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Software Interrupt on line\n              16"] pub fn set_swier16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Software Interrupt on line\n              17"] pub fn swier17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Software Interrupt on line\n              17"] pub fn set_swier17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Software Interrupt on line\n              18"] pub fn swier18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Software Interrupt on line\n              18"] pub fn set_swier18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Software Interrupt on line\n              19"] pub fn swier19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Software Interrupt on line\n              19"] pub fn set_swier19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Software Interrupt on line\n              20"] pub fn swier20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Software Interrupt on line\n              20"] pub fn set_swier20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Software Interrupt on line\n              21"] pub fn swier21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Software Interrupt on line\n              21"] pub fn set_swier21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Software Interrupt on line\n              22"] pub fn swier22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Software Interrupt on line\n              22"] pub fn set_swier22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Pending register (EXTI_PR)"] pub struct PR (u32) ; impl PR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Pending bit 0"] pub fn pr0 (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Pending bit 0"] pub fn set_pr0 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Pending bit 1"] pub fn pr1 (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Pending bit 1"] pub fn set_pr1 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Pending bit 2"] pub fn pr2 (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Pending bit 2"] pub fn set_pr2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Pending bit 3"] pub fn pr3 (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Pending bit 3"] pub fn set_pr3 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Pending bit 4"] pub fn pr4 (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Pending bit 4"] pub fn set_pr4 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Pending bit 5"] pub fn pr5 (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Pending bit 5"] pub fn set_pr5 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Pending bit 6"] pub fn pr6 (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Pending bit 6"] pub fn set_pr6 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Pending bit 7"] pub fn pr7 (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Pending bit 7"] pub fn set_pr7 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Pending bit 8"] pub fn pr8 (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Pending bit 8"] pub fn set_pr8 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Pending bit 9"] pub fn pr9 (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Pending bit 9"] pub fn set_pr9 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Pending bit 10"] pub fn pr10 (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Pending bit 10"] pub fn set_pr10 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Pending bit 11"] pub fn pr11 (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Pending bit 11"] pub fn set_pr11 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Pending bit 12"] pub fn pr12 (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Pending bit 12"] pub fn set_pr12 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Pending bit 13"] pub fn pr13 (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Pending bit 13"] pub fn set_pr13 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Pending bit 14"] pub fn pr14 (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Pending bit 14"] pub fn set_pr14 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "Pending bit 15"] pub fn pr15 (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Pending bit 15"] pub fn set_pr15 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } # [doc = "Pending bit 16"] pub fn pr16 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "Pending bit 16"] pub fn set_pr16 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } # [doc = "Pending bit 17"] pub fn pr17 (& self) -> u32 { (self . 0 >> 17u32) & 1u32 } # [doc = "Pending bit 17"] pub fn set_pr17 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 17u32) ; self . 0 |= value_masked << 17u32 ; } # [doc = "Pending bit 18"] pub fn pr18 (& self) -> u32 { (self . 0 >> 18u32) & 1u32 } # [doc = "Pending bit 18"] pub fn set_pr18 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 18u32) ; self . 0 |= value_masked << 18u32 ; } # [doc = "Pending bit 19"] pub fn pr19 (& self) -> u32 { (self . 0 >> 19u32) & 1u32 } # [doc = "Pending bit 19"] pub fn set_pr19 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 19u32) ; self . 0 |= value_masked << 19u32 ; } # [doc = "Pending bit 20"] pub fn pr20 (& self) -> u32 { (self . 0 >> 20u32) & 1u32 } # [doc = "Pending bit 20"] pub fn set_pr20 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 20u32) ; self . 0 |= value_masked << 20u32 ; } # [doc = "Pending bit 21"] pub fn pr21 (& self) -> u32 { (self . 0 >> 21u32) & 1u32 } # [doc = "Pending bit 21"] pub fn set_pr21 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 21u32) ; self . 0 |= value_masked << 21u32 ; } # [doc = "Pending bit 22"] pub fn pr22 (& self) -> u32 { (self . 0 >> 22u32) & 1u32 } # [doc = "Pending bit 22"] pub fn set_pr22 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 22u32) ; self . 0 |= value_masked << 22u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod tim4 { # [doc = "General purpose timers"] pub struct TIM4 ; impl TIM4 { pub const BASE_ADDR : u64 = 1073743872u64 ; } # [doc = "control register 1"] pub struct CR1 (u32) ; impl CR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Counter enable"] pub fn cen (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Counter enable"] pub fn set_cen (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Update disable"] pub fn udis (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Update disable"] pub fn set_udis (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Update request source"] pub fn urs (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Update request source"] pub fn set_urs (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "One-pulse mode"] pub fn opm (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "One-pulse mode"] pub fn set_opm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Direction"] pub fn dir (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Direction"] pub fn set_dir (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Center-aligned mode\n              selection"] pub fn cms (& self) -> u32 { (self . 0 >> 5u32) & 3u32 } # [doc = "Center-aligned mode\n              selection"] pub fn set_cms (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Auto-reload preload enable"] pub fn arpe (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Auto-reload preload enable"] pub fn set_arpe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Clock division"] pub fn ckd (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Clock division"] pub fn set_ckd (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "control register 2"] pub struct CR2 (u32) ; impl CR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare DMA\n              selection"] pub fn ccds (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare DMA\n              selection"] pub fn set_ccds (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Master mode selection"] pub fn mms (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Master mode selection"] pub fn set_mms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "TI1 selection"] pub fn ti1s (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "TI1 selection"] pub fn set_ti1s (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "slave mode control register"] pub struct SMCR (u32) ; impl SMCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Slave mode selection"] pub fn sms (& self) -> u32 { (self . 0 >> 0u32) & 7u32 } # [doc = "Slave mode selection"] pub fn set_sms (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Trigger selection"] pub fn ts (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "Trigger selection"] pub fn set_ts (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Master/Slave mode"] pub fn msm (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Master/Slave mode"] pub fn set_msm (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "External trigger filter"] pub fn etf (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "External trigger filter"] pub fn set_etf (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "External trigger prescaler"] pub fn etps (& self) -> u32 { (self . 0 >> 12u32) & 3u32 } # [doc = "External trigger prescaler"] pub fn set_etps (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "External clock enable"] pub fn ece (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "External clock enable"] pub fn set_ece (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } # [doc = "External trigger polarity"] pub fn etp (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "External trigger polarity"] pub fn set_etp (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA/Interrupt enable register"] pub struct DIER (u32) ; impl DIER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt enable"] pub fn uie (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt enable"] pub fn set_uie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn cc1ie (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 interrupt\n              enable"] pub fn set_cc1ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn cc2ie (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              enable"] pub fn set_cc2ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn cc3ie (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              enable"] pub fn set_cc3ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn cc4ie (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              enable"] pub fn set_cc4ie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt enable"] pub fn tie (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt enable"] pub fn set_tie (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Update DMA request enable"] pub fn ude (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Update DMA request enable"] pub fn set_ude (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn cc1de (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 DMA request\n              enable"] pub fn set_cc1de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn cc2de (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/Compare 2 DMA request\n              enable"] pub fn set_cc2de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn cc3de (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 DMA request\n              enable"] pub fn set_cc3de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn cc4de (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 DMA request\n              enable"] pub fn set_cc4de (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Trigger DMA request enable"] pub fn tde (& self) -> u32 { (self . 0 >> 14u32) & 1u32 } # [doc = "Trigger DMA request enable"] pub fn set_tde (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 14u32) ; self . 0 |= value_masked << 14u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "status register"] pub struct SR (u32) ; impl SR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update interrupt flag"] pub fn uif (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update interrupt flag"] pub fn set_uif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn cc1if (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1 interrupt\n              flag"] pub fn set_cc1if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn cc2if (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/Compare 2 interrupt\n              flag"] pub fn set_cc2if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn cc3if (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 3 interrupt\n              flag"] pub fn set_cc3if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn cc4if (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 4 interrupt\n              flag"] pub fn set_cc4if (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger interrupt flag"] pub fn tif (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger interrupt flag"] pub fn set_tif (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn cc1of (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 1 overcapture\n              flag"] pub fn set_cc1of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn cc2of (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "Capture/compare 2 overcapture\n              flag"] pub fn set_cc2of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn cc3of (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 overcapture\n              flag"] pub fn set_cc3of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn cc4of (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 overcapture\n              flag"] pub fn set_cc4of (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "event generation register"] pub struct EGR (u32) ; impl EGR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Update generation"] pub fn ug (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Update generation"] pub fn set_ug (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/compare 1\n              generation"] pub fn cc1g (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/compare 1\n              generation"] pub fn set_cc1g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/compare 2\n              generation"] pub fn cc2g (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "Capture/compare 2\n              generation"] pub fn set_cc2g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Capture/compare 3\n              generation"] pub fn cc3g (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/compare 3\n              generation"] pub fn set_cc3g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/compare 4\n              generation"] pub fn cc4g (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/compare 4\n              generation"] pub fn set_cc4g (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Trigger generation"] pub fn tg (& self) -> u32 { (self . 0 >> 6u32) & 1u32 } # [doc = "Trigger generation"] pub fn set_tg (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 6u32) ; self . 0 |= value_masked << 6u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (output\n          mode)"] pub struct CCMR1_Output (u32) ; impl CCMR1_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC1S"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC1S"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC1FE"] pub fn oc1fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC1FE"] pub fn set_oc1fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC1PE"] pub fn oc1pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC1PE"] pub fn set_oc1pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC1M"] pub fn oc1m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC1M"] pub fn set_oc1m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC1CE"] pub fn oc1ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC1CE"] pub fn set_oc1ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC2S"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC2S"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC2FE"] pub fn oc2fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC2FE"] pub fn set_oc2fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC2PE"] pub fn oc2pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC2PE"] pub fn set_oc2pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC2M"] pub fn oc2m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC2M"] pub fn set_oc2m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC2CE"] pub fn oc2ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC2CE"] pub fn set_oc2ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 1 (input\n          mode)"] pub struct CCMR1_Input (u32) ; impl CCMR1_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1\n              selection"] pub fn cc1s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/Compare 1\n              selection"] pub fn set_cc1s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 1 prescaler"] pub fn icpcs (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 1 prescaler"] pub fn set_icpcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 1 filter"] pub fn ic1f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 1 filter"] pub fn set_ic1f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2\n              selection"] pub fn cc2s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 2\n              selection"] pub fn set_cc2s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 2 prescaler"] pub fn ic2pcs (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 2 prescaler"] pub fn set_ic2pcs (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 2 filter"] pub fn ic2f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 2 filter"] pub fn set_ic2f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (output\n          mode)"] pub struct CCMR2_Output (u32) ; impl CCMR2_Output { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "CC3S"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "CC3S"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "OC3FE"] pub fn oc3fe (& self) -> u32 { (self . 0 >> 2u32) & 1u32 } # [doc = "OC3FE"] pub fn set_oc3fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "OC3PE"] pub fn oc3pe (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "OC3PE"] pub fn set_oc3pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "OC3M"] pub fn oc3m (& self) -> u32 { (self . 0 >> 4u32) & 7u32 } # [doc = "OC3M"] pub fn set_oc3m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "OC3CE"] pub fn oc3ce (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "OC3CE"] pub fn set_oc3ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "CC4S"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "CC4S"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "OC4FE"] pub fn oc4fe (& self) -> u32 { (self . 0 >> 10u32) & 1u32 } # [doc = "OC4FE"] pub fn set_oc4fe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "OC4PE"] pub fn oc4pe (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "OC4PE"] pub fn set_oc4pe (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "OC4M"] pub fn oc4m (& self) -> u32 { (self . 0 >> 12u32) & 7u32 } # [doc = "OC4M"] pub fn set_oc4m (& mut self , value : u32) { let value_masked = value & 7u32 ; self . 0 &= ! (7u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "OC4CE"] pub fn oc4ce (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "OC4CE"] pub fn set_oc4ce (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare mode register 2 (input\n          mode)"] pub struct CCMR2_Input (u32) ; impl CCMR2_Input { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/compare 3\n              selection"] pub fn cc3s (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "Capture/compare 3\n              selection"] pub fn set_cc3s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Input capture 3 prescaler"] pub fn ic3psc (& self) -> u32 { (self . 0 >> 2u32) & 3u32 } # [doc = "Input capture 3 prescaler"] pub fn set_ic3psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 2u32) ; self . 0 |= value_masked << 2u32 ; } # [doc = "Input capture 3 filter"] pub fn ic3f (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "Input capture 3 filter"] pub fn set_ic3f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 4\n              selection"] pub fn cc4s (& self) -> u32 { (self . 0 >> 8u32) & 3u32 } # [doc = "Capture/Compare 4\n              selection"] pub fn set_cc4s (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Input capture 4 prescaler"] pub fn ic4psc (& self) -> u32 { (self . 0 >> 10u32) & 3u32 } # [doc = "Input capture 4 prescaler"] pub fn set_ic4psc (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 10u32) ; self . 0 |= value_masked << 10u32 ; } # [doc = "Input capture 4 filter"] pub fn ic4f (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "Input capture 4 filter"] pub fn set_ic4f (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare enable\n          register"] pub struct CCER (u32) ; impl CCER { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Capture/Compare 1 output\n              enable"] pub fn cc1e (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              enable"] pub fn set_cc1e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1p (& self) -> u32 { (self . 0 >> 1u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 1u32) ; self . 0 |= value_masked << 1u32 ; } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn cc1np (& self) -> u32 { (self . 0 >> 3u32) & 1u32 } # [doc = "Capture/Compare 1 output\n              Polarity"] pub fn set_cc1np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 3u32) ; self . 0 |= value_masked << 3u32 ; } # [doc = "Capture/Compare 2 output\n              enable"] pub fn cc2e (& self) -> u32 { (self . 0 >> 4u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              enable"] pub fn set_cc2e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2p (& self) -> u32 { (self . 0 >> 5u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 5u32) ; self . 0 |= value_masked << 5u32 ; } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn cc2np (& self) -> u32 { (self . 0 >> 7u32) & 1u32 } # [doc = "Capture/Compare 2 output\n              Polarity"] pub fn set_cc2np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 7u32) ; self . 0 |= value_masked << 7u32 ; } # [doc = "Capture/Compare 3 output\n              enable"] pub fn cc3e (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              enable"] pub fn set_cc3e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3p (& self) -> u32 { (self . 0 >> 9u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 9u32) ; self . 0 |= value_masked << 9u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc3np (& self) -> u32 { (self . 0 >> 11u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc3np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 11u32) ; self . 0 |= value_masked << 11u32 ; } # [doc = "Capture/Compare 4 output\n              enable"] pub fn cc4e (& self) -> u32 { (self . 0 >> 12u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              enable"] pub fn set_cc4e (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn cc4p (& self) -> u32 { (self . 0 >> 13u32) & 1u32 } # [doc = "Capture/Compare 3 output\n              Polarity"] pub fn set_cc4p (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 13u32) ; self . 0 |= value_masked << 13u32 ; } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn cc4np (& self) -> u32 { (self . 0 >> 15u32) & 1u32 } # [doc = "Capture/Compare 4 output\n              Polarity"] pub fn set_cc4np (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 15u32) ; self . 0 |= value_masked << 15u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "counter"] pub struct CNT (u32) ; impl CNT { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low counter value"] pub fn cnt_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low counter value"] pub fn set_cnt_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High counter value"] pub fn cnt_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High counter value"] pub fn set_cnt_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "prescaler"] pub struct PSC (u32) ; impl PSC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Prescaler value"] pub fn psc (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Prescaler value"] pub fn set_psc (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "auto-reload register"] pub struct ARR (u32) ; impl ARR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Auto-reload value"] pub fn arr_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Auto-reload value"] pub fn set_arr_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Auto-reload value"] pub fn arr_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Auto-reload value"] pub fn set_arr_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 1"] pub struct CCR1 (u32) ; impl CCR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 1\n              value"] pub fn ccr1_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 1\n              value"] pub fn set_ccr1_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 1\n              value"] pub fn ccr1_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 1\n              value"] pub fn set_ccr1_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 2"] pub struct CCR2 (u32) ; impl CCR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare 2\n              value"] pub fn ccr2_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare 2\n              value"] pub fn set_ccr2_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare 2\n              value"] pub fn ccr2_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare 2\n              value"] pub fn set_ccr2_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 3"] pub struct CCR3 (u32) ; impl CCR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr3_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr3_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr3_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr3_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "capture/compare register 4"] pub struct CCR4 (u32) ; impl CCR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Low Capture/Compare value"] pub fn ccr4_l (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "Low Capture/Compare value"] pub fn set_ccr4_l (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "High Capture/Compare value"] pub fn ccr4_h (& self) -> u32 { (self . 0 >> 16u32) & 65535u32 } # [doc = "High Capture/Compare value"] pub fn set_ccr4_h (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA control register"] pub struct DCR (u32) ; impl DCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA base address"] pub fn dba (& self) -> u32 { (self . 0 >> 0u32) & 31u32 } # [doc = "DMA base address"] pub fn set_dba (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "DMA burst length"] pub fn dbl (& self) -> u32 { (self . 0 >> 8u32) & 31u32 } # [doc = "DMA burst length"] pub fn set_dbl (& mut self , value : u32) { let value_masked = value & 31u32 ; self . 0 &= ! (31u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "DMA address for full transfer"] pub struct DMAR (u32) ; impl DMAR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "DMA register for burst\n              accesses"] pub fn dmab (& self) -> u32 { (self . 0 >> 0u32) & 65535u32 } # [doc = "DMA register for burst\n              accesses"] pub fn set_dmab (& mut self , value : u32) { let value_masked = value & 65535u32 ; self . 0 &= ! (65535u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }

pub mod syscfg { # [doc = "System configuration controller"] pub struct SYSCFG ; impl SYSCFG { pub const BASE_ADDR : u64 = 1073821696u64 ; } # [doc = "memory remap register"] pub struct MEMRM (u32) ; impl MEMRM { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "MEM_MODE"] pub fn mem_mode (& self) -> u32 { (self . 0 >> 0u32) & 3u32 } # [doc = "MEM_MODE"] pub fn set_mem_mode (& mut self , value : u32) { let value_masked = value & 3u32 ; self . 0 &= ! (3u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "peripheral mode configuration\n          register"] pub struct PMC (u32) ; impl PMC { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "ADC1DC2"] pub fn adc1dc2 (& self) -> u32 { (self . 0 >> 16u32) & 1u32 } # [doc = "ADC1DC2"] pub fn set_adc1dc2 (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 16u32) ; self . 0 |= value_masked << 16u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "external interrupt configuration register\n          1"] pub struct EXTICR1 (u32) ; impl EXTICR1 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn exti0 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn set_exti0 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn exti1 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn set_exti1 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn exti2 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn set_exti2 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn exti3 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "EXTI x configuration (x = 0 to\n              3)"] pub fn set_exti3 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "external interrupt configuration register\n          2"] pub struct EXTICR2 (u32) ; impl EXTICR2 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn exti4 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn set_exti4 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn exti5 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn set_exti5 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn exti6 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn set_exti6 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn exti7 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "EXTI x configuration (x = 4 to\n              7)"] pub fn set_exti7 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "external interrupt configuration register\n          3"] pub struct EXTICR3 (u32) ; impl EXTICR3 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn exti8 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn set_exti8 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn exti9 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn set_exti9 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "EXTI10"] pub fn exti10 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "EXTI10"] pub fn set_exti10 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn exti11 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "EXTI x configuration (x = 8 to\n              11)"] pub fn set_exti11 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "external interrupt configuration register\n          4"] pub struct EXTICR4 (u32) ; impl EXTICR4 { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn exti12 (& self) -> u32 { (self . 0 >> 0u32) & 15u32 } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn set_exti12 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn exti13 (& self) -> u32 { (self . 0 >> 4u32) & 15u32 } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn set_exti13 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 4u32) ; self . 0 |= value_masked << 4u32 ; } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn exti14 (& self) -> u32 { (self . 0 >> 8u32) & 15u32 } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn set_exti14 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn exti15 (& self) -> u32 { (self . 0 >> 12u32) & 15u32 } # [doc = "EXTI x configuration (x = 12 to\n              15)"] pub fn set_exti15 (& mut self , value : u32) { let value_masked = value & 15u32 ; self . 0 &= ! (15u32 << 12u32) ; self . 0 |= value_masked << 12u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } # [doc = "Compensation cell control\n          register"] pub struct CMPCR (u32) ; impl CMPCR { pub const RESET_VALUE : u32 = 0u64 as u32 ; pub fn new () -> Self { Self (Self :: RESET_VALUE) } pub fn reset (& mut self) { self . 0 = Self :: RESET_VALUE ; } # [doc = "Compensation cell\n              power-down"] pub fn cmp_pd (& self) -> u32 { (self . 0 >> 0u32) & 1u32 } # [doc = "Compensation cell\n              power-down"] pub fn set_cmp_pd (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 0u32) ; self . 0 |= value_masked << 0u32 ; } # [doc = "READY"] pub fn ready (& self) -> u32 { (self . 0 >> 8u32) & 1u32 } # [doc = "READY"] pub fn set_ready (& mut self , value : u32) { let value_masked = value & 1u32 ; self . 0 &= ! (1u32 << 8u32) ; self . 0 |= value_masked << 8u32 ; } pub fn raw (& self) -> u32 { self . 0 } pub fn set_raw (& mut self , value : u32) { self . 0 = value ; } } }
